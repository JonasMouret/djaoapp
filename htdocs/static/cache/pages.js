!function(t){var n={};function e(i){if(n[i])return n[i].exports;var o=n[i]={i:i,l:!1,exports:{}};return t[i].call(o.exports,o,o.exports,e),o.l=!0,o.exports}e.m=t,e.c=n,e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:i})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(e.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var o in t)e.d(i,o,function(n){return t[n]}.bind(null,o));return i},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="/static/cache/",e(e.s=173)}({1:function(t,n){t.exports=function(t){function n(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):n("EvalError: No eval function available")}catch(t){n(t)}}},12:function(t,n,e){e(1)(e(13))},13:function(t,n){t.exports='/** These are plumbing functions to connect the UI and API backends.\n */\n\nfunction clearMessages() {\n    "use strict";\n    $("#messages-content").empty();\n};\n\nfunction showMessages(messages, style) {\n    "use strict";\n    if( typeof toastr !== \'undefined\'\n        && $(toastr.options.containerId).length > 0 ) {\n        for( var i = 0; i < messages.length; ++i ) {\n            toastr[style](messages[i]);\n        }\n\n    } else {\n        var messageBlock = "<div class=\\"alert alert-block";\n        if( style ) {\n            if( style === "error" ) {\n                style = "danger";\n            }\n            messageBlock += " alert-" + style;\n        }\n        messageBlock += "\\"><button type=\\"button\\" class=\\"close\\" data-dismiss=\\"alert\\">&times;</button>";\n\n        if( typeof messages === "string" ) {\n            messages = [messages];\n        }\n        for( var i = 0; i < messages.length; ++i ) {\n            messageBlock += "<div>" + messages[i] + "</div>";\n         }\n         messageBlock += "</div>";\n         $("#messages-content").append(messageBlock);\n    }\n    $("#messages").removeClass("hidden");\n    $("html, body").animate({\n        // scrollTop: $("#messages").offset().top - 50\n        // avoid weird animation when messages at the top:\n        scrollTop: $("body").offset().top\n    }, 500);\n};\n\n\n/**\n Decorates elements when details exist, otherwise return messages to be shown\n globally.\n\n This method takes a `resp` argument as passed by jQuery ajax calls.\n */\nfunction _showErrorMessages(resp) {\n    var messages = [];\n    if( typeof resp === "string" ) {\n        messages = [resp];\n    } else {\n        var data = resp.data || resp.responseJSON;\n        if( data && typeof data === "object" ) {\n            if( data.detail ) {\n                messages = [data.detail];\n            } else if( $.isArray(data) ) {\n                for( var idx = 0; idx < data.length; ++idx ) {\n                    messages = messages.concat(_showErrorMessages(data[idx]));\n                }\n            } else {\n                for( var key in data ) {\n                    if (data.hasOwnProperty(key)) {\n                        var message = data[key];\n                        if( $.isArray(data[key]) ) {\n                            message = "";\n                            var sep = "";\n                            for( var i = 0; i < data[key].length; ++i ) {\n                                var messagePart = data[key][i];\n                                if( typeof data[key][i] !== \'string\' ) {\n                                    messagePart = JSON.stringify(data[key][i]);\n                                }\n                                message += sep + messagePart;\n                                sep = ", ";\n                            }\n                        } else if( data[key].hasOwnProperty(\'detail\') ) {\n                            message = data[key].detail;\n                        }\n                        messages.push(key + ": " + message);\n                        var inputField = $("[name=\\"" + key + "\\"]");\n                        var parent = inputField.parents(\'.form-group\');\n                        inputField.addClass("is-invalid");\n                        parent.addClass("has-error");\n                        var help = parent.find(\'.invalid-feedback\');\n                        if( help.length > 0 ) { help.text(message); }\n                    }\n                }\n            }\n        } else if( resp.detail ) {\n            messages = [resp.detail];\n        }\n    }\n    return messages;\n};\n\n\nfunction showErrorMessages(resp) {\n    if( resp.status >= 500 && resp.status < 600 ) {\n        msg = "Err " + resp.status + ": " + resp.statusText;\n        if( _showErrorMessagesProviderNotified ) {\n            msg += "<br />" + _showErrorMessagesProviderNotified;\n        }\n        messages = [msg];\n    } else {\n        var messages = _showErrorMessages(resp);\n        if( messages.length === 0 ) {\n            messages = ["Err " + resp.status + ": " + resp.statusText];\n        }\n    }\n    showMessages(messages, "error");\n};\n\n\n/** Formats a date shown to the user.\n*/\nvar DATE_FORMAT = \'MMM DD, YYYY\';\n\n/** Retrieves the csrf-token from a <head> meta tag.\n\n    <meta name="csrf-token" content="{{csrf_token}}">\n*/\nfunction getMetaCSRFToken() {\n    "use strict";\n    var metas = document.getElementsByTagName(\'meta\');\n    for( var i = 0; i < metas.length; i++) {\n        if (metas[i].getAttribute("name") == "csrf-token") {\n            return metas[i].getAttribute("content");\n        }\n    }\n    return "";\n};\n\n/** Retrieves an URL query argument.\n\n    Example:\n\n        window.location = getUrlParameter(\'next\');\n*/\nfunction getUrlParameter(name) {\n    name = name.replace(/[\\[]/, \'\\\\[\').replace(/[\\]]/, \'\\\\]\');\n    var regex = new RegExp(\'[\\\\?&]\' + name + \'=([^&#]*)\');\n    var results = regex.exec(location.search);\n    return results === null ? \'\' : decodeURIComponent(results[1].replace(/\\+/g, \' \'));\n};\n'},14:function(t,n,e){e(1)(e(15))},15:function(t,n){t.exports='\n/*\n *\n * More info at [www.dropzonejs.com](http://www.dropzonejs.com)\n *\n * Copyright (c) 2012, Matias Meno\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n */\n\n(function() {\n  var Dropzone, Emitter, camelize, contentLoaded, detectVerticalSquash, drawImageIOSFix, noop, without,\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  noop = function() {};\n\n  Emitter = (function() {\n    function Emitter() {}\n\n    Emitter.prototype.addEventListener = Emitter.prototype.on;\n\n    Emitter.prototype.on = function(event, fn) {\n      this._callbacks = this._callbacks || {};\n      if (!this._callbacks[event]) {\n        this._callbacks[event] = [];\n      }\n      this._callbacks[event].push(fn);\n      return this;\n    };\n\n    Emitter.prototype.emit = function() {\n      var args, callback, callbacks, event, _i, _len;\n      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      this._callbacks = this._callbacks || {};\n      callbacks = this._callbacks[event];\n      if (callbacks) {\n        for (_i = 0, _len = callbacks.length; _i < _len; _i++) {\n          callback = callbacks[_i];\n          callback.apply(this, args);\n        }\n      }\n      return this;\n    };\n\n    Emitter.prototype.removeListener = Emitter.prototype.off;\n\n    Emitter.prototype.removeAllListeners = Emitter.prototype.off;\n\n    Emitter.prototype.removeEventListener = Emitter.prototype.off;\n\n    Emitter.prototype.off = function(event, fn) {\n      var callback, callbacks, i, _i, _len;\n      if (!this._callbacks || arguments.length === 0) {\n        this._callbacks = {};\n        return this;\n      }\n      callbacks = this._callbacks[event];\n      if (!callbacks) {\n        return this;\n      }\n      if (arguments.length === 1) {\n        delete this._callbacks[event];\n        return this;\n      }\n      for (i = _i = 0, _len = callbacks.length; _i < _len; i = ++_i) {\n        callback = callbacks[i];\n        if (callback === fn) {\n          callbacks.splice(i, 1);\n          break;\n        }\n      }\n      return this;\n    };\n\n    return Emitter;\n\n  })();\n\n  Dropzone = (function(_super) {\n    var extend, resolveOption;\n\n    __extends(Dropzone, _super);\n\n    Dropzone.prototype.Emitter = Emitter;\n\n\n    /*\n    This is a list of all available events you can register on a dropzone object.\n    \n    You can register an event handler like this:\n    \n        dropzone.on("dragEnter", function() { });\n     */\n\n    Dropzone.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];\n\n    Dropzone.prototype.defaultOptions = {\n      url: null,\n      method: "post",\n      withCredentials: false,\n      parallelUploads: 2,\n      uploadMultiple: false,\n      maxFilesize: 256,\n      paramName: "file",\n      createImageThumbnails: true,\n      maxThumbnailFilesize: 10,\n      thumbnailWidth: 120,\n      thumbnailHeight: 120,\n      filesizeBase: 1000,\n      maxFiles: null,\n      params: {},\n      clickable: true,\n      ignoreHiddenFiles: true,\n      acceptedFiles: null,\n      acceptedMimeTypes: null,\n      autoProcessQueue: true,\n      autoQueue: true,\n      addRemoveLinks: false,\n      previewsContainer: null,\n      hiddenInputContainer: "body",\n      capture: null,\n      dictDefaultMessage: "Drop files here to upload",\n      dictFallbackMessage: "Your browser does not support drag\'n\'drop file uploads.",\n      dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",\n      dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",\n      dictInvalidFileType: "You can\'t upload files of this type.",\n      dictResponseError: "Server responded with {{statusCode}} code.",\n      dictCancelUpload: "Cancel upload",\n      dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",\n      dictRemoveFile: "Remove file",\n      dictRemoveFileConfirmation: null,\n      dictMaxFilesExceeded: "You can not upload any more files.",\n      accept: function(file, done) {\n        return done();\n      },\n      init: function() {\n        return noop;\n      },\n      forceFallback: false,\n      fallback: function() {\n        var child, messageElement, span, _i, _len, _ref;\n        this.element.className = "" + this.element.className + " dz-browser-not-supported";\n        _ref = this.element.getElementsByTagName("div");\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          child = _ref[_i];\n          if (/(^| )dz-message($| )/.test(child.className)) {\n            messageElement = child;\n            child.className = "dz-message";\n            continue;\n          }\n        }\n        if (!messageElement) {\n          messageElement = Dropzone.createElement("<div class=\\"dz-message\\"><span></span></div>");\n          this.element.appendChild(messageElement);\n        }\n        span = messageElement.getElementsByTagName("span")[0];\n        if (span) {\n          if (span.textContent != null) {\n            span.textContent = this.options.dictFallbackMessage;\n          } else if (span.innerText != null) {\n            span.innerText = this.options.dictFallbackMessage;\n          }\n        }\n        return this.element.appendChild(this.getFallbackForm());\n      },\n      resize: function(file) {\n        var info, srcRatio, trgRatio;\n        info = {\n          srcX: 0,\n          srcY: 0,\n          srcWidth: file.width,\n          srcHeight: file.height\n        };\n        srcRatio = file.width / file.height;\n        info.optWidth = this.options.thumbnailWidth;\n        info.optHeight = this.options.thumbnailHeight;\n        if ((info.optWidth == null) && (info.optHeight == null)) {\n          info.optWidth = info.srcWidth;\n          info.optHeight = info.srcHeight;\n        } else if (info.optWidth == null) {\n          info.optWidth = srcRatio * info.optHeight;\n        } else if (info.optHeight == null) {\n          info.optHeight = (1 / srcRatio) * info.optWidth;\n        }\n        trgRatio = info.optWidth / info.optHeight;\n        if (file.height < info.optHeight || file.width < info.optWidth) {\n          info.trgHeight = info.srcHeight;\n          info.trgWidth = info.srcWidth;\n        } else {\n          if (srcRatio > trgRatio) {\n            info.srcHeight = file.height;\n            info.srcWidth = info.srcHeight * trgRatio;\n          } else {\n            info.srcWidth = file.width;\n            info.srcHeight = info.srcWidth / trgRatio;\n          }\n        }\n        info.srcX = (file.width - info.srcWidth) / 2;\n        info.srcY = (file.height - info.srcHeight) / 2;\n        return info;\n      },\n\n      /*\n      Those functions register themselves to the events on init and handle all\n      the user interface specific stuff. Overwriting them won\'t break the upload\n      but can break the way it\'s displayed.\n      You can overwrite them if you don\'t like the default behavior. If you just\n      want to add an additional event handler, register it on the dropzone object\n      and don\'t overwrite those options.\n       */\n      drop: function(e) {\n        return this.element.classList.remove("dz-drag-hover");\n      },\n      dragstart: noop,\n      dragend: function(e) {\n        return this.element.classList.remove("dz-drag-hover");\n      },\n      dragenter: function(e) {\n        return this.element.classList.add("dz-drag-hover");\n      },\n      dragover: function(e) {\n        return this.element.classList.add("dz-drag-hover");\n      },\n      dragleave: function(e) {\n        return this.element.classList.remove("dz-drag-hover");\n      },\n      paste: noop,\n      reset: function() {\n        return this.element.classList.remove("dz-started");\n      },\n      addedfile: function(file) {\n        var node, removeFileEvent, removeLink, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;\n        if (this.element === this.previewsContainer) {\n          this.element.classList.add("dz-started");\n        }\n        if (this.previewsContainer) {\n          file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());\n          file.previewTemplate = file.previewElement;\n          this.previewsContainer.appendChild(file.previewElement);\n          _ref = file.previewElement.querySelectorAll("[data-dz-name]");\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            node = _ref[_i];\n            node.textContent = file.name;\n          }\n          _ref1 = file.previewElement.querySelectorAll("[data-dz-size]");\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            node = _ref1[_j];\n            node.innerHTML = this.filesize(file.size);\n          }\n          if (this.options.addRemoveLinks) {\n            file._removeLink = Dropzone.createElement("<a class=\\"dz-remove\\" href=\\"javascript:undefined;\\" data-dz-remove>" + this.options.dictRemoveFile + "</a>");\n            file.previewElement.appendChild(file._removeLink);\n          }\n          removeFileEvent = (function(_this) {\n            return function(e) {\n              e.preventDefault();\n              e.stopPropagation();\n              if (file.status === Dropzone.UPLOADING) {\n                return Dropzone.confirm(_this.options.dictCancelUploadConfirmation, function() {\n                  return _this.removeFile(file);\n                });\n              } else {\n                if (_this.options.dictRemoveFileConfirmation) {\n                  return Dropzone.confirm(_this.options.dictRemoveFileConfirmation, function() {\n                    return _this.removeFile(file);\n                  });\n                } else {\n                  return _this.removeFile(file);\n                }\n              }\n            };\n          })(this);\n          _ref2 = file.previewElement.querySelectorAll("[data-dz-remove]");\n          _results = [];\n          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n            removeLink = _ref2[_k];\n            _results.push(removeLink.addEventListener("click", removeFileEvent));\n          }\n          return _results;\n        }\n      },\n      removedfile: function(file) {\n        var _ref;\n        if (file.previewElement) {\n          if ((_ref = file.previewElement) != null) {\n            _ref.parentNode.removeChild(file.previewElement);\n          }\n        }\n        return this._updateMaxFilesReachedClass();\n      },\n      thumbnail: function(file, dataUrl) {\n        var thumbnailElement, _i, _len, _ref;\n        if (file.previewElement) {\n          file.previewElement.classList.remove("dz-file-preview");\n          _ref = file.previewElement.querySelectorAll("[data-dz-thumbnail]");\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            thumbnailElement = _ref[_i];\n            thumbnailElement.alt = file.name;\n            thumbnailElement.src = dataUrl;\n          }\n          return setTimeout(((function(_this) {\n            return function() {\n              return file.previewElement.classList.add("dz-image-preview");\n            };\n          })(this)), 1);\n        }\n      },\n      error: function(file, message) {\n        var node, _i, _len, _ref, _results;\n        if (file.previewElement) {\n          file.previewElement.classList.add("dz-error");\n          if (typeof message !== "String" && message.error) {\n            message = message.error;\n          }\n          _ref = file.previewElement.querySelectorAll("[data-dz-errormessage]");\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            node = _ref[_i];\n            _results.push(node.textContent = message);\n          }\n          return _results;\n        }\n      },\n      errormultiple: noop,\n      processing: function(file) {\n        if (file.previewElement) {\n          file.previewElement.classList.add("dz-processing");\n          if (file._removeLink) {\n            return file._removeLink.textContent = this.options.dictCancelUpload;\n          }\n        }\n      },\n      processingmultiple: noop,\n      uploadprogress: function(file, progress, bytesSent) {\n        var node, _i, _len, _ref, _results;\n        if (file.previewElement) {\n          _ref = file.previewElement.querySelectorAll("[data-dz-uploadprogress]");\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            node = _ref[_i];\n            if (node.nodeName === \'PROGRESS\') {\n              _results.push(node.value = progress);\n            } else {\n              _results.push(node.style.width = "" + progress + "%");\n            }\n          }\n          return _results;\n        }\n      },\n      totaluploadprogress: noop,\n      sending: noop,\n      sendingmultiple: noop,\n      success: function(file) {\n        if (file.previewElement) {\n          return file.previewElement.classList.add("dz-success");\n        }\n      },\n      successmultiple: noop,\n      canceled: function(file) {\n        return this.emit("error", file, "Upload canceled.");\n      },\n      canceledmultiple: noop,\n      complete: function(file) {\n        if (file._removeLink) {\n          file._removeLink.textContent = this.options.dictRemoveFile;\n        }\n        if (file.previewElement) {\n          return file.previewElement.classList.add("dz-complete");\n        }\n      },\n      completemultiple: noop,\n      maxfilesexceeded: noop,\n      maxfilesreached: noop,\n      queuecomplete: noop,\n      addedfiles: noop,\n      previewTemplate: "<div class=\\"dz-preview dz-file-preview\\">\\n  <div class=\\"dz-image\\"><img data-dz-thumbnail /></div>\\n  <div class=\\"dz-details\\">\\n    <div class=\\"dz-size\\"><span data-dz-size></span></div>\\n    <div class=\\"dz-filename\\"><span data-dz-name></span></div>\\n  </div>\\n  <div class=\\"dz-progress\\"><span class=\\"dz-upload\\" data-dz-uploadprogress></span></div>\\n  <div class=\\"dz-error-message\\"><span data-dz-errormessage></span></div>\\n  <div class=\\"dz-success-mark\\">\\n    <svg width=\\"54px\\" height=\\"54px\\" viewBox=\\"0 0 54 54\\" version=\\"1.1\\" xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" xmlns:sketch=\\"http://www.bohemiancoding.com/sketch/ns\\">\\n      <title>Check</title>\\n      <defs></defs>\\n      <g id=\\"Page-1\\" stroke=\\"none\\" stroke-width=\\"1\\" fill=\\"none\\" fill-rule=\\"evenodd\\" sketch:type=\\"MSPage\\">\\n        <path d=\\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\" id=\\"Oval-2\\" stroke-opacity=\\"0.198794158\\" stroke=\\"#747474\\" fill-opacity=\\"0.816519475\\" fill=\\"#FFFFFF\\" sketch:type=\\"MSShapeGroup\\"></path>\\n      </g>\\n    </svg>\\n  </div>\\n  <div class=\\"dz-error-mark\\">\\n    <svg width=\\"54px\\" height=\\"54px\\" viewBox=\\"0 0 54 54\\" version=\\"1.1\\" xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" xmlns:sketch=\\"http://www.bohemiancoding.com/sketch/ns\\">\\n      <title>Error</title>\\n      <defs></defs>\\n      <g id=\\"Page-1\\" stroke=\\"none\\" stroke-width=\\"1\\" fill=\\"none\\" fill-rule=\\"evenodd\\" sketch:type=\\"MSPage\\">\\n        <g id=\\"Check-+-Oval-2\\" sketch:type=\\"MSLayerGroup\\" stroke=\\"#747474\\" stroke-opacity=\\"0.198794158\\" fill=\\"#FFFFFF\\" fill-opacity=\\"0.816519475\\">\\n          <path d=\\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\" id=\\"Oval-2\\" sketch:type=\\"MSShapeGroup\\"></path>\\n        </g>\\n      </g>\\n    </svg>\\n  </div>\\n</div>"\n    };\n\n    extend = function() {\n      var key, object, objects, target, val, _i, _len;\n      target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      for (_i = 0, _len = objects.length; _i < _len; _i++) {\n        object = objects[_i];\n        for (key in object) {\n          val = object[key];\n          target[key] = val;\n        }\n      }\n      return target;\n    };\n\n    function Dropzone(element, options) {\n      var elementOptions, fallback, _ref;\n      this.element = element;\n      this.version = Dropzone.version;\n      this.defaultOptions.previewTemplate = this.defaultOptions.previewTemplate.replace(/\\n*/g, "");\n      this.clickableElements = [];\n      this.listeners = [];\n      this.files = [];\n      if (typeof this.element === "string") {\n        this.element = document.querySelector(this.element);\n      }\n      if (!(this.element && (this.element.nodeType != null))) {\n        throw new Error("Invalid dropzone element.");\n      }\n      if (this.element.dropzone) {\n        throw new Error("Dropzone already attached.");\n      }\n      Dropzone.instances.push(this);\n      this.element.dropzone = this;\n      elementOptions = (_ref = Dropzone.optionsForElement(this.element)) != null ? _ref : {};\n      this.options = extend({}, this.defaultOptions, elementOptions, options != null ? options : {});\n      if (this.options.forceFallback || !Dropzone.isBrowserSupported()) {\n        return this.options.fallback.call(this);\n      }\n      if (this.options.url == null) {\n        this.options.url = this.element.getAttribute("action");\n      }\n      if (!this.options.url) {\n        throw new Error("No URL provided.");\n      }\n      if (this.options.acceptedFiles && this.options.acceptedMimeTypes) {\n        throw new Error("You can\'t provide both \'acceptedFiles\' and \'acceptedMimeTypes\'. \'acceptedMimeTypes\' is deprecated.");\n      }\n      if (this.options.acceptedMimeTypes) {\n        this.options.acceptedFiles = this.options.acceptedMimeTypes;\n        delete this.options.acceptedMimeTypes;\n      }\n      this.options.method = this.options.method.toUpperCase();\n      if ((fallback = this.getExistingFallback()) && fallback.parentNode) {\n        fallback.parentNode.removeChild(fallback);\n      }\n      if (this.options.previewsContainer !== false) {\n        if (this.options.previewsContainer) {\n          this.previewsContainer = Dropzone.getElement(this.options.previewsContainer, "previewsContainer");\n        } else {\n          this.previewsContainer = this.element;\n        }\n      }\n      if (this.options.clickable) {\n        if (this.options.clickable === true) {\n          this.clickableElements = [this.element];\n        } else {\n          this.clickableElements = Dropzone.getElements(this.options.clickable, "clickable");\n        }\n      }\n      this.init();\n    }\n\n    Dropzone.prototype.getAcceptedFiles = function() {\n      var file, _i, _len, _ref, _results;\n      _ref = this.files;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        file = _ref[_i];\n        if (file.accepted) {\n          _results.push(file);\n        }\n      }\n      return _results;\n    };\n\n    Dropzone.prototype.getRejectedFiles = function() {\n      var file, _i, _len, _ref, _results;\n      _ref = this.files;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        file = _ref[_i];\n        if (!file.accepted) {\n          _results.push(file);\n        }\n      }\n      return _results;\n    };\n\n    Dropzone.prototype.getFilesWithStatus = function(status) {\n      var file, _i, _len, _ref, _results;\n      _ref = this.files;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        file = _ref[_i];\n        if (file.status === status) {\n          _results.push(file);\n        }\n      }\n      return _results;\n    };\n\n    Dropzone.prototype.getQueuedFiles = function() {\n      return this.getFilesWithStatus(Dropzone.QUEUED);\n    };\n\n    Dropzone.prototype.getUploadingFiles = function() {\n      return this.getFilesWithStatus(Dropzone.UPLOADING);\n    };\n\n    Dropzone.prototype.getAddedFiles = function() {\n      return this.getFilesWithStatus(Dropzone.ADDED);\n    };\n\n    Dropzone.prototype.getActiveFiles = function() {\n      var file, _i, _len, _ref, _results;\n      _ref = this.files;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        file = _ref[_i];\n        if (file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED) {\n          _results.push(file);\n        }\n      }\n      return _results;\n    };\n\n    Dropzone.prototype.init = function() {\n      var eventName, noPropagation, setupHiddenFileInput, _i, _len, _ref, _ref1;\n      if (this.element.tagName === "form") {\n        this.element.setAttribute("enctype", "multipart/form-data");\n      }\n      if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {\n        this.element.appendChild(Dropzone.createElement("<div class=\\"dz-default dz-message\\"><span>" + this.options.dictDefaultMessage + "</span></div>"));\n      }\n      if (this.clickableElements.length) {\n        setupHiddenFileInput = (function(_this) {\n          return function() {\n            if (_this.hiddenFileInput) {\n              _this.hiddenFileInput.parentNode.removeChild(_this.hiddenFileInput);\n            }\n            _this.hiddenFileInput = document.createElement("input");\n            _this.hiddenFileInput.setAttribute("type", "file");\n            if ((_this.options.maxFiles == null) || _this.options.maxFiles > 1) {\n              _this.hiddenFileInput.setAttribute("multiple", "multiple");\n            }\n            _this.hiddenFileInput.className = "dz-hidden-input";\n            if (_this.options.acceptedFiles != null) {\n              _this.hiddenFileInput.setAttribute("accept", _this.options.acceptedFiles);\n            }\n            if (_this.options.capture != null) {\n              _this.hiddenFileInput.setAttribute("capture", _this.options.capture);\n            }\n            _this.hiddenFileInput.style.visibility = "hidden";\n            _this.hiddenFileInput.style.position = "absolute";\n            _this.hiddenFileInput.style.top = "0";\n            _this.hiddenFileInput.style.left = "0";\n            _this.hiddenFileInput.style.height = "0";\n            _this.hiddenFileInput.style.width = "0";\n            document.querySelector(_this.options.hiddenInputContainer).appendChild(_this.hiddenFileInput);\n            return _this.hiddenFileInput.addEventListener("change", function() {\n              var file, files, _i, _len;\n              files = _this.hiddenFileInput.files;\n              if (files.length) {\n                for (_i = 0, _len = files.length; _i < _len; _i++) {\n                  file = files[_i];\n                  _this.addFile(file);\n                }\n              }\n              _this.emit("addedfiles", files);\n              return setupHiddenFileInput();\n            });\n          };\n        })(this);\n        setupHiddenFileInput();\n      }\n      this.URL = (_ref = window.URL) != null ? _ref : window.webkitURL;\n      _ref1 = this.events;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        eventName = _ref1[_i];\n        this.on(eventName, this.options[eventName]);\n      }\n      this.on("uploadprogress", (function(_this) {\n        return function() {\n          return _this.updateTotalUploadProgress();\n        };\n      })(this));\n      this.on("removedfile", (function(_this) {\n        return function() {\n          return _this.updateTotalUploadProgress();\n        };\n      })(this));\n      this.on("canceled", (function(_this) {\n        return function(file) {\n          return _this.emit("complete", file);\n        };\n      })(this));\n      this.on("complete", (function(_this) {\n        return function(file) {\n          if (_this.getAddedFiles().length === 0 && _this.getUploadingFiles().length === 0 && _this.getQueuedFiles().length === 0) {\n            return setTimeout((function() {\n              return _this.emit("queuecomplete");\n            }), 0);\n          }\n        };\n      })(this));\n      noPropagation = function(e) {\n        e.stopPropagation();\n        if (e.preventDefault) {\n          return e.preventDefault();\n        } else {\n          return e.returnValue = false;\n        }\n      };\n      this.listeners = [\n        {\n          element: this.element,\n          events: {\n            "dragstart": (function(_this) {\n              return function(e) {\n                return _this.emit("dragstart", e);\n              };\n            })(this),\n            "dragenter": (function(_this) {\n              return function(e) {\n                noPropagation(e);\n                return _this.emit("dragenter", e);\n              };\n            })(this),\n            "dragover": (function(_this) {\n              return function(e) {\n                var efct;\n                try {\n                  efct = e.dataTransfer.effectAllowed;\n                } catch (_error) {}\n                e.dataTransfer.dropEffect = \'move\' === efct || \'linkMove\' === efct ? \'move\' : \'copy\';\n                noPropagation(e);\n                return _this.emit("dragover", e);\n              };\n            })(this),\n            "dragleave": (function(_this) {\n              return function(e) {\n                return _this.emit("dragleave", e);\n              };\n            })(this),\n            "drop": (function(_this) {\n              return function(e) {\n                noPropagation(e);\n                return _this.drop(e);\n              };\n            })(this),\n            "dragend": (function(_this) {\n              return function(e) {\n                return _this.emit("dragend", e);\n              };\n            })(this)\n          }\n        }\n      ];\n      this.clickableElements.forEach((function(_this) {\n        return function(clickableElement) {\n          return _this.listeners.push({\n            element: clickableElement,\n            events: {\n              "click": function(evt) {\n                if ((clickableElement !== _this.element) || (evt.target === _this.element || Dropzone.elementInside(evt.target, _this.element.querySelector(".dz-message")))) {\n                  _this.hiddenFileInput.click();\n                }\n                return true;\n              }\n            }\n          });\n        };\n      })(this));\n      this.enable();\n      return this.options.init.call(this);\n    };\n\n    Dropzone.prototype.destroy = function() {\n      var _ref;\n      this.disable();\n      this.removeAllFiles(true);\n      if ((_ref = this.hiddenFileInput) != null ? _ref.parentNode : void 0) {\n        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\n        this.hiddenFileInput = null;\n      }\n      delete this.element.dropzone;\n      return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);\n    };\n\n    Dropzone.prototype.updateTotalUploadProgress = function() {\n      var activeFiles, file, totalBytes, totalBytesSent, totalUploadProgress, _i, _len, _ref;\n      totalBytesSent = 0;\n      totalBytes = 0;\n      activeFiles = this.getActiveFiles();\n      if (activeFiles.length) {\n        _ref = this.getActiveFiles();\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          file = _ref[_i];\n          totalBytesSent += file.upload.bytesSent;\n          totalBytes += file.upload.total;\n        }\n        totalUploadProgress = 100 * totalBytesSent / totalBytes;\n      } else {\n        totalUploadProgress = 100;\n      }\n      return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);\n    };\n\n    Dropzone.prototype._getParamName = function(n) {\n      if (typeof this.options.paramName === "function") {\n        return this.options.paramName(n);\n      } else {\n        return "" + this.options.paramName + (this.options.uploadMultiple ? "[" + n + "]" : "");\n      }\n    };\n\n    Dropzone.prototype.getFallbackForm = function() {\n      var existingFallback, fields, fieldsString, form;\n      if (existingFallback = this.getExistingFallback()) {\n        return existingFallback;\n      }\n      fieldsString = "<div class=\\"dz-fallback\\">";\n      if (this.options.dictFallbackText) {\n        fieldsString += "<p>" + this.options.dictFallbackText + "</p>";\n      }\n      fieldsString += "<input type=\\"file\\" name=\\"" + (this._getParamName(0)) + "\\" " + (this.options.uploadMultiple ? \'multiple="multiple"\' : void 0) + " /><input type=\\"submit\\" value=\\"Upload!\\"></div>";\n      fields = Dropzone.createElement(fieldsString);\n      if (this.element.tagName !== "FORM") {\n        form = Dropzone.createElement("<form action=\\"" + this.options.url + "\\" enctype=\\"multipart/form-data\\" method=\\"" + this.options.method + "\\"></form>");\n        form.appendChild(fields);\n      } else {\n        this.element.setAttribute("enctype", "multipart/form-data");\n        this.element.setAttribute("method", this.options.method);\n      }\n      return form != null ? form : fields;\n    };\n\n    Dropzone.prototype.getExistingFallback = function() {\n      var fallback, getFallback, tagName, _i, _len, _ref;\n      getFallback = function(elements) {\n        var el, _i, _len;\n        for (_i = 0, _len = elements.length; _i < _len; _i++) {\n          el = elements[_i];\n          if (/(^| )fallback($| )/.test(el.className)) {\n            return el;\n          }\n        }\n      };\n      _ref = ["div", "form"];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        tagName = _ref[_i];\n        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {\n          return fallback;\n        }\n      }\n    };\n\n    Dropzone.prototype.setupEventListeners = function() {\n      var elementListeners, event, listener, _i, _len, _ref, _results;\n      _ref = this.listeners;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elementListeners = _ref[_i];\n        _results.push((function() {\n          var _ref1, _results1;\n          _ref1 = elementListeners.events;\n          _results1 = [];\n          for (event in _ref1) {\n            listener = _ref1[event];\n            _results1.push(elementListeners.element.addEventListener(event, listener, false));\n          }\n          return _results1;\n        })());\n      }\n      return _results;\n    };\n\n    Dropzone.prototype.removeEventListeners = function() {\n      var elementListeners, event, listener, _i, _len, _ref, _results;\n      _ref = this.listeners;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elementListeners = _ref[_i];\n        _results.push((function() {\n          var _ref1, _results1;\n          _ref1 = elementListeners.events;\n          _results1 = [];\n          for (event in _ref1) {\n            listener = _ref1[event];\n            _results1.push(elementListeners.element.removeEventListener(event, listener, false));\n          }\n          return _results1;\n        })());\n      }\n      return _results;\n    };\n\n    Dropzone.prototype.disable = function() {\n      var file, _i, _len, _ref, _results;\n      this.clickableElements.forEach(function(element) {\n        return element.classList.remove("dz-clickable");\n      });\n      this.removeEventListeners();\n      _ref = this.files;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        file = _ref[_i];\n        _results.push(this.cancelUpload(file));\n      }\n      return _results;\n    };\n\n    Dropzone.prototype.enable = function() {\n      this.clickableElements.forEach(function(element) {\n        return element.classList.add("dz-clickable");\n      });\n      return this.setupEventListeners();\n    };\n\n    Dropzone.prototype.filesize = function(size) {\n      var cutoff, i, selectedSize, selectedUnit, unit, units, _i, _len;\n      selectedSize = 0;\n      selectedUnit = "b";\n      if (size > 0) {\n        units = [\'TB\', \'GB\', \'MB\', \'KB\', \'b\'];\n        for (i = _i = 0, _len = units.length; _i < _len; i = ++_i) {\n          unit = units[i];\n          cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;\n          if (size >= cutoff) {\n            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);\n            selectedUnit = unit;\n            break;\n          }\n        }\n        selectedSize = Math.round(10 * selectedSize) / 10;\n      }\n      return "<strong>" + selectedSize + "</strong> " + selectedUnit;\n    };\n\n    Dropzone.prototype._updateMaxFilesReachedClass = function() {\n      if ((this.options.maxFiles != null) && this.getAcceptedFiles().length >= this.options.maxFiles) {\n        if (this.getAcceptedFiles().length === this.options.maxFiles) {\n          this.emit(\'maxfilesreached\', this.files);\n        }\n        return this.element.classList.add("dz-max-files-reached");\n      } else {\n        return this.element.classList.remove("dz-max-files-reached");\n      }\n    };\n\n    Dropzone.prototype.drop = function(e) {\n      var files, items;\n      if (!e.dataTransfer) {\n        return;\n      }\n      this.emit("drop", e);\n      files = e.dataTransfer.files;\n      this.emit("addedfiles", files);\n      if (files.length) {\n        items = e.dataTransfer.items;\n        if (items && items.length && (items[0].webkitGetAsEntry != null)) {\n          this._addFilesFromItems(items);\n        } else {\n          this.handleFiles(files);\n        }\n      }\n    };\n\n    Dropzone.prototype.paste = function(e) {\n      var items, _ref;\n      if ((e != null ? (_ref = e.clipboardData) != null ? _ref.items : void 0 : void 0) == null) {\n        return;\n      }\n      this.emit("paste", e);\n      items = e.clipboardData.items;\n      if (items.length) {\n        return this._addFilesFromItems(items);\n      }\n    };\n\n    Dropzone.prototype.handleFiles = function(files) {\n      var file, _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = files.length; _i < _len; _i++) {\n        file = files[_i];\n        _results.push(this.addFile(file));\n      }\n      return _results;\n    };\n\n    Dropzone.prototype._addFilesFromItems = function(items) {\n      var entry, item, _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = items.length; _i < _len; _i++) {\n        item = items[_i];\n        if ((item.webkitGetAsEntry != null) && (entry = item.webkitGetAsEntry())) {\n          if (entry.isFile) {\n            _results.push(this.addFile(item.getAsFile()));\n          } else if (entry.isDirectory) {\n            _results.push(this._addFilesFromDirectory(entry, entry.name));\n          } else {\n            _results.push(void 0);\n          }\n        } else if (item.getAsFile != null) {\n          if ((item.kind == null) || item.kind === "file") {\n            _results.push(this.addFile(item.getAsFile()));\n          } else {\n            _results.push(void 0);\n          }\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    Dropzone.prototype._addFilesFromDirectory = function(directory, path) {\n      var dirReader, entriesReader;\n      dirReader = directory.createReader();\n      entriesReader = (function(_this) {\n        return function(entries) {\n          var entry, _i, _len;\n          for (_i = 0, _len = entries.length; _i < _len; _i++) {\n            entry = entries[_i];\n            if (entry.isFile) {\n              entry.file(function(file) {\n                if (_this.options.ignoreHiddenFiles && file.name.substring(0, 1) === \'.\') {\n                  return;\n                }\n                file.fullPath = "" + path + "/" + file.name;\n                return _this.addFile(file);\n              });\n            } else if (entry.isDirectory) {\n              _this._addFilesFromDirectory(entry, "" + path + "/" + entry.name);\n            }\n          }\n        };\n      })(this);\n      return dirReader.readEntries(entriesReader, function(error) {\n        return typeof console !== "undefined" && console !== null ? typeof console.log === "function" ? console.log(error) : void 0 : void 0;\n      });\n    };\n\n    Dropzone.prototype.accept = function(file, done) {\n      if (file.size > this.options.maxFilesize * 1024 * 1024) {\n        return done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));\n      } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {\n        return done(this.options.dictInvalidFileType);\n      } else if ((this.options.maxFiles != null) && this.getAcceptedFiles().length >= this.options.maxFiles) {\n        done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));\n        return this.emit("maxfilesexceeded", file);\n      } else {\n        return this.options.accept.call(this, file, done);\n      }\n    };\n\n    Dropzone.prototype.addFile = function(file) {\n      file.upload = {\n        progress: 0,\n        total: file.size,\n        bytesSent: 0\n      };\n      this.files.push(file);\n      file.status = Dropzone.ADDED;\n      this.emit("addedfile", file);\n      this._enqueueThumbnail(file);\n      return this.accept(file, (function(_this) {\n        return function(error) {\n          if (error) {\n            file.accepted = false;\n            _this._errorProcessing([file], error);\n          } else {\n            file.accepted = true;\n            if (_this.options.autoQueue) {\n              _this.enqueueFile(file);\n            }\n          }\n          return _this._updateMaxFilesReachedClass();\n        };\n      })(this));\n    };\n\n    Dropzone.prototype.enqueueFiles = function(files) {\n      var file, _i, _len;\n      for (_i = 0, _len = files.length; _i < _len; _i++) {\n        file = files[_i];\n        this.enqueueFile(file);\n      }\n      return null;\n    };\n\n    Dropzone.prototype.enqueueFile = function(file) {\n      if (file.status === Dropzone.ADDED && file.accepted === true) {\n        file.status = Dropzone.QUEUED;\n        if (this.options.autoProcessQueue) {\n          return setTimeout(((function(_this) {\n            return function() {\n              return _this.processQueue();\n            };\n          })(this)), 0);\n        }\n      } else {\n        throw new Error("This file can\'t be queued because it has already been processed or was rejected.");\n      }\n    };\n\n    Dropzone.prototype._thumbnailQueue = [];\n\n    Dropzone.prototype._processingThumbnail = false;\n\n    Dropzone.prototype._enqueueThumbnail = function(file) {\n      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {\n        this._thumbnailQueue.push(file);\n        return setTimeout(((function(_this) {\n          return function() {\n            return _this._processThumbnailQueue();\n          };\n        })(this)), 0);\n      }\n    };\n\n    Dropzone.prototype._processThumbnailQueue = function() {\n      if (this._processingThumbnail || this._thumbnailQueue.length === 0) {\n        return;\n      }\n      this._processingThumbnail = true;\n      return this.createThumbnail(this._thumbnailQueue.shift(), (function(_this) {\n        return function() {\n          _this._processingThumbnail = false;\n          return _this._processThumbnailQueue();\n        };\n      })(this));\n    };\n\n    Dropzone.prototype.removeFile = function(file) {\n      if (file.status === Dropzone.UPLOADING) {\n        this.cancelUpload(file);\n      }\n      this.files = without(this.files, file);\n      this.emit("removedfile", file);\n      if (this.files.length === 0) {\n        return this.emit("reset");\n      }\n    };\n\n    Dropzone.prototype.removeAllFiles = function(cancelIfNecessary) {\n      var file, _i, _len, _ref;\n      if (cancelIfNecessary == null) {\n        cancelIfNecessary = false;\n      }\n      _ref = this.files.slice();\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        file = _ref[_i];\n        if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {\n          this.removeFile(file);\n        }\n      }\n      return null;\n    };\n\n    Dropzone.prototype.createThumbnail = function(file, callback) {\n      var fileReader;\n      fileReader = new FileReader;\n      fileReader.onload = (function(_this) {\n        return function() {\n          if (file.type === "image/svg+xml") {\n            _this.emit("thumbnail", file, fileReader.result);\n            if (callback != null) {\n              callback();\n            }\n            return;\n          }\n          return _this.createThumbnailFromUrl(file, fileReader.result, callback);\n        };\n      })(this);\n      return fileReader.readAsDataURL(file);\n    };\n\n    Dropzone.prototype.createThumbnailFromUrl = function(file, imageUrl, callback, crossOrigin) {\n      var img;\n      img = document.createElement("img");\n      if (crossOrigin) {\n        img.crossOrigin = crossOrigin;\n      }\n      img.onload = (function(_this) {\n        return function() {\n          var canvas, ctx, resizeInfo, thumbnail, _ref, _ref1, _ref2, _ref3;\n          file.width = img.width;\n          file.height = img.height;\n          resizeInfo = _this.options.resize.call(_this, file);\n          if (resizeInfo.trgWidth == null) {\n            resizeInfo.trgWidth = resizeInfo.optWidth;\n          }\n          if (resizeInfo.trgHeight == null) {\n            resizeInfo.trgHeight = resizeInfo.optHeight;\n          }\n          canvas = document.createElement("canvas");\n          ctx = canvas.getContext("2d");\n          canvas.width = resizeInfo.trgWidth;\n          canvas.height = resizeInfo.trgHeight;\n          drawImageIOSFix(ctx, img, (_ref = resizeInfo.srcX) != null ? _ref : 0, (_ref1 = resizeInfo.srcY) != null ? _ref1 : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, (_ref2 = resizeInfo.trgX) != null ? _ref2 : 0, (_ref3 = resizeInfo.trgY) != null ? _ref3 : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);\n          thumbnail = canvas.toDataURL("image/png");\n          _this.emit("thumbnail", file, thumbnail);\n          if (callback != null) {\n            return callback();\n          }\n        };\n      })(this);\n      if (callback != null) {\n        img.onerror = callback;\n      }\n      return img.src = imageUrl;\n    };\n\n    Dropzone.prototype.processQueue = function() {\n      var i, parallelUploads, processingLength, queuedFiles;\n      parallelUploads = this.options.parallelUploads;\n      processingLength = this.getUploadingFiles().length;\n      i = processingLength;\n      if (processingLength >= parallelUploads) {\n        return;\n      }\n      queuedFiles = this.getQueuedFiles();\n      if (!(queuedFiles.length > 0)) {\n        return;\n      }\n      if (this.options.uploadMultiple) {\n        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));\n      } else {\n        while (i < parallelUploads) {\n          if (!queuedFiles.length) {\n            return;\n          }\n          this.processFile(queuedFiles.shift());\n          i++;\n        }\n      }\n    };\n\n    Dropzone.prototype.processFile = function(file) {\n      return this.processFiles([file]);\n    };\n\n    Dropzone.prototype.processFiles = function(files) {\n      var file, _i, _len;\n      for (_i = 0, _len = files.length; _i < _len; _i++) {\n        file = files[_i];\n        file.processing = true;\n        file.status = Dropzone.UPLOADING;\n        this.emit("processing", file);\n      }\n      if (this.options.uploadMultiple) {\n        this.emit("processingmultiple", files);\n      }\n      return this.uploadFiles(files);\n    };\n\n    Dropzone.prototype._getFilesWithXhr = function(xhr) {\n      var file, files;\n      return files = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.files;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          file = _ref[_i];\n          if (file.xhr === xhr) {\n            _results.push(file);\n          }\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Dropzone.prototype.cancelUpload = function(file) {\n      var groupedFile, groupedFiles, _i, _j, _len, _len1, _ref;\n      if (file.status === Dropzone.UPLOADING) {\n        groupedFiles = this._getFilesWithXhr(file.xhr);\n        for (_i = 0, _len = groupedFiles.length; _i < _len; _i++) {\n          groupedFile = groupedFiles[_i];\n          groupedFile.status = Dropzone.CANCELED;\n        }\n        file.xhr.abort();\n        for (_j = 0, _len1 = groupedFiles.length; _j < _len1; _j++) {\n          groupedFile = groupedFiles[_j];\n          this.emit("canceled", groupedFile);\n        }\n        if (this.options.uploadMultiple) {\n          this.emit("canceledmultiple", groupedFiles);\n        }\n      } else if ((_ref = file.status) === Dropzone.ADDED || _ref === Dropzone.QUEUED) {\n        file.status = Dropzone.CANCELED;\n        this.emit("canceled", file);\n        if (this.options.uploadMultiple) {\n          this.emit("canceledmultiple", [file]);\n        }\n      }\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    };\n\n    resolveOption = function() {\n      var args, option;\n      option = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      if (typeof option === \'function\') {\n        return option.apply(this, args);\n      }\n      return option;\n    };\n\n    Dropzone.prototype.uploadFile = function(file) {\n      return this.uploadFiles([file]);\n    };\n\n    Dropzone.prototype.uploadFiles = function(files) {\n      var file, formData, handleError, headerName, headerValue, headers, i, input, inputName, inputType, key, method, option, progressObj, response, updateProgress, url, value, xhr, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n      xhr = new XMLHttpRequest();\n      for (_i = 0, _len = files.length; _i < _len; _i++) {\n        file = files[_i];\n        file.xhr = xhr;\n      }\n      method = resolveOption(this.options.method, files);\n      url = resolveOption(this.options.url, files);\n      xhr.open(method, url, true);\n      xhr.withCredentials = !!this.options.withCredentials;\n      response = null;\n      handleError = (function(_this) {\n        return function() {\n          var _j, _len1, _results;\n          _results = [];\n          for (_j = 0, _len1 = files.length; _j < _len1; _j++) {\n            file = files[_j];\n            _results.push(_this._errorProcessing(files, response || _this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr));\n          }\n          return _results;\n        };\n      })(this);\n      updateProgress = (function(_this) {\n        return function(e) {\n          var allFilesFinished, progress, _j, _k, _l, _len1, _len2, _len3, _results;\n          if (e != null) {\n            progress = 100 * e.loaded / e.total;\n            for (_j = 0, _len1 = files.length; _j < _len1; _j++) {\n              file = files[_j];\n              file.upload = {\n                progress: progress,\n                total: e.total,\n                bytesSent: e.loaded\n              };\n            }\n          } else {\n            allFilesFinished = true;\n            progress = 100;\n            for (_k = 0, _len2 = files.length; _k < _len2; _k++) {\n              file = files[_k];\n              if (!(file.upload.progress === 100 && file.upload.bytesSent === file.upload.total)) {\n                allFilesFinished = false;\n              }\n              file.upload.progress = progress;\n              file.upload.bytesSent = file.upload.total;\n            }\n            if (allFilesFinished) {\n              return;\n            }\n          }\n          _results = [];\n          for (_l = 0, _len3 = files.length; _l < _len3; _l++) {\n            file = files[_l];\n            _results.push(_this.emit("uploadprogress", file, progress, file.upload.bytesSent));\n          }\n          return _results;\n        };\n      })(this);\n      xhr.onload = (function(_this) {\n        return function(e) {\n          var _ref;\n          if (files[0].status === Dropzone.CANCELED) {\n            return;\n          }\n          if (xhr.readyState !== 4) {\n            return;\n          }\n          response = xhr.responseText;\n          if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {\n            try {\n              response = JSON.parse(response);\n            } catch (_error) {\n              e = _error;\n              response = "Invalid JSON response from server.";\n            }\n          }\n          updateProgress();\n          if (!((200 <= (_ref = xhr.status) && _ref < 300))) {\n            return handleError();\n          } else {\n            return _this._finished(files, response, e);\n          }\n        };\n      })(this);\n      xhr.onerror = (function(_this) {\n        return function() {\n          if (files[0].status === Dropzone.CANCELED) {\n            return;\n          }\n          return handleError();\n        };\n      })(this);\n      progressObj = (_ref = xhr.upload) != null ? _ref : xhr;\n      progressObj.onprogress = updateProgress;\n      headers = {\n        "Accept": "application/json",\n        "Cache-Control": "no-cache",\n        "X-Requested-With": "XMLHttpRequest"\n      };\n      if (this.options.headers) {\n        extend(headers, this.options.headers);\n      }\n      for (headerName in headers) {\n        headerValue = headers[headerName];\n        if (headerValue) {\n          xhr.setRequestHeader(headerName, headerValue);\n        }\n      }\n      formData = new FormData();\n      if (this.options.params) {\n        _ref1 = this.options.params;\n        for (key in _ref1) {\n          value = _ref1[key];\n          formData.append(key, value);\n        }\n      }\n      for (_j = 0, _len1 = files.length; _j < _len1; _j++) {\n        file = files[_j];\n        this.emit("sending", file, xhr, formData);\n      }\n      if (this.options.uploadMultiple) {\n        this.emit("sendingmultiple", files, xhr, formData);\n      }\n      if (this.element.tagName === "FORM") {\n        _ref2 = this.element.querySelectorAll("input, textarea, select, button");\n        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n          input = _ref2[_k];\n          inputName = input.getAttribute("name");\n          inputType = input.getAttribute("type");\n          if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {\n            _ref3 = input.options;\n            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {\n              option = _ref3[_l];\n              if (option.selected) {\n                formData.append(inputName, option.value);\n              }\n            }\n          } else if (!inputType || ((_ref4 = inputType.toLowerCase()) !== "checkbox" && _ref4 !== "radio") || input.checked) {\n            formData.append(inputName, input.value);\n          }\n        }\n      }\n      for (i = _m = 0, _ref5 = files.length - 1; 0 <= _ref5 ? _m <= _ref5 : _m >= _ref5; i = 0 <= _ref5 ? ++_m : --_m) {\n        formData.append(this._getParamName(i), files[i], files[i].name);\n      }\n      return this.submitRequest(xhr, formData, files);\n    };\n\n    Dropzone.prototype.submitRequest = function(xhr, formData, files) {\n      return xhr.send(formData);\n    };\n\n    Dropzone.prototype._finished = function(files, responseText, e) {\n      var file, _i, _len;\n      for (_i = 0, _len = files.length; _i < _len; _i++) {\n        file = files[_i];\n        file.status = Dropzone.SUCCESS;\n        this.emit("success", file, responseText, e);\n        this.emit("complete", file);\n      }\n      if (this.options.uploadMultiple) {\n        this.emit("successmultiple", files, responseText, e);\n        this.emit("completemultiple", files);\n      }\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    };\n\n    Dropzone.prototype._errorProcessing = function(files, message, xhr) {\n      var file, _i, _len;\n      for (_i = 0, _len = files.length; _i < _len; _i++) {\n        file = files[_i];\n        file.status = Dropzone.ERROR;\n        this.emit("error", file, message, xhr);\n        this.emit("complete", file);\n      }\n      if (this.options.uploadMultiple) {\n        this.emit("errormultiple", files, message, xhr);\n        this.emit("completemultiple", files);\n      }\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    };\n\n    return Dropzone;\n\n  })(Emitter);\n\n  Dropzone.version = "4.2.0";\n\n  Dropzone.options = {};\n\n  Dropzone.optionsForElement = function(element) {\n    if (element.getAttribute("id")) {\n      return Dropzone.options[camelize(element.getAttribute("id"))];\n    } else {\n      return void 0;\n    }\n  };\n\n  Dropzone.instances = [];\n\n  Dropzone.forElement = function(element) {\n    if (typeof element === "string") {\n      element = document.querySelector(element);\n    }\n    if ((element != null ? element.dropzone : void 0) == null) {\n      throw new Error("No Dropzone found for given element. This is probably because you\'re trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");\n    }\n    return element.dropzone;\n  };\n\n  Dropzone.autoDiscover = true;\n\n  Dropzone.discover = function() {\n    var checkElements, dropzone, dropzones, _i, _len, _results;\n    if (document.querySelectorAll) {\n      dropzones = document.querySelectorAll(".dropzone");\n    } else {\n      dropzones = [];\n      checkElements = function(elements) {\n        var el, _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = elements.length; _i < _len; _i++) {\n          el = elements[_i];\n          if (/(^| )dropzone($| )/.test(el.className)) {\n            _results.push(dropzones.push(el));\n          } else {\n            _results.push(void 0);\n          }\n        }\n        return _results;\n      };\n      checkElements(document.getElementsByTagName("div"));\n      checkElements(document.getElementsByTagName("form"));\n    }\n    _results = [];\n    for (_i = 0, _len = dropzones.length; _i < _len; _i++) {\n      dropzone = dropzones[_i];\n      if (Dropzone.optionsForElement(dropzone) !== false) {\n        _results.push(new Dropzone(dropzone));\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  Dropzone.blacklistedBrowsers = [/opera.*Macintosh.*version\\/12/i];\n\n  Dropzone.isBrowserSupported = function() {\n    var capableBrowser, regex, _i, _len, _ref;\n    capableBrowser = true;\n    if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {\n      if (!("classList" in document.createElement("a"))) {\n        capableBrowser = false;\n      } else {\n        _ref = Dropzone.blacklistedBrowsers;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          regex = _ref[_i];\n          if (regex.test(navigator.userAgent)) {\n            capableBrowser = false;\n            continue;\n          }\n        }\n      }\n    } else {\n      capableBrowser = false;\n    }\n    return capableBrowser;\n  };\n\n  without = function(list, rejectedItem) {\n    var item, _i, _len, _results;\n    _results = [];\n    for (_i = 0, _len = list.length; _i < _len; _i++) {\n      item = list[_i];\n      if (item !== rejectedItem) {\n        _results.push(item);\n      }\n    }\n    return _results;\n  };\n\n  camelize = function(str) {\n    return str.replace(/[\\-_](\\w)/g, function(match) {\n      return match.charAt(1).toUpperCase();\n    });\n  };\n\n  Dropzone.createElement = function(string) {\n    var div;\n    div = document.createElement("div");\n    div.innerHTML = string;\n    return div.childNodes[0];\n  };\n\n  Dropzone.elementInside = function(element, container) {\n    if (element === container) {\n      return true;\n    }\n    while (element = element.parentNode) {\n      if (element === container) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  Dropzone.getElement = function(el, name) {\n    var element;\n    if (typeof el === "string") {\n      element = document.querySelector(el);\n    } else if (el.nodeType != null) {\n      element = el;\n    }\n    if (element == null) {\n      throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector or a plain HTML element.");\n    }\n    return element;\n  };\n\n  Dropzone.getElements = function(els, name) {\n    var e, el, elements, _i, _j, _len, _len1, _ref;\n    if (els instanceof Array) {\n      elements = [];\n      try {\n        for (_i = 0, _len = els.length; _i < _len; _i++) {\n          el = els[_i];\n          elements.push(this.getElement(el, name));\n        }\n      } catch (_error) {\n        e = _error;\n        elements = null;\n      }\n    } else if (typeof els === "string") {\n      elements = [];\n      _ref = document.querySelectorAll(els);\n      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n        el = _ref[_j];\n        elements.push(el);\n      }\n    } else if (els.nodeType != null) {\n      elements = [els];\n    }\n    if (!((elements != null) && elements.length)) {\n      throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");\n    }\n    return elements;\n  };\n\n  Dropzone.confirm = function(question, accepted, rejected) {\n    if (window.confirm(question)) {\n      return accepted();\n    } else if (rejected != null) {\n      return rejected();\n    }\n  };\n\n  Dropzone.isValidFile = function(file, acceptedFiles) {\n    var baseMimeType, mimeType, validType, _i, _len;\n    if (!acceptedFiles) {\n      return true;\n    }\n    acceptedFiles = acceptedFiles.split(",");\n    mimeType = file.type;\n    baseMimeType = mimeType.replace(/\\/.*$/, "");\n    for (_i = 0, _len = acceptedFiles.length; _i < _len; _i++) {\n      validType = acceptedFiles[_i];\n      validType = validType.trim();\n      if (validType.charAt(0) === ".") {\n        if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {\n          return true;\n        }\n      } else if (/\\/\\*$/.test(validType)) {\n        if (baseMimeType === validType.replace(/\\/.*$/, "")) {\n          return true;\n        }\n      } else {\n        if (mimeType === validType) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  if (typeof jQuery !== "undefined" && jQuery !== null) {\n    jQuery.fn.dropzone = function(options) {\n      return this.each(function() {\n        return new Dropzone(this, options);\n      });\n    };\n  }\n\n  if (typeof module !== "undefined" && module !== null) {\n    module.exports = Dropzone;\n  } else {\n    window.Dropzone = Dropzone;\n  }\n\n  Dropzone.ADDED = "added";\n\n  Dropzone.QUEUED = "queued";\n\n  Dropzone.ACCEPTED = Dropzone.QUEUED;\n\n  Dropzone.UPLOADING = "uploading";\n\n  Dropzone.PROCESSING = Dropzone.UPLOADING;\n\n  Dropzone.CANCELED = "canceled";\n\n  Dropzone.ERROR = "error";\n\n  Dropzone.SUCCESS = "success";\n\n\n  /*\n  \n  Bugfix for iOS 6 and 7\n  Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\n  based on the work of https://github.com/stomita/ios-imagefile-megapixel\n   */\n\n  detectVerticalSquash = function(img) {\n    var alpha, canvas, ctx, data, ey, ih, iw, py, ratio, sy;\n    iw = img.naturalWidth;\n    ih = img.naturalHeight;\n    canvas = document.createElement("canvas");\n    canvas.width = 1;\n    canvas.height = ih;\n    ctx = canvas.getContext("2d");\n    ctx.drawImage(img, 0, 0);\n    data = ctx.getImageData(0, 0, 1, ih).data;\n    sy = 0;\n    ey = ih;\n    py = ih;\n    while (py > sy) {\n      alpha = data[(py - 1) * 4 + 3];\n      if (alpha === 0) {\n        ey = py;\n      } else {\n        sy = py;\n      }\n      py = (ey + sy) >> 1;\n    }\n    ratio = py / ih;\n    if (ratio === 0) {\n      return 1;\n    } else {\n      return ratio;\n    }\n  };\n\n  drawImageIOSFix = function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\n    var vertSquashRatio;\n    vertSquashRatio = detectVerticalSquash(img);\n    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\n  };\n\n\n  /*\n   * contentloaded.js\n   *\n   * Author: Diego Perini (diego.perini at gmail.com)\n   * Summary: cross-browser wrapper for DOMContentLoaded\n   * Updated: 20101020\n   * License: MIT\n   * Version: 1.2\n   *\n   * URL:\n   * http://javascript.nwbox.com/ContentLoaded/\n   * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE\n   */\n\n  contentLoaded = function(win, fn) {\n    var add, doc, done, init, poll, pre, rem, root, top;\n    done = false;\n    top = true;\n    doc = win.document;\n    root = doc.documentElement;\n    add = (doc.addEventListener ? "addEventListener" : "attachEvent");\n    rem = (doc.addEventListener ? "removeEventListener" : "detachEvent");\n    pre = (doc.addEventListener ? "" : "on");\n    init = function(e) {\n      if (e.type === "readystatechange" && doc.readyState !== "complete") {\n        return;\n      }\n      (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);\n      if (!done && (done = true)) {\n        return fn.call(win, e.type || e);\n      }\n    };\n    poll = function() {\n      var e;\n      try {\n        root.doScroll("left");\n      } catch (_error) {\n        e = _error;\n        setTimeout(poll, 50);\n        return;\n      }\n      return init("poll");\n    };\n    if (doc.readyState !== "complete") {\n      if (doc.createEventObject && root.doScroll) {\n        try {\n          top = !win.frameElement;\n        } catch (_error) {}\n        if (top) {\n          poll();\n        }\n      }\n      doc[add](pre + "DOMContentLoaded", init, false);\n      doc[add](pre + "readystatechange", init, false);\n      return win[add](pre + "load", init, false);\n    }\n  };\n\n  Dropzone._autoDiscoverFunction = function() {\n    if (Dropzone.autoDiscover) {\n      return Dropzone.discover();\n    }\n  };\n\n  contentLoaded(window, Dropzone._autoDiscoverFunction);\n\n}).call(this);\n'},16:function(t,n,e){e(1)(e(17))},17:function(t,n){t.exports='(function ($) {\n    "use strict";\n\n    function Djupload(el, options){\n        this.element = $(el);\n        this.options = options;\n        this.init();\n    }\n\n    /* UI element to upload files directly to S3.\n\n       <div data-complete-url="">\n       </div>\n     */\n    Djupload.prototype = {\n\n        _csrfToken: function() {\n            var self = this;\n            if( self.options.csrfToken ) { return self.options.csrfToken; }\n            return getMetaCSRFToken();\n        },\n\n        _uploadSuccess: function(file, resp) {\n            var self = this;\n            self.element.trigger("djupload.success", resp.location);\n            if( self.options.uploadSuccess &&\n                {}.toString.call(self.options.uploadSuccess)\n                === \'[object Function]\' ) {\n                self.options.uploadSuccess(file, resp);\n            } else {\n                if( resp.detail ) {\n                    showMessages(resp.detail, "success");\n                }\n            }\n            return true;\n        },\n\n        _uploadError: function(file, resp) {\n            var self = this;\n            self.element.trigger("djupload.error", [file.name, resp]);\n            if( self.options.uploadError ) {\n                self.options.uploadError(file, resp);\n            } else {\n                showErrorMessages(resp);\n            }\n        },\n\n        _uploadProgress: function(file, progress) {\n            var self = this;\n            self.element.trigger("djupload.progress", [file.name, progress]);\n            if( self.options.uploadProgress ) {\n                self.options.uploadProgress(file, progress);\n            }\n            return true;\n        },\n\n        init: function(){\n            var self = this;\n            if( self.options.mediaPrefix !== ""\n                && !self.options.mediaPrefix.match(/\\/$/)){\n                self.options.mediaPrefix += "/";\n            }\n            if( self.options.uploadUrl.indexOf("/api/auth/") >= 0 ) {\n                $.ajax({\n                    method: "GET",\n                    url: self.options.uploadUrl +\n                        (self.options.acl === "public-read" ? "?public=1" : ""),\n                    datatype: "json",\n                    contentType: "application/json; charset=utf-8",\n                    success: function(data) {\n\n                        var parser = document.createElement(\'a\');\n                        parser.href = data.location;\n                        self.options.uploadUrl = parser.host + "/";\n                        if( parser.protocol ) {\n                            self.options.uploadUrl = parser.protocol + "//"\n                                + self.options.uploadUrl;\n                        }\n                        self.options.mediaPrefix = parser.pathname;\n                        if( self.options.mediaPrefix === \'undefined\'\n                            || self.options.mediaPrefix === null ) {\n                            self.options.mediaPrefix = "";\n                        }\n                        if( self.options.mediaPrefix !== ""\n                            && self.options.mediaPrefix.match(/^\\//)){\n                            self.options.mediaPrefix = self.options.mediaPrefix.substring(1);\n                        }\n                        if( self.options.mediaPrefix !== ""\n                            && !self.options.mediaPrefix.match(/\\/$/)){\n                            self.options.mediaPrefix += "/";\n                        }\n\n                        self.options.accessKey = data.access_key;\n                        self.options.policy = data.policy;\n                        self.options.amzCredential = data.x_amz_credential;\n                        self.options.amzDate = data.x_amz_date;\n                        self.options.amzServerSideEncryption = data.x_amz_server_side_encryption;\n                        self.options.securityToken = data.security_token;\n                        self.options.signature = data.signature;\n                        self.initDropzone();\n                    },\n                    error: function(resp) {\n                        showErrorMessages(resp);\n                    }\n                });\n            } else {\n                self.initDropzone();\n            }\n        },\n\n        initDropzone: function() {\n            var self = this;\n            var dropzoneUrl = (self.options.accessKey ? self.options.uploadUrl\n                : (self.element.attr("data-complete-url") ?\n                    self.element.attr("data-complete-url")\n                    : self.options.uploadUrl));\n            if( !dropzoneUrl ) {\n                showErrorMessages(self.options.configError);\n                throw new Error(self.options.configError);\n            }\n            self.element.dropzone({\n                paramName: self.options.uploadParamName,\n                url: dropzoneUrl,\n                maxFilesize: self.options.uploadMaxFileSize,\n                clickable: self.options.uploadClickableZone,\n                createImageThumbnails: false,\n                previewTemplate: "<div></div>",\n                init: function() {\n                    if( self.options.accessKey ) {\n                        // We are going to remove extra input files that AWS\n                        // would reject (ex: csrftoken).\n                        var fields = this.element.querySelectorAll(\n                            "input, textarea, select, button");\n                        for( var idx = 0; idx < fields.length; ++idx ) {\n                            if( fields[idx].getAttribute("name")\n                                && (fields[idx].getAttribute("name")\n                                    !== self.options.uploadParamName) ) {\n                                fields[idx].parentNode.removeChild(fields[idx]);\n                            }\n                        }\n                    }\n\n                    this.on("sending", function(file, xhr, formData){\n                        if( self.options.accessKey ) {\n                            formData.append(\n                                "key", self.options.mediaPrefix + file.name);\n                            formData.append("policy", self.options.policy);\n                            formData.append(\n                                "x-amz-algorithm", "AWS4-HMAC-SHA256");\n                            formData.append(\n                                "x-amz-credential", self.options.amzCredential);\n                            formData.append("x-amz-date", self.options.amzDate);\n                            formData.append("x-amz-security-token",\n                                self.options.securityToken);\n                            formData.append(\n                                "x-amz-signature", self.options.signature);\n                            if( self.options.acl ) {\n                                formData.append("acl", self.options.acl);\n                            } else {\n                                formData.append("acl", "private");\n                            }\n                            if( self.options.amzServerSideEncryption ) {\n                                formData.append("x-amz-server-side-encryption",\n                                    self.options.amzServerSideEncryption);\n                            } else if( !self.options.acl\n                                || self.options.acl !== "public-read" ) {\n                                formData.append("x-amz-server-side-encryption",\n                                    "AES256");\n                            }\n                            var ext = file.name.slice(\n                                file.name.lastIndexOf(\'.\')).toLowerCase();\n                            if( ext === ".jpg" ) {\n                                formData.append("Content-Type", "image/jpeg");\n                            } else if( ext === ".png" ) {\n                                formData.append("Content-Type", "image/png");\n                            } else if( ext === ".gif" ) {\n                                formData.append("Content-Type", "image/gif");\n                            } else if( ext === ".mp4" ) {\n                                formData.append("Content-Type", "video/mp4");\n                            } else {\n                                formData.append(\n                                    "Content-Type", "binary/octet-stream");\n                            }\n                        } else {\n                            formData.append(\n                                "csrfmiddlewaretoken", getMetaCSRFToken());\n                            var data = self.element.data();\n                            for( var key in data ) {\n                                if( data.hasOwnProperty(key)\n                                    && key != \'djupload\' ) {\n                                    formData.append(key, data[key]);\n                                }\n                            }\n                        }\n                    });\n\n                    this.on("success", function(file, response){\n                        if( self.options.accessKey) {\n                            // With a direct upload to S3, we need to build\n                            // a custom response with location url ourselves.\n                            response = {\n                                location: file.xhr.responseURL + self.options.mediaPrefix + file.name\n                            };\n                            // We will also call back a completion url\n                            // on the server.\n                            var completeUrl = self.element.attr(\n                                "data-complete-url");\n                            if( completeUrl ) {\n                                var data = {};\n                                [].forEach.call(self.element[0].attributes, function(attr) {\n                                    if (/^data-/.test(attr.name)) {\n                                        var camelCaseName = attr.name.substr(5).replace(/-(.)/g, function ($0, $1) {\n                                            return $1.toUpperCase();\n                                        });\n                                        data[camelCaseName] = attr.value;\n                                    }\n                                });\n                                for( var key in data ) {\n                                    if( data.hasOwnProperty(key)\n                                        && key != \'djupload\' ) {\n                                        response[key] = data[key];\n                                    }\n                                }\n                                $.ajax({\n                                    type: "POST",\n                                    url: completeUrl,\n                                    beforeSend: function(xhr) {\n                                        xhr.setRequestHeader(\n                                            "X-CSRFToken", getMetaCSRFToken());\n                                    },\n                                    data: JSON.stringify(response),\n                                    datatype: "json",\n                                    contentType: "application/json; charset=utf-8",\n                                    success: function(resp) {\n                                        self._uploadSuccess(file, resp);\n                                    },\n                                    error: function(resp) {\n                                        self._uploadError(file, resp);\n                                    }\n                                });\n                            } else {\n                                self._uploadSuccess(file, response);\n                            }\n                        } else {\n                            self._uploadSuccess(file, response);\n                        }\n                    });\n\n                    this.on("error", function(file, message){\n                        self._uploadError(file, message);\n                    });\n\n                    this.on("uploadprogress", function(file, progress){\n                        self._uploadProgress(file, progress);\n                    });\n                }\n            });\n        }\n    };\n\n    $.fn.djupload = function(options) {\n        var opts = $.extend( {}, $.fn.djupload.defaults, options );\n        return this.each(function() {\n            if (!$.data(this, "djupload")) {\n                $.data(this, "djupload", new Djupload(this, opts));\n            }\n        });\n    };\n\n    $.fn.djupload.defaults = {\n        // location\n        uploadUrl: null,\n        mediaPrefix: "",\n\n        uploadZone: "body",\n        uploadClickableZone: true,\n        uploadParamName: "file",\n        uploadMaxFileSize: 250,\n\n        // Django upload\n        csrfToken: null,\n\n        // S3 direct upload\n        accessKey: null,\n        securityToken: null,\n        acl: null, // defaults to "private".\n        policy: "",\n        signature: null,\n        amzCredential: null,\n        amzDate: null,\n        amzServerSideEncryption: null,\n\n        // callback\n        uploadSuccess: function(file, resp) {\n            showMessages([\'"\' + file.name + \'" uploaded sucessfully\'],\n                \'success\');\n        },\n        uploadError: null,\n        uploadProgress: null,\n\n        // error messages\n        configError: "instantiated djupload() with no uploadUrl specified."\n\n    };\n\n    Dropzone.autoDiscover = false;\n\n})(jQuery);\n\n'},173:function(t,n,e){"use strict";e.r(n);e(5),e(14),e(8),e(174),e(176),e(178),e(180),e(182),e(184),e(186),e(188),e(12),e(190),e(16),e(192),e(194),e(196)},174:function(t,n,e){e(1)(e(175))},175:function(t,n){t.exports='// jquery.selection\n// ----------------\n// v0.1.2\n//\n// Copyright (c) 2013-2015 Mateus Maso\n// Distributed under MIT license\n//\n// http://github.com/mateusmaso/jquery.selection\n\n(function(root, factory) {\n\n  if (typeof exports !== \'undefined\') {\n    if (typeof module !== \'undefined\' && module.exports)\n      module.exports = factory(global.$);\n    exports = factory(global.$);\n  } else {\n    factory(root.$);\n  }\n\n}(this, function($) {\n\n  $.fn.saveSelection = function() {\n    return this.each(function() {\n      if (window.getSelection().rangeCount > 0) {\n        $(this).data("savedSelection", window.getSelection().getRangeAt(0));\n      }\n    });\n  };\n\n  $.fn.restoreSelection = function() {\n    return this.each(function() {\n      var selection = window.getSelection();\n      var range = $(this).data("savedSelection");\n\n      if ($(this).is("textarea") || $(this).is("input") || !range) {\n        $(this).focus();\n      } else {\n        if (selection.rangeCount > 0) selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    });\n  };\n\n  $.fn.hasSelection = function() {\n    return $(this).data("savedSelection") != null;\n  };\n\n}));\n'},176:function(t,n,e){e(1)(e(177))},177:function(t,n){t.exports="/*!\n\tAutosize 1.18.18\n\tlicense: MIT\n\thttp://www.jacklmoore.com/autosize\n*/\n(function ($) {\n\tvar\n\tdefaults = {\n\t\tclassName: 'autosizejs',\n\t\tid: 'autosizejs',\n\t\tappend: '\\n',\n\t\tcallback: false,\n\t\tresizeDelay: 10,\n\t\tplaceholder: true\n\t},\n\n\t// line-height is conditionally included because IE7/IE8/old Opera do not return the correct value.\n\ttypographyStyles = [\n\t\t'fontFamily',\n\t\t'fontSize',\n\t\t'fontWeight',\n\t\t'fontStyle',\n\t\t'letterSpacing',\n\t\t'textTransform',\n\t\t'wordSpacing',\n\t\t'textIndent',\n\t\t'whiteSpace'\n\t],\n\n\t// to keep track which textarea is being mirrored when adjust() is called.\n\tmirrored,\n\n\t// the mirror element, which is used to calculate what size the mirrored element should be.\n\tmirror = $('<textarea tabindex=\"-1\"/>').data('autosize', true)[0];\n\n\t// border:0 is unnecessary, but avoids a bug in Firefox on OSX\n\tmirror.style.cssText = \"position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;\";\n\n\t// test that line-height can be accurately copied.\n\tmirror.style.lineHeight = '99px';\n\tif ($(mirror).css('lineHeight') === '99px') {\n\t\ttypographyStyles.push('lineHeight');\n\t}\n\tmirror.style.lineHeight = '';\n\n\t$.fn.autosize = function (options) {\n\t\tif (!this.length) {\n\t\t\treturn this;\n\t\t}\n\n\t\toptions = $.extend({}, defaults, options || {});\n\n\t\tif (mirror.parentNode !== document.body) {\n\t\t\t$(document.body).append(mirror);\n\t\t}\n\n\t\treturn this.each(function () {\n\t\t\tvar\n\t\t\tta = this,\n\t\t\t$ta = $(ta),\n\t\t\tmaxHeight,\n\t\t\tminHeight,\n\t\t\tboxOffset = 0,\n\t\t\tcallback = $.isFunction(options.callback),\n\t\t\toriginalStyles = {\n\t\t\t\theight: ta.style.height,\n\t\t\t\toverflow: ta.style.overflow,\n\t\t\t\toverflowY: ta.style.overflowY,\n\t\t\t\twordWrap: ta.style.wordWrap,\n\t\t\t\tresize: ta.style.resize\n\t\t\t},\n\t\t\ttimeout,\n\t\t\twidth = $ta.width(),\n\t\t\ttaResize = $ta.css('resize');\n\n\t\t\tif ($ta.data('autosize')) {\n\t\t\t\t// exit if autosize has already been applied, or if the textarea is the mirror element.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$ta.data('autosize', true);\n\n\t\t\tif ($ta.css('box-sizing') === 'border-box' || $ta.css('-moz-box-sizing') === 'border-box' || $ta.css('-webkit-box-sizing') === 'border-box'){\n\t\t\t\tboxOffset = $ta.outerHeight() - $ta.height();\n\t\t\t}\n\n\t\t\t// IE8 and lower return 'auto', which parses to NaN, if no min-height is set.\n\t\t\tminHeight = Math.max(parseFloat($ta.css('minHeight')) - boxOffset || 0, $ta.height());\n\n\t\t\t$ta.css({\n\t\t\t\toverflow: 'hidden',\n\t\t\t\toverflowY: 'hidden',\n\t\t\t\twordWrap: 'break-word' // horizontal overflow is hidden, so break-word is necessary for handling words longer than the textarea width\n\t\t\t});\n\n\t\t\tif (taResize === 'vertical') {\n\t\t\t\t$ta.css('resize','none');\n\t\t\t} else if (taResize === 'both') {\n\t\t\t\t$ta.css('resize', 'horizontal');\n\t\t\t}\n\n\t\t\t// getComputedStyle is preferred here because it preserves sub-pixel values, while jQuery's .width() rounds to an integer.\n\t\t\tfunction setWidth() {\n\t\t\t\tvar width;\n\t\t\t\tvar style = window.getComputedStyle ? window.getComputedStyle(ta, null) : null;\n\n\t\t\t\tif (style) {\n\t\t\t\t\twidth = parseFloat(style.width);\n\t\t\t\t\tif (style.boxSizing === 'border-box' || style.webkitBoxSizing === 'border-box' || style.mozBoxSizing === 'border-box') {\n\t\t\t\t\t\t$.each(['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'], function(i,val){\n\t\t\t\t\t\t\twidth -= parseFloat(style[val]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twidth = $ta.width();\n\t\t\t\t}\n\n\t\t\t\tmirror.style.width = Math.max(width,0) + 'px';\n\t\t\t}\n\n\t\t\tfunction initMirror() {\n\t\t\t\tvar styles = {};\n\n\t\t\t\tmirrored = ta;\n\t\t\t\tmirror.className = options.className;\n\t\t\t\tmirror.id = options.id;\n\t\t\t\tmaxHeight = parseFloat($ta.css('maxHeight'));\n\n\t\t\t\t// mirror is a duplicate textarea located off-screen that\n\t\t\t\t// is automatically updated to contain the same text as the\n\t\t\t\t// original textarea.  mirror always has a height of 0.\n\t\t\t\t// This gives a cross-browser supported way getting the actual\n\t\t\t\t// height of the text, through the scrollTop property.\n\t\t\t\t$.each(typographyStyles, function(i,val){\n\t\t\t\t\tstyles[val] = $ta.css(val);\n\t\t\t\t});\n\n\t\t\t\t$(mirror).css(styles).attr('wrap', $ta.attr('wrap'));\n\n\t\t\t\tsetWidth();\n\n\t\t\t\t// Chrome-specific fix:\n\t\t\t\t// When the textarea y-overflow is hidden, Chrome doesn't reflow the text to account for the space\n\t\t\t\t// made available by removing the scrollbar. This workaround triggers the reflow for Chrome.\n\t\t\t\tif (window.chrome) {\n\t\t\t\t\tvar width = ta.style.width;\n\t\t\t\t\tta.style.width = '0px';\n\t\t\t\t\tvar ignore = ta.offsetWidth;\n\t\t\t\t\tta.style.width = width;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Using mainly bare JS in this function because it is going\n\t\t\t// to fire very often while typing, and needs to very efficient.\n\t\t\tfunction adjust() {\n\t\t\t\tvar height, originalHeight;\n\n\t\t\t\tif (mirrored !== ta) {\n\t\t\t\t\tinitMirror();\n\t\t\t\t} else {\n\t\t\t\t\tsetWidth();\n\t\t\t\t}\n\n\t\t\t\tif (!ta.value && options.placeholder) {\n\t\t\t\t\t// If the textarea is empty, copy the placeholder text into\n\t\t\t\t\t// the mirror control and use that for sizing so that we\n\t\t\t\t\t// don't end up with placeholder getting trimmed.\n\t\t\t\t\tmirror.value = ($ta.attr(\"placeholder\") || '');\n\t\t\t\t} else {\n\t\t\t\t\tmirror.value = ta.value;\n\t\t\t\t}\n\n\t\t\t\tmirror.value += options.append || '';\n\t\t\t\tmirror.style.overflowY = ta.style.overflowY;\n\t\t\t\toriginalHeight = parseFloat(ta.style.height) || 0;\n\n\t\t\t\t// Setting scrollTop to zero is needed in IE8 and lower for the next step to be accurately applied\n\t\t\t\tmirror.scrollTop = 0;\n\n\t\t\t\tmirror.scrollTop = 9e4;\n\n\t\t\t\t// Using scrollTop rather than scrollHeight because scrollHeight is non-standard and includes padding.\n\t\t\t\theight = mirror.scrollTop;\n\n\t\t\t\tif (maxHeight && height > maxHeight) {\n\t\t\t\t\tta.style.overflowY = 'scroll';\n\t\t\t\t\theight = maxHeight;\n\t\t\t\t} else {\n\t\t\t\t\tta.style.overflowY = 'hidden';\n\t\t\t\t\tif (height < minHeight) {\n\t\t\t\t\t\theight = minHeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\theight += boxOffset;\n\n\t\t\t\tif (Math.abs(originalHeight - height) > 1/100) {\n\t\t\t\t\tta.style.height = height + 'px';\n\n\t\t\t\t\t// Trigger a repaint for IE8 for when ta is nested 2 or more levels inside an inline-block\n\t\t\t\t\tmirror.className = mirror.className;\n\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\toptions.callback.call(ta,ta);\n\t\t\t\t\t}\n\t\t\t\t\t$ta.trigger('autosize.resized');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction resize () {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\ttimeout = setTimeout(function(){\n\t\t\t\t\tvar newWidth = $ta.width();\n\n\t\t\t\t\tif (newWidth !== width) {\n\t\t\t\t\t\twidth = newWidth;\n\t\t\t\t\t\tadjust();\n\t\t\t\t\t}\n\t\t\t\t}, parseInt(options.resizeDelay,10));\n\t\t\t}\n\n\t\t\tif ('onpropertychange' in ta) {\n\t\t\t\tif ('oninput' in ta) {\n\t\t\t\t\t// Detects IE9.  IE9 does not fire onpropertychange or oninput for deletions,\n\t\t\t\t\t// so binding to onkeyup to catch most of those occasions.  There is no way that I\n\t\t\t\t\t// know of to detect something like 'cut' in IE9.\n\t\t\t\t\t$ta.on('input.autosize keyup.autosize', adjust);\n\t\t\t\t} else {\n\t\t\t\t\t// IE7 / IE8\n\t\t\t\t\t$ta.on('propertychange.autosize', function(){\n\t\t\t\t\t\tif(event.propertyName === 'value'){\n\t\t\t\t\t\t\tadjust();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Modern Browsers\n\t\t\t\t$ta.on('input.autosize', adjust);\n\t\t\t}\n\n\t\t\t// Set options.resizeDelay to false if using fixed-width textarea elements.\n\t\t\t// Uses a timeout and width check to reduce the amount of times adjust needs to be called after window resize.\n\n\t\t\tif (options.resizeDelay !== false) {\n\t\t\t\t$(window).on('resize.autosize', resize);\n\t\t\t}\n\n\t\t\t// Event for manual triggering if needed.\n\t\t\t// Should only be needed when the value of the textarea is changed through JavaScript rather than user input.\n\t\t\t$ta.on('autosize.resize', adjust);\n\n\t\t\t// Event for manual triggering that also forces the styles to update as well.\n\t\t\t// Should only be needed if one of typography styles of the textarea change, and the textarea is already the target of the adjust method.\n\t\t\t$ta.on('autosize.resizeIncludeStyle', function() {\n\t\t\t\tmirrored = null;\n\t\t\t\tadjust();\n\t\t\t});\n\n\t\t\t$ta.on('autosize.destroy', function(){\n\t\t\t\tmirrored = null;\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\t$(window).off('resize', resize);\n\t\t\t\t$ta\n\t\t\t\t\t.off('autosize')\n\t\t\t\t\t.off('.autosize')\n\t\t\t\t\t.css(originalStyles)\n\t\t\t\t\t.removeData('autosize');\n\t\t\t});\n\n\t\t\t// Call adjust in case the textarea already contains text.\n\t\t\tadjust();\n\t\t});\n\t};\n}(jQuery || $)); // jQuery or jQuery-like library, such as Zepto\n"},178:function(t,n,e){e(1)(e(179))},179:function(t,n){t.exports='var Markdown;\r\n\r\nif (typeof exports === "object" && typeof require === "function") // we\'re in a CommonJS (e.g. Node.js) module\r\n    Markdown = exports;\r\nelse\r\n    Markdown = {};\r\n    \r\n// The following text is included for historical reasons, but should\r\n// be taken with a pinch of salt; it\'s not all true anymore.\r\n\r\n//\r\n// Wherever possible, Showdown is a straight, line-by-line port\r\n// of the Perl version of Markdown.\r\n//\r\n// This is not a normal parser design; it\'s basically just a\r\n// series of string substitutions.  It\'s hard to read and\r\n// maintain this way,  but keeping Showdown close to the original\r\n// design makes it easier to port new features.\r\n//\r\n// More importantly, Showdown behaves like markdown.pl in most\r\n// edge cases.  So web applications can do client-side preview\r\n// in Javascript, and then build identical HTML on the server.\r\n//\r\n// This port needs the new RegExp functionality of ECMA 262,\r\n// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers\r\n// should do fine.  Even with the new regular expression features,\r\n// We do a lot of work to emulate Perl\'s regex functionality.\r\n// The tricky changes in this file mostly have the "attacklab:"\r\n// label.  Major or self-explanatory changes don\'t.\r\n//\r\n// Smart diff tools like Araxis Merge will be able to match up\r\n// this file with markdown.pl in a useful way.  A little tweaking\r\n// helps: in a copy of markdown.pl, replace "#" with "//" and\r\n// replace "$text" with "text".  Be sure to ignore whitespace\r\n// and line endings.\r\n//\r\n\r\n\r\n//\r\n// Usage:\r\n//\r\n//   var text = "Markdown *rocks*.";\r\n//\r\n//   var converter = new Markdown.Converter();\r\n//   var html = converter.makeHtml(text);\r\n//\r\n//   alert(html);\r\n//\r\n// Note: move the sample code to the bottom of this\r\n// file before uncommenting it.\r\n//\r\n\r\n(function () {\r\n\r\n    function identity(x) { return x; }\r\n    function returnFalse(x) { return false; }\r\n\r\n    function HookCollection() { }\r\n\r\n    HookCollection.prototype = {\r\n\r\n        chain: function (hookname, func) {\r\n            var original = this[hookname];\r\n            if (!original)\r\n                throw new Error("unknown hook " + hookname);\r\n\r\n            if (original === identity)\r\n                this[hookname] = func;\r\n            else\r\n                this[hookname] = function (text) {\r\n                    var args = Array.prototype.slice.call(arguments, 0);\r\n                    args[0] = original.apply(null, args);\r\n                    return func.apply(null, args);\r\n                };\r\n        },\r\n        set: function (hookname, func) {\r\n            if (!this[hookname])\r\n                throw new Error("unknown hook " + hookname);\r\n            this[hookname] = func;\r\n        },\r\n        addNoop: function (hookname) {\r\n            this[hookname] = identity;\r\n        },\r\n        addFalse: function (hookname) {\r\n            this[hookname] = returnFalse;\r\n        }\r\n    };\r\n\r\n    Markdown.HookCollection = HookCollection;\r\n\r\n    // g_urls and g_titles allow arbitrary user-entered strings as keys. This\r\n    // caused an exception (and hence stopped the rendering) when the user entered\r\n    // e.g. [push] or [__proto__]. Adding a prefix to the actual key prevents this\r\n    // (since no builtin property starts with "s_"). See\r\n    // http://meta.stackoverflow.com/questions/64655/strange-wmd-bug\r\n    // (granted, switching from Array() to Object() alone would have left only __proto__\r\n    // to be a problem)\r\n    function SaveHash() { }\r\n    SaveHash.prototype = {\r\n        set: function (key, value) {\r\n            this["s_" + key] = value;\r\n        },\r\n        get: function (key) {\r\n            return this["s_" + key];\r\n        }\r\n    };\r\n\r\n    Markdown.Converter = function () {\r\n        var pluginHooks = this.hooks = new HookCollection();\r\n        \r\n        // given a URL that was encountered by itself (without markup), should return the link text that\'s to be given to this link\r\n        pluginHooks.addNoop("plainLinkText");\r\n        \r\n        // called with the orignal text as given to makeHtml. The result of this plugin hook is the actual markdown source that will be cooked\r\n        pluginHooks.addNoop("preConversion");\r\n        \r\n        // called with the text once all normalizations have been completed (tabs to spaces, line endings, etc.), but before any conversions have\r\n        pluginHooks.addNoop("postNormalization");\r\n        \r\n        // Called with the text before / after creating block elements like code blocks and lists. Note that this is called recursively\r\n        // with inner content, e.g. it\'s called with the full text, and then only with the content of a blockquote. The inner\r\n        // call will receive outdented text.\r\n        pluginHooks.addNoop("preBlockGamut");\r\n        pluginHooks.addNoop("postBlockGamut");\r\n        \r\n        // called with the text of a single block element before / after the span-level conversions (bold, code spans, etc.) have been made\r\n        pluginHooks.addNoop("preSpanGamut");\r\n        pluginHooks.addNoop("postSpanGamut");\r\n        \r\n        // called with the final cooked HTML code. The result of this plugin hook is the actual output of makeHtml\r\n        pluginHooks.addNoop("postConversion");\r\n\r\n        //\r\n        // Private state of the converter instance:\r\n        //\r\n\r\n        // Global hashes, used by various utility routines\r\n        var g_urls;\r\n        var g_titles;\r\n        var g_html_blocks;\r\n\r\n        // Used to track when we\'re inside an ordered or unordered list\r\n        // (see _ProcessListItems() for details):\r\n        var g_list_level;\r\n\r\n        this.makeHtml = function (text) {\r\n\r\n            //\r\n            // Main function. The order in which other subs are called here is\r\n            // essential. Link and image substitutions need to happen before\r\n            // _EscapeSpecialCharsWithinTagAttributes(), so that any *\'s or _\'s in the <a>\r\n            // and <img> tags get encoded.\r\n            //\r\n\r\n            // This will only happen if makeHtml on the same converter instance is called from a plugin hook.\r\n            // Don\'t do that.\r\n            if (g_urls)\r\n                throw new Error("Recursive call to converter.makeHtml");\r\n        \r\n            // Create the private state objects.\r\n            g_urls = new SaveHash();\r\n            g_titles = new SaveHash();\r\n            g_html_blocks = [];\r\n            g_list_level = 0;\r\n\r\n            text = pluginHooks.preConversion(text);\r\n\r\n            // attacklab: Replace ~ with ~T\r\n            // This lets us use tilde as an escape char to avoid md5 hashes\r\n            // The choice of character is arbitray; anything that isn\'t\r\n            // magic in Markdown will work.\r\n            text = text.replace(/~/g, "~T");\r\n\r\n            // attacklab: Replace $ with ~D\r\n            // RegExp interprets $ as a special character\r\n            // when it\'s in a replacement string\r\n            text = text.replace(/\\$/g, "~D");\r\n\r\n            // Standardize line endings\r\n            text = text.replace(/\\r\\n/g, "\\n"); // DOS to Unix\r\n            text = text.replace(/\\r/g, "\\n"); // Mac to Unix\r\n\r\n            // Make sure text begins and ends with a couple of newlines:\r\n            text = "\\n\\n" + text + "\\n\\n";\r\n\r\n            // Convert all tabs to spaces.\r\n            text = _Detab(text);\r\n\r\n            // Strip any lines consisting only of spaces and tabs.\r\n            // This makes subsequent regexen easier to write, because we can\r\n            // match consecutive blank lines with /\\n+/ instead of something\r\n            // contorted like /[ \\t]*\\n+/ .\r\n            text = text.replace(/^[ \\t]+$/mg, "");\r\n            \r\n            text = pluginHooks.postNormalization(text);\r\n\r\n            // Turn block-level HTML blocks into hash entries\r\n            text = _HashHTMLBlocks(text);\r\n\r\n            // Strip link definitions, store in hashes.\r\n            text = _StripLinkDefinitions(text);\r\n\r\n            text = _RunBlockGamut(text);\r\n\r\n            text = _UnescapeSpecialChars(text);\r\n\r\n            // attacklab: Restore dollar signs\r\n            text = text.replace(/~D/g, "$$");\r\n\r\n            // attacklab: Restore tildes\r\n            text = text.replace(/~T/g, "~");\r\n\r\n            text = pluginHooks.postConversion(text);\r\n\r\n            g_html_blocks = g_titles = g_urls = null;\r\n\r\n            return text;\r\n        };\r\n\r\n        function _StripLinkDefinitions(text) {\r\n            //\r\n            // Strips link definitions from text, stores the URLs and titles in\r\n            // hash references.\r\n            //\r\n\r\n            // Link defs are in the form: ^[id]: url "optional title"\r\n\r\n            /*\r\n            text = text.replace(/\r\n                ^[ ]{0,3}\\[(.+)\\]:  // id = $1  attacklab: g_tab_width - 1\r\n                [ \\t]*\r\n                \\n?                 // maybe *one* newline\r\n                [ \\t]*\r\n                <?(\\S+?)>?          // url = $2\r\n                (?=\\s|$)            // lookahead for whitespace instead of the lookbehind removed below\r\n                [ \\t]*\r\n                \\n?                 // maybe one newline\r\n                [ \\t]*\r\n                (                   // (potential) title = $3\r\n                    (\\n*)           // any lines skipped = $4 attacklab: lookbehind removed\r\n                    [ \\t]+\r\n                    ["(]\r\n                    (.+?)           // title = $5\r\n                    [")]\r\n                    [ \\t]*\r\n                )?                  // title is optional\r\n                (?:\\n+|$)\r\n            /gm, function(){...});\r\n            */\r\n\r\n            text = text.replace(/^[ ]{0,3}\\[(.+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?(?=\\s|$)[ \\t]*\\n?[ \\t]*((\\n*)["(](.+?)[")][ \\t]*)?(?:\\n+)/gm,\r\n                function (wholeMatch, m1, m2, m3, m4, m5) {\r\n                    m1 = m1.toLowerCase();\r\n                    g_urls.set(m1, _EncodeAmpsAndAngles(m2));  // Link IDs are case-insensitive\r\n                    if (m4) {\r\n                        // Oops, found blank lines, so it\'s not a title.\r\n                        // Put back the parenthetical statement we stole.\r\n                        return m3;\r\n                    } else if (m5) {\r\n                        g_titles.set(m1, m5.replace(/"/g, "&quot;"));\r\n                    }\r\n\r\n                    // Completely remove the definition from the text\r\n                    return "";\r\n                }\r\n            );\r\n\r\n            return text;\r\n        }\r\n\r\n        function _HashHTMLBlocks(text) {\r\n\r\n            // Hashify HTML blocks:\r\n            // We only want to do this for block-level HTML tags, such as headers,\r\n            // lists, and tables. That\'s because we still want to wrap <p>s around\r\n            // "paragraphs" that are wrapped in non-block-level tags, such as anchors,\r\n            // phrase emphasis, and spans. The list of tags we\'re looking for is\r\n            // hard-coded:\r\n            var block_tags_a = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del"\r\n            var block_tags_b = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math"\r\n\r\n            // First, look for nested blocks, e.g.:\r\n            //   <div>\r\n            //     <div>\r\n            //     tags for inner block must be indented.\r\n            //     </div>\r\n            //   </div>\r\n            //\r\n            // The outermost tags must start at the left margin for this to match, and\r\n            // the inner nested divs must be indented.\r\n            // We need to do this before the next, more liberal match, because the next\r\n            // match will start at the first `<div>` and stop at the first `</div>`.\r\n\r\n            // attacklab: This regex can be expensive when it fails.\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (                       // save in $1\r\n                    ^                   // start of line  (with /m)\r\n                    <($block_tags_a)    // start tag = $2\r\n                    \\b                  // word break\r\n                                        // attacklab: hack around khtml/pcre bug...\r\n                    [^\\r]*?\\n           // any number of lines, minimally matching\r\n                    </\\2>               // the matching end tag\r\n                    [ \\t]*              // trailing spaces/tabs\r\n                    (?=\\n+)             // followed by a newline\r\n                )                       // attacklab: there are sentinel newlines at end of document\r\n            /gm,function(){...}};\r\n            */\r\n            text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm, hashElement);\r\n\r\n            //\r\n            // Now match more liberally, simply from `\\n<tag>` to `</tag>\\n`\r\n            //\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (                       // save in $1\r\n                    ^                   // start of line  (with /m)\r\n                    <($block_tags_b)    // start tag = $2\r\n                    \\b                  // word break\r\n                                        // attacklab: hack around khtml/pcre bug...\r\n                    [^\\r]*?             // any number of lines, minimally matching\r\n                    .*</\\2>             // the matching end tag\r\n                    [ \\t]*              // trailing spaces/tabs\r\n                    (?=\\n+)             // followed by a newline\r\n                )                       // attacklab: there are sentinel newlines at end of document\r\n            /gm,function(){...}};\r\n            */\r\n            text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\\b[^\\r]*?.*<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm, hashElement);\r\n\r\n            // Special case just for <hr />. It was easier to make a special case than\r\n            // to make the other regex more complicated.  \r\n\r\n            /*\r\n            text = text.replace(/\r\n                \\n                  // Starting after a blank line\r\n                [ ]{0,3}\r\n                (                   // save in $1\r\n                    (<(hr)          // start tag = $2\r\n                        \\b          // word break\r\n                        ([^<>])*?\r\n                    \\/?>)           // the matching end tag\r\n                    [ \\t]*\r\n                    (?=\\n{2,})      // followed by a blank line\r\n                )\r\n            /g,hashElement);\r\n            */\r\n            text = text.replace(/\\n[ ]{0,3}((<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g, hashElement);\r\n\r\n            // Special case for standalone HTML comments:\r\n\r\n            /*\r\n            text = text.replace(/\r\n                \\n\\n                                            // Starting after a blank line\r\n                [ ]{0,3}                                        // attacklab: g_tab_width - 1\r\n                (                                               // save in $1\r\n                    <!\r\n                    (--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)   // see http://www.w3.org/TR/html-markup/syntax.html#comments and http://meta.stackoverflow.com/q/95256\r\n                    >\r\n                    [ \\t]*\r\n                    (?=\\n{2,})                                  // followed by a blank line\r\n                )\r\n            /g,hashElement);\r\n            */\r\n            text = text.replace(/\\n\\n[ ]{0,3}(<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>[ \\t]*(?=\\n{2,}))/g, hashElement);\r\n\r\n            // PHP and ASP-style processor instructions (<?...?> and <%...%>)\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (?:\r\n                    \\n\\n            // Starting after a blank line\r\n                )\r\n                (                   // save in $1\r\n                    [ ]{0,3}        // attacklab: g_tab_width - 1\r\n                    (?:\r\n                        <([?%])     // $2\r\n                        [^\\r]*?\r\n                        \\2>\r\n                    )\r\n                    [ \\t]*\r\n                    (?=\\n{2,})      // followed by a blank line\r\n                )\r\n            /g,hashElement);\r\n            */\r\n            text = text.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g, hashElement);\r\n\r\n            return text;\r\n        }\r\n\r\n        function hashElement(wholeMatch, m1) {\r\n            var blockText = m1;\r\n\r\n            // Undo double lines\r\n            blockText = blockText.replace(/^\\n+/, "");\r\n\r\n            // strip trailing blank lines\r\n            blockText = blockText.replace(/\\n+$/g, "");\r\n\r\n            // Replace the element text with a marker ("~KxK" where x is its key)\r\n            blockText = "\\n\\n~K" + (g_html_blocks.push(blockText) - 1) + "K\\n\\n";\r\n\r\n            return blockText;\r\n        }\r\n        \r\n        var blockGamutHookCallback = function (t) { return _RunBlockGamut(t); }\r\n\r\n        function _RunBlockGamut(text, doNotUnhash) {\r\n            //\r\n            // These are all the transformations that form block-level\r\n            // tags like paragraphs, headers, and list items.\r\n            //\r\n            \r\n            text = pluginHooks.preBlockGamut(text, blockGamutHookCallback);\r\n            \r\n            text = _DoHeaders(text);\r\n\r\n            // Do Horizontal Rules:\r\n            var replacement = "<hr />\\n";\r\n            text = text.replace(/^[ ]{0,2}([ ]?\\*[ ]?){3,}[ \\t]*$/gm, replacement);\r\n            text = text.replace(/^[ ]{0,2}([ ]?-[ ]?){3,}[ \\t]*$/gm, replacement);\r\n            text = text.replace(/^[ ]{0,2}([ ]?_[ ]?){3,}[ \\t]*$/gm, replacement);\r\n\r\n            text = _DoLists(text);\r\n            text = _DoCodeBlocks(text);\r\n            text = _DoBlockQuotes(text);\r\n            \r\n            text = pluginHooks.postBlockGamut(text, blockGamutHookCallback);\r\n\r\n            // We already ran _HashHTMLBlocks() before, in Markdown(), but that\r\n            // was to escape raw HTML in the original Markdown source. This time,\r\n            // we\'re escaping the markup we\'ve just created, so that we don\'t wrap\r\n            // <p> tags around block-level tags.\r\n            text = _HashHTMLBlocks(text);\r\n            text = _FormParagraphs(text, doNotUnhash);\r\n\r\n            return text;\r\n        }\r\n\r\n        function _RunSpanGamut(text) {\r\n            //\r\n            // These are all the transformations that occur *within* block-level\r\n            // tags like paragraphs, headers, and list items.\r\n            //\r\n\r\n            text = pluginHooks.preSpanGamut(text);\r\n            \r\n            text = _DoCodeSpans(text);\r\n            text = _EscapeSpecialCharsWithinTagAttributes(text);\r\n            text = _EncodeBackslashEscapes(text);\r\n\r\n            // Process anchor and image tags. Images must come first,\r\n            // because ![foo][f] looks like an anchor.\r\n            text = _DoImages(text);\r\n            text = _DoAnchors(text);\r\n\r\n            // Make links out of things like `<http://example.com/>`\r\n            // Must come after _DoAnchors(), because you can use < and >\r\n            // delimiters in inline links like [this](<url>).\r\n            text = _DoAutoLinks(text);\r\n            \r\n            text = text.replace(/~P/g, "://"); // put in place to prevent autolinking; reset now\r\n            \r\n            text = _EncodeAmpsAndAngles(text);\r\n            text = _DoItalicsAndBold(text);\r\n\r\n            // Do hard breaks:\r\n            text = text.replace(/  +\\n/g, " <br>\\n");\r\n            \r\n            text = pluginHooks.postSpanGamut(text);\r\n\r\n            return text;\r\n        }\r\n\r\n        function _EscapeSpecialCharsWithinTagAttributes(text) {\r\n            //\r\n            // Within tags -- meaning between < and > -- encode [\\ ` * _] so they\r\n            // don\'t conflict with their use in Markdown for code, italics and strong.\r\n            //\r\n\r\n            // Build a regex to find HTML tags and comments.  See Friedl\'s \r\n            // "Mastering Regular Expressions", 2nd Ed., pp. 200-201.\r\n\r\n            // SE: changed the comment part of the regex\r\n\r\n            var regex = /(<[a-z\\/!$]("[^"]*"|\'[^\']*\'|[^\'">])*>|<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>)/gi;\r\n\r\n            text = text.replace(regex, function (wholeMatch) {\r\n                var tag = wholeMatch.replace(/(.)<\\/?code>(?=.)/g, "$1`");\r\n                tag = escapeCharacters(tag, wholeMatch.charAt(1) == "!" ? "\\\\`*_/" : "\\\\`*_"); // also escape slashes in comments to prevent autolinking there -- http://meta.stackoverflow.com/questions/95987\r\n                return tag;\r\n            });\r\n\r\n            return text;\r\n        }\r\n\r\n        function _DoAnchors(text) {\r\n            //\r\n            // Turn Markdown link shortcuts into XHTML <a> tags.\r\n            //\r\n            //\r\n            // First, handle reference-style links: [link text] [id]\r\n            //\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (                           // wrap whole match in $1\r\n                    \\[\r\n                    (\r\n                        (?:\r\n                            \\[[^\\]]*\\]      // allow brackets nested one level\r\n                            |\r\n                            [^\\[]           // or anything else\r\n                        )*\r\n                    )\r\n                    \\]\r\n\r\n                    [ ]?                    // one optional space\r\n                    (?:\\n[ ]*)?             // one optional newline followed by spaces\r\n\r\n                    \\[\r\n                    (.*?)                   // id = $3\r\n                    \\]\r\n                )\r\n                ()()()()                    // pad remaining backreferences\r\n            /g, writeAnchorTag);\r\n            */\r\n            text = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g, writeAnchorTag);\r\n\r\n            //\r\n            // Next, inline-style links: [link text](url "optional title")\r\n            //\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (                           // wrap whole match in $1\r\n                    \\[\r\n                    (\r\n                        (?:\r\n                            \\[[^\\]]*\\]      // allow brackets nested one level\r\n                            |\r\n                            [^\\[\\]]         // or anything else\r\n                        )*\r\n                    )\r\n                    \\]\r\n                    \\(                      // literal paren\r\n                    [ \\t]*\r\n                    ()                      // no id, so leave $3 empty\r\n                    <?(                     // href = $4\r\n                        (?:\r\n                            \\([^)]*\\)       // allow one level of (correctly nested) parens (think MSDN)\r\n                            |\r\n                            [^()\\s]\r\n                        )*?\r\n                    )>?                \r\n                    [ \\t]*\r\n                    (                       // $5\r\n                        ([\'"])              // quote char = $6\r\n                        (.*?)               // Title = $7\r\n                        \\6                  // matching quote\r\n                        [ \\t]*              // ignore any spaces/tabs between closing quote and )\r\n                    )?                      // title is optional\r\n                    \\)\r\n                )\r\n            /g, writeAnchorTag);\r\n            */\r\n\r\n            text = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]\\([ \\t]*()<?((?:\\([^)]*\\)|[^()\\s])*?)>?[ \\t]*(([\'"])(.*?)\\6[ \\t]*)?\\))/g, writeAnchorTag);\r\n\r\n            //\r\n            // Last, handle reference-style shortcuts: [link text]\r\n            // These must come last in case you\'ve also got [link test][1]\r\n            // or [link test](/foo)\r\n            //\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (                   // wrap whole match in $1\r\n                    \\[\r\n                    ([^\\[\\]]+)      // link text = $2; can\'t contain \'[\' or \']\'\r\n                    \\]\r\n                )\r\n                ()()()()()          // pad rest of backreferences\r\n            /g, writeAnchorTag);\r\n            */\r\n            text = text.replace(/(\\[([^\\[\\]]+)\\])()()()()()/g, writeAnchorTag);\r\n\r\n            return text;\r\n        }\r\n\r\n        function writeAnchorTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {\r\n            if (m7 == undefined) m7 = "";\r\n            var whole_match = m1;\r\n            var link_text = m2.replace(/:\\/\\//g, "~P"); // to prevent auto-linking withing the link. will be converted back after the auto-linker runs\r\n            var link_id = m3.toLowerCase();\r\n            var url = m4;\r\n            var title = m7;\r\n\r\n            if (url == "") {\r\n                if (link_id == "") {\r\n                    // lower-case and turn embedded newlines into spaces\r\n                    link_id = link_text.toLowerCase().replace(/ ?\\n/g, " ");\r\n                }\r\n                url = "#" + link_id;\r\n\r\n                if (g_urls.get(link_id) != undefined) {\r\n                    url = g_urls.get(link_id);\r\n                    if (g_titles.get(link_id) != undefined) {\r\n                        title = g_titles.get(link_id);\r\n                    }\r\n                }\r\n                else {\r\n                    if (whole_match.search(/\\(\\s*\\)$/m) > -1) {\r\n                        // Special case for explicit empty url\r\n                        url = "";\r\n                    } else {\r\n                        return whole_match;\r\n                    }\r\n                }\r\n            }\r\n            url = encodeProblemUrlChars(url);\r\n            url = escapeCharacters(url, "*_");\r\n            var result = "<a href=\\"" + url + "\\"";\r\n\r\n            if (title != "") {\r\n                title = attributeEncode(title);\r\n                title = escapeCharacters(title, "*_");\r\n                result += " title=\\"" + title + "\\"";\r\n            }\r\n\r\n            result += ">" + link_text + "</a>";\r\n\r\n            return result;\r\n        }\r\n\r\n        function _DoImages(text) {\r\n            //\r\n            // Turn Markdown image shortcuts into <img> tags.\r\n            //\r\n\r\n            //\r\n            // First, handle reference-style labeled images: ![alt text][id]\r\n            //\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (                   // wrap whole match in $1\r\n                    !\\[\r\n                    (.*?)           // alt text = $2\r\n                    \\]\r\n\r\n                    [ ]?            // one optional space\r\n                    (?:\\n[ ]*)?     // one optional newline followed by spaces\r\n\r\n                    \\[\r\n                    (.*?)           // id = $3\r\n                    \\]\r\n                )\r\n                ()()()()            // pad rest of backreferences\r\n            /g, writeImageTag);\r\n            */\r\n            text = text.replace(/(!\\[(.*?)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g, writeImageTag);\r\n\r\n            //\r\n            // Next, handle inline images:  ![alt text](url "optional title")\r\n            // Don\'t forget: encode * and _\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (                   // wrap whole match in $1\r\n                    !\\[\r\n                    (.*?)           // alt text = $2\r\n                    \\]\r\n                    \\s?             // One optional whitespace character\r\n                    \\(              // literal paren\r\n                    [ \\t]*\r\n                    ()              // no id, so leave $3 empty\r\n                    <?(\\S+?)>?      // src url = $4\r\n                    [ \\t]*\r\n                    (               // $5\r\n                        ([\'"])      // quote char = $6\r\n                        (.*?)       // title = $7\r\n                        \\6          // matching quote\r\n                        [ \\t]*\r\n                    )?              // title is optional\r\n                    \\)\r\n                )\r\n            /g, writeImageTag);\r\n            */\r\n            text = text.replace(/(!\\[(.*?)\\]\\s?\\([ \\t]*()<?(\\S+?)>?[ \\t]*(([\'"])(.*?)\\6[ \\t]*)?\\))/g, writeImageTag);\r\n\r\n            return text;\r\n        }\r\n        \r\n        function attributeEncode(text) {\r\n            // unconditionally replace angle brackets here -- what ends up in an attribute (e.g. alt or title)\r\n            // never makes sense to have verbatim HTML in it (and the sanitizer would totally break it)\r\n            return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");\r\n        }\r\n\r\n        function writeImageTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {\r\n            var whole_match = m1;\r\n            var alt_text = m2;\r\n            var link_id = m3.toLowerCase();\r\n            var url = m4;\r\n            var title = m7;\r\n\r\n            if (!title) title = "";\r\n\r\n            if (url == "") {\r\n                if (link_id == "") {\r\n                    // lower-case and turn embedded newlines into spaces\r\n                    link_id = alt_text.toLowerCase().replace(/ ?\\n/g, " ");\r\n                }\r\n                url = "#" + link_id;\r\n\r\n                if (g_urls.get(link_id) != undefined) {\r\n                    url = g_urls.get(link_id);\r\n                    if (g_titles.get(link_id) != undefined) {\r\n                        title = g_titles.get(link_id);\r\n                    }\r\n                }\r\n                else {\r\n                    return whole_match;\r\n                }\r\n            }\r\n            \r\n            alt_text = escapeCharacters(attributeEncode(alt_text), "*_[]()");\r\n            url = escapeCharacters(url, "*_");\r\n            var result = "<img src=\\"" + url + "\\" alt=\\"" + alt_text + "\\"";\r\n\r\n            // attacklab: Markdown.pl adds empty title attributes to images.\r\n            // Replicate this bug.\r\n\r\n            //if (title != "") {\r\n            title = attributeEncode(title);\r\n            title = escapeCharacters(title, "*_");\r\n            result += " title=\\"" + title + "\\"";\r\n            //}\r\n\r\n            result += " />";\r\n\r\n            return result;\r\n        }\r\n\r\n        function _DoHeaders(text) {\r\n\r\n            // Setext-style headers:\r\n            //  Header 1\r\n            //  ========\r\n            //  \r\n            //  Header 2\r\n            //  --------\r\n            //\r\n            text = text.replace(/^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\r\n                function (wholeMatch, m1) { return "<h1>" + _RunSpanGamut(m1) + "</h1>\\n\\n"; }\r\n            );\r\n\r\n            text = text.replace(/^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm,\r\n                function (matchFound, m1) { return "<h2>" + _RunSpanGamut(m1) + "</h2>\\n\\n"; }\r\n            );\r\n\r\n            // atx-style headers:\r\n            //  # Header 1\r\n            //  ## Header 2\r\n            //  ## Header 2 with closing hashes ##\r\n            //  ...\r\n            //  ###### Header 6\r\n            //\r\n\r\n            /*\r\n            text = text.replace(/\r\n                ^(\\#{1,6})      // $1 = string of #\'s\r\n                [ \\t]*\r\n                (.+?)           // $2 = Header text\r\n                [ \\t]*\r\n                \\#*             // optional closing #\'s (not counted)\r\n                \\n+\r\n            /gm, function() {...});\r\n            */\r\n\r\n            text = text.replace(/^(\\#{1,6})[ \\t]*(.+?)[ \\t]*\\#*\\n+/gm,\r\n                function (wholeMatch, m1, m2) {\r\n                    var h_level = m1.length;\r\n                    return "<h" + h_level + ">" + _RunSpanGamut(m2) + "</h" + h_level + ">\\n\\n";\r\n                }\r\n            );\r\n\r\n            return text;\r\n        }\r\n\r\n        function _DoLists(text) {\r\n            //\r\n            // Form HTML ordered (numbered) and unordered (bulleted) lists.\r\n            //\r\n\r\n            // attacklab: add sentinel to hack around khtml/safari bug:\r\n            // http://bugs.webkit.org/show_bug.cgi?id=11231\r\n            text += "~0";\r\n\r\n            // Re-usable pattern to match any entirel ul or ol list:\r\n\r\n            /*\r\n            var whole_list = /\r\n                (                                   // $1 = whole list\r\n                    (                               // $2\r\n                        [ ]{0,3}                    // attacklab: g_tab_width - 1\r\n                        ([*+-]|\\d+[.])              // $3 = first list item marker\r\n                        [ \\t]+\r\n                    )\r\n                    [^\\r]+?\r\n                    (                               // $4\r\n                        ~0                          // sentinel for workaround; should be $\r\n                        |\r\n                        \\n{2,}\r\n                        (?=\\S)\r\n                        (?!                         // Negative lookahead for another list item marker\r\n                            [ \\t]*\r\n                            (?:[*+-]|\\d+[.])[ \\t]+\r\n                        )\r\n                    )\r\n                )\r\n            /g\r\n            */\r\n            var whole_list = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\r\n\r\n            if (g_list_level) {\r\n                text = text.replace(whole_list, function (wholeMatch, m1, m2) {\r\n                    var list = m1;\r\n                    var list_type = (m2.search(/[*+-]/g) > -1) ? "ul" : "ol";\r\n\r\n                    var result = _ProcessListItems(list, list_type);\r\n\r\n                    // Trim any trailing whitespace, to put the closing `</$list_type>`\r\n                    // up on the preceding line, to get it past the current stupid\r\n                    // HTML block parser. This is a hack to work around the terrible\r\n                    // hack that is the HTML block parser.\r\n                    result = result.replace(/\\s+$/, "");\r\n                    result = "<" + list_type + ">" + result + "</" + list_type + ">\\n";\r\n                    return result;\r\n                });\r\n            } else {\r\n                whole_list = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/g;\r\n                text = text.replace(whole_list, function (wholeMatch, m1, m2, m3) {\r\n                    var runup = m1;\r\n                    var list = m2;\r\n\r\n                    var list_type = (m3.search(/[*+-]/g) > -1) ? "ul" : "ol";\r\n                    var result = _ProcessListItems(list, list_type);\r\n                    result = runup + "<" + list_type + ">\\n" + result + "</" + list_type + ">\\n";\r\n                    return result;\r\n                });\r\n            }\r\n\r\n            // attacklab: strip sentinel\r\n            text = text.replace(/~0/, "");\r\n\r\n            return text;\r\n        }\r\n\r\n        var _listItemMarkers = { ol: "\\\\d+[.]", ul: "[*+-]" };\r\n\r\n        function _ProcessListItems(list_str, list_type) {\r\n            //\r\n            //  Process the contents of a single ordered or unordered list, splitting it\r\n            //  into individual list items.\r\n            //\r\n            //  list_type is either "ul" or "ol".\r\n\r\n            // The $g_list_level global keeps track of when we\'re inside a list.\r\n            // Each time we enter a list, we increment it; when we leave a list,\r\n            // we decrement. If it\'s zero, we\'re not in a list anymore.\r\n            //\r\n            // We do this because when we\'re not inside a list, we want to treat\r\n            // something like this:\r\n            //\r\n            //    I recommend upgrading to version\r\n            //    8. Oops, now this line is treated\r\n            //    as a sub-list.\r\n            //\r\n            // As a single paragraph, despite the fact that the second line starts\r\n            // with a digit-period-space sequence.\r\n            //\r\n            // Whereas when we\'re inside a list (or sub-list), that line will be\r\n            // treated as the start of a sub-list. What a kludge, huh? This is\r\n            // an aspect of Markdown\'s syntax that\'s hard to parse perfectly\r\n            // without resorting to mind-reading. Perhaps the solution is to\r\n            // change the syntax rules such that sub-lists must start with a\r\n            // starting cardinal number; e.g. "1." or "a.".\r\n\r\n            g_list_level++;\r\n\r\n            // trim trailing blank lines:\r\n            list_str = list_str.replace(/\\n{2,}$/, "\\n");\r\n\r\n            // attacklab: add sentinel to emulate \\z\r\n            list_str += "~0";\r\n\r\n            // In the original attacklab showdown, list_type was not given to this function, and anything\r\n            // that matched /[*+-]|\\d+[.]/ would just create the next <li>, causing this mismatch:\r\n            //\r\n            //  Markdown          rendered by WMD        rendered by MarkdownSharp\r\n            //  ------------------------------------------------------------------\r\n            //  1. first          1. first               1. first\r\n            //  2. second         2. second              2. second\r\n            //  - third           3. third                   * third\r\n            //\r\n            // We changed this to behave identical to MarkdownSharp. This is the constructed RegEx,\r\n            // with {MARKER} being one of \\d+[.] or [*+-], depending on list_type:\r\n        \r\n            /*\r\n            list_str = list_str.replace(/\r\n                (^[ \\t]*)                       // leading whitespace = $1\r\n                ({MARKER}) [ \\t]+               // list marker = $2\r\n                ([^\\r]+?                        // list item text   = $3\r\n                    (\\n+)\r\n                )\r\n                (?=\r\n                    (~0 | \\2 ({MARKER}) [ \\t]+)\r\n                )\r\n            /gm, function(){...});\r\n            */\r\n\r\n            var marker = _listItemMarkers[list_type];\r\n            var re = new RegExp("(^[ \\\\t]*)(" + marker + ")[ \\\\t]+([^\\\\r]+?(\\\\n+))(?=(~0|\\\\1(" + marker + ")[ \\\\t]+))", "gm");\r\n            var last_item_had_a_double_newline = false;\r\n            list_str = list_str.replace(re,\r\n                function (wholeMatch, m1, m2, m3) {\r\n                    var item = m3;\r\n                    var leading_space = m1;\r\n                    var ends_with_double_newline = /\\n\\n$/.test(item);\r\n                    var contains_double_newline = ends_with_double_newline || item.search(/\\n{2,}/) > -1;\r\n\r\n                    if (contains_double_newline || last_item_had_a_double_newline) {\r\n                        item = _RunBlockGamut(_Outdent(item), /* doNotUnhash = */true);\r\n                    }\r\n                    else {\r\n                        // Recursion for sub-lists:\r\n                        item = _DoLists(_Outdent(item));\r\n                        item = item.replace(/\\n$/, ""); // chomp(item)\r\n                        item = _RunSpanGamut(item);\r\n                    }\r\n                    last_item_had_a_double_newline = ends_with_double_newline;\r\n                    return "<li>" + item + "</li>\\n";\r\n                }\r\n            );\r\n\r\n            // attacklab: strip sentinel\r\n            list_str = list_str.replace(/~0/g, "");\r\n\r\n            g_list_level--;\r\n            return list_str;\r\n        }\r\n\r\n        function _DoCodeBlocks(text) {\r\n            //\r\n            //  Process Markdown `<pre><code>` blocks.\r\n            //  \r\n\r\n            /*\r\n            text = text.replace(/\r\n                (?:\\n\\n|^)\r\n                (                               // $1 = the code block -- one or more lines, starting with a space/tab\r\n                    (?:\r\n                        (?:[ ]{4}|\\t)           // Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width\r\n                        .*\\n+\r\n                    )+\r\n                )\r\n                (\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))    // attacklab: g_tab_width\r\n            /g ,function(){...});\r\n            */\r\n\r\n            // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\r\n            text += "~0";\r\n\r\n            text = text.replace(/(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g,\r\n                function (wholeMatch, m1, m2) {\r\n                    var codeblock = m1;\r\n                    var nextChar = m2;\r\n\r\n                    codeblock = _EncodeCode(_Outdent(codeblock));\r\n                    codeblock = _Detab(codeblock);\r\n                    codeblock = codeblock.replace(/^\\n+/g, ""); // trim leading newlines\r\n                    codeblock = codeblock.replace(/\\n+$/g, ""); // trim trailing whitespace\r\n\r\n                    codeblock = "<pre><code>" + codeblock + "\\n</code></pre>";\r\n\r\n                    return "\\n\\n" + codeblock + "\\n\\n" + nextChar;\r\n                }\r\n            );\r\n\r\n            // attacklab: strip sentinel\r\n            text = text.replace(/~0/, "");\r\n\r\n            return text;\r\n        }\r\n\r\n        function hashBlock(text) {\r\n            text = text.replace(/(^\\n+|\\n+$)/g, "");\r\n            return "\\n\\n~K" + (g_html_blocks.push(text) - 1) + "K\\n\\n";\r\n        }\r\n\r\n        function _DoCodeSpans(text) {\r\n            //\r\n            // * Backtick quotes are used for <code></code> spans.\r\n            // \r\n            // * You can use multiple backticks as the delimiters if you want to\r\n            //   include literal backticks in the code span. So, this input:\r\n            //     \r\n            //      Just type ``foo `bar` baz`` at the prompt.\r\n            //     \r\n            //   Will translate to:\r\n            //     \r\n            //      <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\r\n            //     \r\n            //   There\'s no arbitrary limit to the number of backticks you\r\n            //   can use as delimters. If you need three consecutive backticks\r\n            //   in your code, use four for delimiters, etc.\r\n            //\r\n            // * You can use spaces to get literal backticks at the edges:\r\n            //     \r\n            //      ... type `` `bar` `` ...\r\n            //     \r\n            //   Turns to:\r\n            //     \r\n            //      ... type <code>`bar`</code> ...\r\n            //\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (^|[^\\\\])       // Character before opening ` can\'t be a backslash\r\n                (`+)            // $2 = Opening run of `\r\n                (               // $3 = The code block\r\n                    [^\\r]*?\r\n                    [^`]        // attacklab: work around lack of lookbehind\r\n                )\r\n                \\2              // Matching closer\r\n                (?!`)\r\n            /gm, function(){...});\r\n            */\r\n\r\n            text = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\r\n                function (wholeMatch, m1, m2, m3, m4) {\r\n                    var c = m3;\r\n                    c = c.replace(/^([ \\t]*)/g, ""); // leading whitespace\r\n                    c = c.replace(/[ \\t]*$/g, ""); // trailing whitespace\r\n                    c = _EncodeCode(c);\r\n                    c = c.replace(/:\\/\\//g, "~P"); // to prevent auto-linking. Not necessary in code *blocks*, but in code spans. Will be converted back after the auto-linker runs.\r\n                    return m1 + "<code>" + c + "</code>";\r\n                }\r\n            );\r\n\r\n            return text;\r\n        }\r\n\r\n        function _EncodeCode(text) {\r\n            //\r\n            // Encode/escape certain characters inside Markdown code runs.\r\n            // The point is that in code, these characters are literals,\r\n            // and lose their special Markdown meanings.\r\n            //\r\n            // Encode all ampersands; HTML entities are not\r\n            // entities within a Markdown code span.\r\n            text = text.replace(/&/g, "&amp;");\r\n\r\n            // Do the angle bracket song and dance:\r\n            text = text.replace(/</g, "&lt;");\r\n            text = text.replace(/>/g, "&gt;");\r\n\r\n            // Now, escape characters that are magic in Markdown:\r\n            text = escapeCharacters(text, "\\*_{}[]\\\\", false);\r\n\r\n            // jj the line above breaks this:\r\n            //---\r\n\r\n            //* Item\r\n\r\n            //   1. Subitem\r\n\r\n            //            special char: *\r\n            //---\r\n\r\n            return text;\r\n        }\r\n\r\n        function _DoItalicsAndBold(text) {\r\n\r\n            // <strong> must go first:\r\n            text = text.replace(/([\\W_]|^)(\\*\\*|__)(?=\\S)([^\\r]*?\\S[\\*_]*)\\2([\\W_]|$)/g,\r\n            "$1<strong>$3</strong>$4");\r\n\r\n            text = text.replace(/([\\W_]|^)(\\*|_)(?=\\S)([^\\r\\*_]*?\\S)\\2([\\W_]|$)/g,\r\n            "$1<em>$3</em>$4");\r\n\r\n            return text;\r\n        }\r\n\r\n        function _DoBlockQuotes(text) {\r\n\r\n            /*\r\n            text = text.replace(/\r\n                (                           // Wrap whole match in $1\r\n                    (\r\n                        ^[ \\t]*>[ \\t]?      // \'>\' at the start of a line\r\n                        .+\\n                // rest of the first line\r\n                        (.+\\n)*             // subsequent consecutive lines\r\n                        \\n*                 // blanks\r\n                    )+\r\n                )\r\n            /gm, function(){...});\r\n            */\r\n\r\n            text = text.replace(/((^[ \\t]*>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm,\r\n                function (wholeMatch, m1) {\r\n                    var bq = m1;\r\n\r\n                    // attacklab: hack around Konqueror 3.5.4 bug:\r\n                    // "----------bug".replace(/^-/g,"") == "bug"\r\n\r\n                    bq = bq.replace(/^[ \\t]*>[ \\t]?/gm, "~0"); // trim one level of quoting\r\n\r\n                    // attacklab: clean up hack\r\n                    bq = bq.replace(/~0/g, "");\r\n\r\n                    bq = bq.replace(/^[ \\t]+$/gm, "");     // trim whitespace-only lines\r\n                    bq = _RunBlockGamut(bq);             // recurse\r\n\r\n                    bq = bq.replace(/(^|\\n)/g, "$1  ");\r\n                    // These leading spaces screw with <pre> content, so we need to fix that:\r\n                    bq = bq.replace(\r\n                            /(\\s*<pre>[^\\r]+?<\\/pre>)/gm,\r\n                        function (wholeMatch, m1) {\r\n                            var pre = m1;\r\n                            // attacklab: hack around Konqueror 3.5.4 bug:\r\n                            pre = pre.replace(/^  /mg, "~0");\r\n                            pre = pre.replace(/~0/g, "");\r\n                            return pre;\r\n                        });\r\n\r\n                    return hashBlock("<blockquote>\\n" + bq + "\\n</blockquote>");\r\n                }\r\n            );\r\n            return text;\r\n        }\r\n\r\n        function _FormParagraphs(text, doNotUnhash) {\r\n            //\r\n            //  Params:\r\n            //    $text - string to process with html <p> tags\r\n            //\r\n\r\n            // Strip leading and trailing lines:\r\n            text = text.replace(/^\\n+/g, "");\r\n            text = text.replace(/\\n+$/g, "");\r\n\r\n            var grafs = text.split(/\\n{2,}/g);\r\n            var grafsOut = [];\r\n            \r\n            var markerRe = /~K(\\d+)K/;\r\n\r\n            //\r\n            // Wrap <p> tags.\r\n            //\r\n            var end = grafs.length;\r\n            for (var i = 0; i < end; i++) {\r\n                var str = grafs[i];\r\n\r\n                // if this is an HTML marker, copy it\r\n                if (markerRe.test(str)) {\r\n                    grafsOut.push(str);\r\n                }\r\n                else if (/\\S/.test(str)) {\r\n                    str = _RunSpanGamut(str);\r\n                    str = str.replace(/^([ \\t]*)/g, "<p>");\r\n                    str += "</p>"\r\n                    grafsOut.push(str);\r\n                }\r\n\r\n            }\r\n            //\r\n            // Unhashify HTML blocks\r\n            //\r\n            if (!doNotUnhash) {\r\n                end = grafsOut.length;\r\n                for (var i = 0; i < end; i++) {\r\n                    var foundAny = true;\r\n                    while (foundAny) { // we may need several runs, since the data may be nested\r\n                        foundAny = false;\r\n                        grafsOut[i] = grafsOut[i].replace(/~K(\\d+)K/g, function (wholeMatch, id) {\r\n                            foundAny = true;\r\n                            return g_html_blocks[id];\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            return grafsOut.join("\\n\\n");\r\n        }\r\n\r\n        function _EncodeAmpsAndAngles(text) {\r\n            // Smart processing for ampersands and angle brackets that need to be encoded.\r\n\r\n            // Ampersand-encoding based entirely on Nat Irons\'s Amputator MT plugin:\r\n            //   http://bumppo.net/projects/amputator/\r\n            text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g, "&amp;");\r\n\r\n            // Encode naked <\'s\r\n            text = text.replace(/<(?![a-z\\/?!]|~D)/gi, "&lt;");\r\n\r\n            return text;\r\n        }\r\n\r\n        function _EncodeBackslashEscapes(text) {\r\n            //\r\n            //   Parameter:  String.\r\n            //   Returns:    The string, with after processing the following backslash\r\n            //               escape sequences.\r\n            //\r\n\r\n            // attacklab: The polite way to do this is with the new\r\n            // escapeCharacters() function:\r\n            //\r\n            //     text = escapeCharacters(text,"\\\\",true);\r\n            //     text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);\r\n            //\r\n            // ...but we\'re sidestepping its use of the (slow) RegExp constructor\r\n            // as an optimization for Firefox.  This function gets called a LOT.\r\n\r\n            text = text.replace(/\\\\(\\\\)/g, escapeCharacters_callback);\r\n            text = text.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g, escapeCharacters_callback);\r\n            return text;\r\n        }\r\n        \r\n        function handleTrailingParens(wholeMatch, lookbehind, protocol, link) {\r\n            if (lookbehind)\r\n                return wholeMatch;\r\n            if (link.charAt(link.length - 1) !== ")")\r\n                return "<" + protocol + link + ">";\r\n            var parens = link.match(/[()]/g);\r\n            var level = 0;\r\n            for (var i = 0; i < parens.length; i++) {\r\n                if (parens[i] === "(") {\r\n                    if (level <= 0)\r\n                        level = 1;\r\n                    else\r\n                        level++;\r\n                }\r\n                else {\r\n                    level--;\r\n                }\r\n            }\r\n            var tail = "";\r\n            if (level < 0) {\r\n                var re = new RegExp("\\\\){1," + (-level) + "}$");\r\n                link = link.replace(re, function (trailingParens) {\r\n                    tail = trailingParens;\r\n                    return "";\r\n                });\r\n            }\r\n            \r\n            return "<" + protocol + link + ">" + tail;\r\n        }\r\n\r\n        function _DoAutoLinks(text) {\r\n\r\n            // note that at this point, all other URL in the text are already hyperlinked as <a href=""></a>\r\n            // *except* for the <http://www.foo.com> case\r\n\r\n            // automatically add < and > around unadorned raw hyperlinks\r\n            // must be preceded by a non-word character (and not by =" or <) and followed by non-word/EOF character\r\n            // simulating the lookbehind in a consuming way is okay here, since a URL can neither and with a " nor\r\n            // with a <, so there is no risk of overlapping matches.\r\n            text = text.replace(/(="|<)?\\b(https?|ftp)(:\\/\\/[-A-Z0-9+&@#\\/%?=~_|\\[\\]\\(\\)!:,\\.;]*[-A-Z0-9+&@#\\/%=~_|\\[\\])])(?=$|\\W)/gi, handleTrailingParens);\r\n\r\n            //  autolink anything like <http://example.com>\r\n            \r\n            var replacer = function (wholematch, m1) { return "<a href=\\"" + m1 + "\\">" + pluginHooks.plainLinkText(m1) + "</a>"; }\r\n            text = text.replace(/<((https?|ftp):[^\'">\\s]+)>/gi, replacer);\r\n\r\n            // Email addresses: <address@domain.foo>\r\n            /*\r\n            text = text.replace(/\r\n                <\r\n                (?:mailto:)?\r\n                (\r\n                    [-.\\w]+\r\n                    \\@\r\n                    [-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+\r\n                )\r\n                >\r\n            /gi, _DoAutoLinks_callback());\r\n            */\r\n\r\n            /* disabling email autolinking, since we don\'t do that on the server, either\r\n            text = text.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\r\n                function(wholeMatch,m1) {\r\n                    return _EncodeEmailAddress( _UnescapeSpecialChars(m1) );\r\n                }\r\n            );\r\n            */\r\n            return text;\r\n        }\r\n\r\n        function _UnescapeSpecialChars(text) {\r\n            //\r\n            // Swap back in all the special characters we\'ve hidden.\r\n            //\r\n            text = text.replace(/~E(\\d+)E/g,\r\n                function (wholeMatch, m1) {\r\n                    var charCodeToReplace = parseInt(m1);\r\n                    return String.fromCharCode(charCodeToReplace);\r\n                }\r\n            );\r\n            return text;\r\n        }\r\n\r\n        function _Outdent(text) {\r\n            //\r\n            // Remove one level of line-leading tabs or spaces\r\n            //\r\n\r\n            // attacklab: hack around Konqueror 3.5.4 bug:\r\n            // "----------bug".replace(/^-/g,"") == "bug"\r\n\r\n            text = text.replace(/^(\\t|[ ]{1,4})/gm, "~0"); // attacklab: g_tab_width\r\n\r\n            // attacklab: clean up hack\r\n            text = text.replace(/~0/g, "")\r\n\r\n            return text;\r\n        }\r\n\r\n        function _Detab(text) {\r\n            if (!/\\t/.test(text))\r\n                return text;\r\n\r\n            var spaces = ["    ", "   ", "  ", " "],\r\n            skew = 0,\r\n            v;\r\n\r\n            return text.replace(/[\\n\\t]/g, function (match, offset) {\r\n                if (match === "\\n") {\r\n                    skew = offset + 1;\r\n                    return match;\r\n                }\r\n                v = (offset - skew) % 4;\r\n                skew = offset + 1;\r\n                return spaces[v];\r\n            });\r\n        }\r\n\r\n        //\r\n        //  attacklab: Utility functions\r\n        //\r\n\r\n        var _problemUrlChars = /(?:["\'*()[\\]:]|~D)/g;\r\n\r\n        // hex-encodes some unusual "problem" chars in URLs to avoid URL detection problems \r\n        function encodeProblemUrlChars(url) {\r\n            if (!url)\r\n                return "";\r\n\r\n            var len = url.length;\r\n\r\n            return url.replace(_problemUrlChars, function (match, offset) {\r\n                if (match == "~D") // escape for dollar\r\n                    return "%24";\r\n                if (match == ":") {\r\n                    if (offset == len - 1 || /[0-9\\/]/.test(url.charAt(offset + 1)))\r\n                        return ":"\r\n                }\r\n                return "%" + match.charCodeAt(0).toString(16);\r\n            });\r\n        }\r\n\r\n\r\n        function escapeCharacters(text, charsToEscape, afterBackslash) {\r\n            // First we have to escape the escape characters so that\r\n            // we can build a character class out of them\r\n            var regexString = "([" + charsToEscape.replace(/([\\[\\]\\\\])/g, "\\\\$1") + "])";\r\n\r\n            if (afterBackslash) {\r\n                regexString = "\\\\\\\\" + regexString;\r\n            }\r\n\r\n            var regex = new RegExp(regexString, "g");\r\n            text = text.replace(regex, escapeCharacters_callback);\r\n\r\n            return text;\r\n        }\r\n\r\n\r\n        function escapeCharacters_callback(wholeMatch, m1) {\r\n            var charCodeToEscape = m1.charCodeAt(0);\r\n            return "~E" + charCodeToEscape + "E";\r\n        }\r\n\r\n    }; // end of the Markdown.Converter constructor\r\n\r\n})();\r\n'},180:function(t,n,e){e(1)(e(181))},181:function(t,n){t.exports='(function () {\n    var output, Converter;\n    if (typeof exports === "object" && typeof require === "function") { // we\'re in a CommonJS (e.g. Node.js) module\n        output = exports;\n        Converter = require("./Markdown.Converter").Converter;\n    } else {\n        output = window.Markdown;\n        Converter = output.Converter;\n    }\n        \n    output.getSanitizingConverter = function () {\n        var converter = new Converter();\n        converter.hooks.chain("postConversion", sanitizeHtml);\n        converter.hooks.chain("postConversion", balanceTags);\n        return converter;\n    }\n\n    function sanitizeHtml(html) {\n        return html.replace(/<[^>]*>?/gi, sanitizeTag);\n    }\n\n    // (tags that can be opened/closed) | (tags that stand alone)\n    var basic_tag_whitelist = /^(<\\/?(b|blockquote|code|del|dd|dl|dt|em|h1|h2|h3|i|kbd|li|ol|p|pre|s|sup|sub|strong|strike|ul)>|<(br|hr)\\s?\\/?>)$/i;\n    // <a href="url..." optional title>|</a>\n    var a_white = /^(<a\\shref="((https?|ftp):\\/\\/|\\/)[-A-Za-z0-9+&@#\\/%?=~_|!:,.;\\(\\)]+"(\\stitle="[^"<>]+")?\\s?>|<\\/a>)$/i;\n\n    // <img src="url..." optional width  optional height  optional alt  optional title\n    var img_white = /^(<img\\ssrc="(https?:\\/\\/|\\/)[-A-Za-z0-9+&@#\\/%?=~_|!:,.;\\(\\)]+"(\\swidth="\\d{1,3}")?(\\sheight="\\d{1,3}")?(\\salt="[^"<>]*")?(\\stitle="[^"<>]*")?\\s?\\/?>)$/i;\n\n    function sanitizeTag(tag) {\n        if (tag.match(basic_tag_whitelist) || tag.match(a_white) || tag.match(img_white))\n            return tag;\n        else\n            return "";\n    }\n\n    /// <summary>\n    /// attempt to balance HTML tags in the html string\n    /// by removing any unmatched opening or closing tags\n    /// IMPORTANT: we *assume* HTML has *already* been \n    /// sanitized and is safe/sane before balancing!\n    /// \n    /// adapted from CODESNIPPET: A8591DBA-D1D3-11DE-947C-BA5556D89593\n    /// </summary>\n    function balanceTags(html) {\n\n        if (html == "")\n            return "";\n\n        var re = /<\\/?\\w+[^>]*(\\s|$|>)/g;\n        // convert everything to lower case; this makes\n        // our case insensitive comparisons easier\n        var tags = html.toLowerCase().match(re);\n\n        // no HTML tags present? nothing to do; exit now\n        var tagcount = (tags || []).length;\n        if (tagcount == 0)\n            return html;\n\n        var tagname, tag;\n        var ignoredtags = "<p><img><br><li><hr>";\n        var match;\n        var tagpaired = [];\n        var tagremove = [];\n        var needsRemoval = false;\n\n        // loop through matched tags in forward order\n        for (var ctag = 0; ctag < tagcount; ctag++) {\n            tagname = tags[ctag].replace(/<\\/?(\\w+).*/, "$1");\n            // skip any already paired tags\n            // and skip tags in our ignore list; assume they\'re self-closed\n            if (tagpaired[ctag] || ignoredtags.search("<" + tagname + ">") > -1)\n                continue;\n\n            tag = tags[ctag];\n            match = -1;\n\n            if (!/^<\\//.test(tag)) {\n                // this is an opening tag\n                // search forwards (next tags), look for closing tags\n                for (var ntag = ctag + 1; ntag < tagcount; ntag++) {\n                    if (!tagpaired[ntag] && tags[ntag] == "</" + tagname + ">") {\n                        match = ntag;\n                        break;\n                    }\n                }\n            }\n\n            if (match == -1)\n                needsRemoval = tagremove[ctag] = true; // mark for removal\n            else\n                tagpaired[match] = true; // mark paired\n        }\n\n        if (!needsRemoval)\n            return html;\n\n        // delete all orphaned tags from the string\n\n        var ctag = 0;\n        html = html.replace(re, function (match) {\n            var res = tagremove[ctag] ? "" : match;\n            ctag++;\n            return res;\n        });\n        return html;\n    }\n})();\n'},182:function(t,n,e){e(1)(e(183))},183:function(t,n){t.exports='/**\n * Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.0\n * Build date: 10 May 2015\n */\n\n(function(factory, root) {\n    if (typeof define == "function" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else if (typeof module != "undefined" && typeof exports == "object") {\n        // Node/CommonJS style\n        module.exports = factory();\n    } else {\n        // No AMD or CommonJS support so we place Rangy in (probably) the global variable\n        root.rangy = factory();\n    }\n})(function() {\n\n    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";\n\n    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START\n    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.\n    var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",\n        "commonAncestorContainer"];\n\n    // Minimal set of methods required for DOM Level 2 Range compliance\n    var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",\n        "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",\n        "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];\n\n    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];\n\n    // Subset of TextRange\'s full set of methods that we\'re interested in\n    var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "moveToElementText", "parentElement", "select",\n        "setEndPoint", "getBoundingClientRect"];\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Trio of functions taken from Peter Michaux\'s article:\n    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n    function isHostMethod(o, p) {\n        var t = typeof o[p];\n        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";\n    }\n\n    function isHostObject(o, p) {\n        return !!(typeof o[p] == OBJECT && o[p]);\n    }\n\n    function isHostProperty(o, p) {\n        return typeof o[p] != UNDEFINED;\n    }\n\n    // Creates a convenience function to save verbose repeated calls to tests functions\n    function createMultiplePropertyTest(testFunc) {\n        return function(o, props) {\n            var i = props.length;\n            while (i--) {\n                if (!testFunc(o, props[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n    var areHostMethods = createMultiplePropertyTest(isHostMethod);\n    var areHostObjects = createMultiplePropertyTest(isHostObject);\n    var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n    function isTextRange(range) {\n        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n    }\n\n    function getBody(doc) {\n        return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];\n    }\n\n    var forEach = [].forEach ?\n        function(arr, func) {\n            arr.forEach(func);\n        } :\n        function(arr, func) {\n            for (var i = 0, len = arr.length; i < len; ++i) {\n                func(arr[i], i);\n            }\n        };\n\n    var modules = {};\n\n    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);\n\n    var util = {\n        isHostMethod: isHostMethod,\n        isHostObject: isHostObject,\n        isHostProperty: isHostProperty,\n        areHostMethods: areHostMethods,\n        areHostObjects: areHostObjects,\n        areHostProperties: areHostProperties,\n        isTextRange: isTextRange,\n        getBody: getBody,\n        forEach: forEach\n    };\n\n    var api = {\n        version: "1.3.0",\n        initialized: false,\n        isBrowser: isBrowser,\n        supported: true,\n        util: util,\n        features: {},\n        modules: modules,\n        config: {\n            alertOnFail: false,\n            alertOnWarn: false,\n            preferTextRange: false,\n            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize\n        }\n    };\n\n    function consoleLog(msg) {\n        if (typeof console != UNDEFINED && isHostMethod(console, "log")) {\n            console.log(msg);\n        }\n    }\n\n    function alertOrLog(msg, shouldAlert) {\n        if (isBrowser && shouldAlert) {\n            alert(msg);\n        } else  {\n            consoleLog(msg);\n        }\n    }\n\n    function fail(reason) {\n        api.initialized = true;\n        api.supported = false;\n        alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);\n    }\n\n    api.fail = fail;\n\n    function warn(msg) {\n        alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);\n    }\n\n    api.warn = warn;\n\n    // Add utility extend() method\n    var extend;\n    if ({}.hasOwnProperty) {\n        util.extend = extend = function(obj, props, deep) {\n            var o, p;\n            for (var i in props) {\n                if (props.hasOwnProperty(i)) {\n                    o = obj[i];\n                    p = props[i];\n                    if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {\n                        extend(o, p, true);\n                    }\n                    obj[i] = p;\n                }\n            }\n            // Special case for toString, which does not show up in for...in loops in IE <= 8\n            if (props.hasOwnProperty("toString")) {\n                obj.toString = props.toString;\n            }\n            return obj;\n        };\n\n        util.createOptions = function(optionsParam, defaults) {\n            var options = {};\n            extend(options, defaults);\n            if (optionsParam) {\n                extend(options, optionsParam);\n            }\n            return options;\n        };\n    } else {\n        fail("hasOwnProperty not supported");\n    }\n\n    // Test whether we\'re in a browser and bail out if not\n    if (!isBrowser) {\n        fail("Rangy can only run in a browser");\n    }\n\n    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not\n    (function() {\n        var toArray;\n\n        if (isBrowser) {\n            var el = document.createElement("div");\n            el.appendChild(document.createElement("span"));\n            var slice = [].slice;\n            try {\n                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {\n                    toArray = function(arrayLike) {\n                        return slice.call(arrayLike, 0);\n                    };\n                }\n            } catch (e) {}\n        }\n\n        if (!toArray) {\n            toArray = function(arrayLike) {\n                var arr = [];\n                for (var i = 0, len = arrayLike.length; i < len; ++i) {\n                    arr[i] = arrayLike[i];\n                }\n                return arr;\n            };\n        }\n\n        util.toArray = toArray;\n    })();\n\n    // Very simple event handler wrapper function that doesn\'t attempt to solve issues such as "this" handling or\n    // normalization of event properties\n    var addListener;\n    if (isBrowser) {\n        if (isHostMethod(document, "addEventListener")) {\n            addListener = function(obj, eventType, listener) {\n                obj.addEventListener(eventType, listener, false);\n            };\n        } else if (isHostMethod(document, "attachEvent")) {\n            addListener = function(obj, eventType, listener) {\n                obj.attachEvent("on" + eventType, listener);\n            };\n        } else {\n            fail("Document does not have required addEventListener or attachEvent method");\n        }\n\n        util.addListener = addListener;\n    }\n\n    var initListeners = [];\n\n    function getErrorDesc(ex) {\n        return ex.message || ex.description || String(ex);\n    }\n\n    // Initialization\n    function init() {\n        if (!isBrowser || api.initialized) {\n            return;\n        }\n        var testRange;\n        var implementsDomRange = false, implementsTextRange = false;\n\n        // First, perform basic feature tests\n\n        if (isHostMethod(document, "createRange")) {\n            testRange = document.createRange();\n            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n                implementsDomRange = true;\n            }\n        }\n\n        var body = getBody(document);\n        if (!body || body.nodeName.toLowerCase() != "body") {\n            fail("No body element found");\n            return;\n        }\n\n        if (body && isHostMethod(body, "createTextRange")) {\n            testRange = body.createTextRange();\n            if (isTextRange(testRange)) {\n                implementsTextRange = true;\n            }\n        }\n\n        if (!implementsDomRange && !implementsTextRange) {\n            fail("Neither Range nor TextRange are available");\n            return;\n        }\n\n        api.initialized = true;\n        api.features = {\n            implementsDomRange: implementsDomRange,\n            implementsTextRange: implementsTextRange\n        };\n\n        // Initialize modules\n        var module, errorMessage;\n        for (var moduleName in modules) {\n            if ( (module = modules[moduleName]) instanceof Module ) {\n                module.init(module, api);\n            }\n        }\n\n        // Call init listeners\n        for (var i = 0, len = initListeners.length; i < len; ++i) {\n            try {\n                initListeners[i](api);\n            } catch (ex) {\n                errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);\n                consoleLog(errorMessage);\n            }\n        }\n    }\n\n    function deprecationNotice(deprecated, replacement, module) {\n        if (module) {\n            deprecated += " in module " + module.name;\n        }\n        api.warn("DEPRECATED: " + deprecated + " is deprecated. Please use " +\n        replacement + " instead.");\n    }\n\n    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {\n        owner[deprecated] = function() {\n            deprecationNotice(deprecated, replacement, module);\n            return owner[replacement].apply(owner, util.toArray(arguments));\n        };\n    }\n\n    util.deprecationNotice = deprecationNotice;\n    util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;\n\n    // Allow external scripts to initialize this library in case it\'s loaded after the document has loaded\n    api.init = init;\n\n    // Execute listener immediately if already initialized\n    api.addInitListener = function(listener) {\n        if (api.initialized) {\n            listener(api);\n        } else {\n            initListeners.push(listener);\n        }\n    };\n\n    var shimListeners = [];\n\n    api.addShimListener = function(listener) {\n        shimListeners.push(listener);\n    };\n\n    function shim(win) {\n        win = win || window;\n        init();\n\n        // Notify listeners\n        for (var i = 0, len = shimListeners.length; i < len; ++i) {\n            shimListeners[i](win);\n        }\n    }\n\n    if (isBrowser) {\n        api.shim = api.createMissingNativeApi = shim;\n        createAliasForDeprecatedMethod(api, "createMissingNativeApi", "shim");\n    }\n\n    function Module(name, dependencies, initializer) {\n        this.name = name;\n        this.dependencies = dependencies;\n        this.initialized = false;\n        this.supported = false;\n        this.initializer = initializer;\n    }\n\n    Module.prototype = {\n        init: function() {\n            var requiredModuleNames = this.dependencies || [];\n            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {\n                moduleName = requiredModuleNames[i];\n\n                requiredModule = modules[moduleName];\n                if (!requiredModule || !(requiredModule instanceof Module)) {\n                    throw new Error("required module \'" + moduleName + "\' not found");\n                }\n\n                requiredModule.init();\n\n                if (!requiredModule.supported) {\n                    throw new Error("required module \'" + moduleName + "\' not supported");\n                }\n            }\n\n            // Now run initializer\n            this.initializer(this);\n        },\n\n        fail: function(reason) {\n            this.initialized = true;\n            this.supported = false;\n            throw new Error(reason);\n        },\n\n        warn: function(msg) {\n            api.warn("Module " + this.name + ": " + msg);\n        },\n\n        deprecationNotice: function(deprecated, replacement) {\n            api.warn("DEPRECATED: " + deprecated + " in module " + this.name + " is deprecated. Please use " +\n                replacement + " instead");\n        },\n\n        createError: function(msg) {\n            return new Error("Error in Rangy " + this.name + " module: " + msg);\n        }\n    };\n\n    function createModule(name, dependencies, initFunc) {\n        var newModule = new Module(name, dependencies, function(module) {\n            if (!module.initialized) {\n                module.initialized = true;\n                try {\n                    initFunc(api, module);\n                    module.supported = true;\n                } catch (ex) {\n                    var errorMessage = "Module \'" + name + "\' failed to load: " + getErrorDesc(ex);\n                    consoleLog(errorMessage);\n                    if (ex.stack) {\n                        consoleLog(ex.stack);\n                    }\n                }\n            }\n        });\n        modules[name] = newModule;\n        return newModule;\n    }\n\n    api.createModule = function(name) {\n        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)\n        var initFunc, dependencies;\n        if (arguments.length == 2) {\n            initFunc = arguments[1];\n            dependencies = [];\n        } else {\n            initFunc = arguments[2];\n            dependencies = arguments[1];\n        }\n\n        var module = createModule(name, dependencies, initFunc);\n\n        // Initialize the module immediately if the core is already initialized\n        if (api.initialized && api.supported) {\n            module.init();\n        }\n    };\n\n    api.createCoreModule = function(name, dependencies, initFunc) {\n        createModule(name, dependencies, initFunc);\n    };\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately\n\n    function RangePrototype() {}\n    api.RangePrototype = RangePrototype;\n    api.rangePrototype = new RangePrototype();\n\n    function SelectionPrototype() {}\n    api.selectionPrototype = new SelectionPrototype();\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // DOM utility methods used by Rangy\n    api.createCoreModule("DomUtil", [], function(api, module) {\n        var UNDEF = "undefined";\n        var util = api.util;\n        var getBody = util.getBody;\n\n        // Perform feature tests\n        if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {\n            module.fail("document missing a Node creation method");\n        }\n\n        if (!util.isHostMethod(document, "getElementsByTagName")) {\n            module.fail("document missing getElementsByTagName method");\n        }\n\n        var el = document.createElement("div");\n        if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||\n                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {\n            module.fail("Incomplete Element implementation");\n        }\n\n        // innerHTML is required for Range\'s createContextualFragment method\n        if (!util.isHostProperty(el, "innerHTML")) {\n            module.fail("Element is missing innerHTML property");\n        }\n\n        var textNode = document.createTextNode("test");\n        if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||\n                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) ||\n                !util.areHostProperties(textNode, ["data"]))) {\n            module.fail("Incomplete Text Node implementation");\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven\'t been\n        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n        // contains just the document as a single element and the value searched for is the document.\n        var arrayContains = /*Array.prototype.indexOf ?\n            function(arr, val) {\n                return arr.indexOf(val) > -1;\n            }:*/\n\n            function(arr, val) {\n                var i = arr.length;\n                while (i--) {\n                    if (arr[i] === val) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n        function isHtmlNamespace(node) {\n            var ns;\n            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");\n        }\n\n        function parentElement(node) {\n            var parent = node.parentNode;\n            return (parent.nodeType == 1) ? parent : null;\n        }\n\n        function getNodeIndex(node) {\n            var i = 0;\n            while( (node = node.previousSibling) ) {\n                ++i;\n            }\n            return i;\n        }\n\n        function getNodeLength(node) {\n            switch (node.nodeType) {\n                case 7:\n                case 10:\n                    return 0;\n                case 3:\n                case 8:\n                    return node.length;\n                default:\n                    return node.childNodes.length;\n            }\n        }\n\n        function getCommonAncestor(node1, node2) {\n            var ancestors = [], n;\n            for (n = node1; n; n = n.parentNode) {\n                ancestors.push(n);\n            }\n\n            for (n = node2; n; n = n.parentNode) {\n                if (arrayContains(ancestors, n)) {\n                    return n;\n                }\n            }\n\n            return null;\n        }\n\n        function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n            var n = selfIsAncestor ? descendant : descendant.parentNode;\n            while (n) {\n                if (n === ancestor) {\n                    return true;\n                } else {\n                    n = n.parentNode;\n                }\n            }\n            return false;\n        }\n\n        function isOrIsAncestorOf(ancestor, descendant) {\n            return isAncestorOf(ancestor, descendant, true);\n        }\n\n        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n            var p, n = selfIsAncestor ? node : node.parentNode;\n            while (n) {\n                p = n.parentNode;\n                if (p === ancestor) {\n                    return n;\n                }\n                n = p;\n            }\n            return null;\n        }\n\n        function isCharacterDataNode(node) {\n            var t = node.nodeType;\n            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment\n        }\n\n        function isTextOrCommentNode(node) {\n            if (!node) {\n                return false;\n            }\n            var t = node.nodeType;\n            return t == 3 || t == 8 ; // Text or Comment\n        }\n\n        function insertAfter(node, precedingNode) {\n            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;\n            if (nextNode) {\n                parent.insertBefore(node, nextNode);\n            } else {\n                parent.appendChild(node);\n            }\n            return node;\n        }\n\n        // Note that we cannot use splitText() because it is bugridden in IE 9.\n        function splitDataNode(node, index, positionsToPreserve) {\n            var newNode = node.cloneNode(false);\n            newNode.deleteData(0, index);\n            node.deleteData(index, node.length - index);\n            insertAfter(newNode, node);\n\n            // Preserve positions\n            if (positionsToPreserve) {\n                for (var i = 0, position; position = positionsToPreserve[i++]; ) {\n                    // Handle case where position was inside the portion of node after the split point\n                    if (position.node == node && position.offset > index) {\n                        position.node = newNode;\n                        position.offset -= index;\n                    }\n                    // Handle the case where the position is a node offset within node\'s parent\n                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {\n                        ++position.offset;\n                    }\n                }\n            }\n            return newNode;\n        }\n\n        function getDocument(node) {\n            if (node.nodeType == 9) {\n                return node;\n            } else if (typeof node.ownerDocument != UNDEF) {\n                return node.ownerDocument;\n            } else if (typeof node.document != UNDEF) {\n                return node.document;\n            } else if (node.parentNode) {\n                return getDocument(node.parentNode);\n            } else {\n                throw module.createError("getDocument: no document found for node");\n            }\n        }\n\n        function getWindow(node) {\n            var doc = getDocument(node);\n            if (typeof doc.defaultView != UNDEF) {\n                return doc.defaultView;\n            } else if (typeof doc.parentWindow != UNDEF) {\n                return doc.parentWindow;\n            } else {\n                throw module.createError("Cannot get a window object for node");\n            }\n        }\n\n        function getIframeDocument(iframeEl) {\n            if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument;\n            } else if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow.document;\n            } else {\n                throw module.createError("getIframeDocument: No Document object found for iframe element");\n            }\n        }\n\n        function getIframeWindow(iframeEl) {\n            if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow;\n            } else if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument.defaultView;\n            } else {\n                throw module.createError("getIframeWindow: No Window object found for iframe element");\n            }\n        }\n\n        // This looks bad. Is it worth it?\n        function isWindow(obj) {\n            return obj && util.isHostMethod(obj, "setTimeout") && util.isHostObject(obj, "document");\n        }\n\n        function getContentDocument(obj, module, methodName) {\n            var doc;\n\n            if (!obj) {\n                doc = document;\n            }\n\n            // Test if a DOM node has been passed and obtain a document object for it if so\n            else if (util.isHostProperty(obj, "nodeType")) {\n                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe") ?\n                    getIframeDocument(obj) : getDocument(obj);\n            }\n\n            // Test if the doc parameter appears to be a Window object\n            else if (isWindow(obj)) {\n                doc = obj.document;\n            }\n\n            if (!doc) {\n                throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");\n            }\n\n            return doc;\n        }\n\n        function getRootContainer(node) {\n            var parent;\n            while ( (parent = node.parentNode) ) {\n                node = parent;\n            }\n            return node;\n        }\n\n        function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n            var nodeC, root, childA, childB, n;\n            if (nodeA == nodeB) {\n                // Case 1: nodes are the same\n                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {\n                // Case 2: node C (container B or an ancestor) is a child node of A\n                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {\n                // Case 3: node C (container A or an ancestor) is a child node of B\n                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;\n            } else {\n                root = getCommonAncestor(nodeA, nodeB);\n                if (!root) {\n                    throw new Error("comparePoints error: nodes have no common ancestor");\n                }\n\n                // Case 4: containers are siblings or descendants of siblings\n                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);\n                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);\n\n                if (childA === childB) {\n                    // This shouldn\'t be possible\n                    throw module.createError("comparePoints got to case 4 and childA and childB are the same!");\n                } else {\n                    n = root.firstChild;\n                    while (n) {\n                        if (n === childA) {\n                            return -1;\n                        } else if (n === childB) {\n                            return 1;\n                        }\n                        n = n.nextSibling;\n                    }\n                }\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test for IE\'s crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried\n        var crashyTextNodes = false;\n\n        function isBrokenNode(node) {\n            var n;\n            try {\n                n = node.parentNode;\n                return false;\n            } catch (e) {\n                return true;\n            }\n        }\n\n        (function() {\n            var el = document.createElement("b");\n            el.innerHTML = "1";\n            var textNode = el.firstChild;\n            el.innerHTML = "<br />";\n            crashyTextNodes = isBrokenNode(textNode);\n\n            api.features.crashyTextNodes = crashyTextNodes;\n        })();\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        function inspectNode(node) {\n            if (!node) {\n                return "[No node]";\n            }\n            if (crashyTextNodes && isBrokenNode(node)) {\n                return "[Broken node]";\n            }\n            if (isCharacterDataNode(node)) {\n                return \'"\' + node.data + \'"\';\n            }\n            if (node.nodeType == 1) {\n                var idAttr = node.id ? \' id="\' + node.id + \'"\' : "";\n                return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";\n            }\n            return node.nodeName;\n        }\n\n        function fragmentFromNodeChildren(node) {\n            var fragment = getDocument(node).createDocumentFragment(), child;\n            while ( (child = node.firstChild) ) {\n                fragment.appendChild(child);\n            }\n            return fragment;\n        }\n\n        var getComputedStyleProperty;\n        if (typeof window.getComputedStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return getWindow(el).getComputedStyle(el, null)[propName];\n            };\n        } else if (typeof document.documentElement.currentStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return el.currentStyle ? el.currentStyle[propName] : "";\n            };\n        } else {\n            module.fail("No means of obtaining computed style properties found");\n        }\n\n        function createTestElement(doc, html, contentEditable) {\n            var body = getBody(doc);\n            var el = doc.createElement("div");\n            el.contentEditable = "" + !!contentEditable;\n            if (html) {\n                el.innerHTML = html;\n            }\n\n            // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)\n            var bodyFirstChild = body.firstChild;\n            if (bodyFirstChild) {\n                body.insertBefore(el, bodyFirstChild);\n            } else {\n                body.appendChild(el);\n            }\n\n            return el;\n        }\n\n        function removeNode(node) {\n            return node.parentNode.removeChild(node);\n        }\n\n        function NodeIterator(root) {\n            this.root = root;\n            this._next = root;\n        }\n\n        NodeIterator.prototype = {\n            _current: null,\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                var n = this._current = this._next;\n                var child, next;\n                if (this._current) {\n                    child = n.firstChild;\n                    if (child) {\n                        this._next = child;\n                    } else {\n                        next = null;\n                        while ((n !== this.root) && !(next = n.nextSibling)) {\n                            n = n.parentNode;\n                        }\n                        this._next = next;\n                    }\n                }\n                return this._current;\n            },\n\n            detach: function() {\n                this._current = this._next = this.root = null;\n            }\n        };\n\n        function createIterator(root) {\n            return new NodeIterator(root);\n        }\n\n        function DomPosition(node, offset) {\n            this.node = node;\n            this.offset = offset;\n        }\n\n        DomPosition.prototype = {\n            equals: function(pos) {\n                return !!pos && this.node === pos.node && this.offset == pos.offset;\n            },\n\n            inspect: function() {\n                return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";\n            },\n\n            toString: function() {\n                return this.inspect();\n            }\n        };\n\n        function DOMException(codeName) {\n            this.code = this[codeName];\n            this.codeName = codeName;\n            this.message = "DOMException: " + this.codeName;\n        }\n\n        DOMException.prototype = {\n            INDEX_SIZE_ERR: 1,\n            HIERARCHY_REQUEST_ERR: 3,\n            WRONG_DOCUMENT_ERR: 4,\n            NO_MODIFICATION_ALLOWED_ERR: 7,\n            NOT_FOUND_ERR: 8,\n            NOT_SUPPORTED_ERR: 9,\n            INVALID_STATE_ERR: 11,\n            INVALID_NODE_TYPE_ERR: 24\n        };\n\n        DOMException.prototype.toString = function() {\n            return this.message;\n        };\n\n        api.dom = {\n            arrayContains: arrayContains,\n            isHtmlNamespace: isHtmlNamespace,\n            parentElement: parentElement,\n            getNodeIndex: getNodeIndex,\n            getNodeLength: getNodeLength,\n            getCommonAncestor: getCommonAncestor,\n            isAncestorOf: isAncestorOf,\n            isOrIsAncestorOf: isOrIsAncestorOf,\n            getClosestAncestorIn: getClosestAncestorIn,\n            isCharacterDataNode: isCharacterDataNode,\n            isTextOrCommentNode: isTextOrCommentNode,\n            insertAfter: insertAfter,\n            splitDataNode: splitDataNode,\n            getDocument: getDocument,\n            getWindow: getWindow,\n            getIframeWindow: getIframeWindow,\n            getIframeDocument: getIframeDocument,\n            getBody: getBody,\n            isWindow: isWindow,\n            getContentDocument: getContentDocument,\n            getRootContainer: getRootContainer,\n            comparePoints: comparePoints,\n            isBrokenNode: isBrokenNode,\n            inspectNode: inspectNode,\n            getComputedStyleProperty: getComputedStyleProperty,\n            createTestElement: createTestElement,\n            removeNode: removeNode,\n            fragmentFromNodeChildren: fragmentFromNodeChildren,\n            createIterator: createIterator,\n            DomPosition: DomPosition\n        };\n\n        api.DOMException = DOMException;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Pure JavaScript implementation of DOM Range\n    api.createCoreModule("DomRange", ["DomUtil"], function(api, module) {\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DOMException = api.DOMException;\n\n        var isCharacterDataNode = dom.isCharacterDataNode;\n        var getNodeIndex = dom.getNodeIndex;\n        var isOrIsAncestorOf = dom.isOrIsAncestorOf;\n        var getDocument = dom.getDocument;\n        var comparePoints = dom.comparePoints;\n        var splitDataNode = dom.splitDataNode;\n        var getClosestAncestorIn = dom.getClosestAncestorIn;\n        var getNodeLength = dom.getNodeLength;\n        var arrayContains = dom.arrayContains;\n        var getRootContainer = dom.getRootContainer;\n        var crashyTextNodes = api.features.crashyTextNodes;\n\n        var removeNode = dom.removeNode;\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Utility functions\n\n        function isNonTextPartiallySelected(node, range) {\n            return (node.nodeType != 3) &&\n                   (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));\n        }\n\n        function getRangeDocument(range) {\n            return range.document || getDocument(range.startContainer);\n        }\n\n        function getRangeRoot(range) {\n            return getRootContainer(range.startContainer);\n        }\n\n        function getBoundaryBeforeNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node));\n        }\n\n        function getBoundaryAfterNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);\n        }\n\n        function insertNodeAtPosition(node, n, o) {\n            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n            if (isCharacterDataNode(n)) {\n                if (o == n.length) {\n                    dom.insertAfter(node, n);\n                } else {\n                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));\n                }\n            } else if (o >= n.childNodes.length) {\n                n.appendChild(node);\n            } else {\n                n.insertBefore(node, n.childNodes[o]);\n            }\n            return firstNodeInserted;\n        }\n\n        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {\n            assertRangeValid(rangeA);\n            assertRangeValid(rangeB);\n\n            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {\n                throw new DOMException("WRONG_DOCUMENT_ERR");\n            }\n\n            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),\n                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);\n\n            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n        }\n\n        function cloneSubtree(iterator) {\n            var partiallySelected;\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n                partiallySelected = iterator.isPartiallySelectedSubtree();\n                node = node.cloneNode(!partiallySelected);\n                if (partiallySelected) {\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(cloneSubtree(subIterator));\n                    subIterator.detach();\n                }\n\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException("HIERARCHY_REQUEST_ERR");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function iterateSubtree(rangeIterator, func, iteratorState) {\n            var it, n;\n            iteratorState = iteratorState || { stop: false };\n            for (var node, subRangeIterator; node = rangeIterator.next(); ) {\n                if (rangeIterator.isPartiallySelectedSubtree()) {\n                    if (func(node) === false) {\n                        iteratorState.stop = true;\n                        return;\n                    } else {\n                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of\n                        // the node selected by the Range.\n                        subRangeIterator = rangeIterator.getSubtreeIterator();\n                        iterateSubtree(subRangeIterator, func, iteratorState);\n                        subRangeIterator.detach();\n                        if (iteratorState.stop) {\n                            return;\n                        }\n                    }\n                } else {\n                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n                    // descendants\n                    it = dom.createIterator(node);\n                    while ( (n = it.next()) ) {\n                        if (func(n) === false) {\n                            iteratorState.stop = true;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        function deleteSubtree(iterator) {\n            var subIterator;\n            while (iterator.next()) {\n                if (iterator.isPartiallySelectedSubtree()) {\n                    subIterator = iterator.getSubtreeIterator();\n                    deleteSubtree(subIterator);\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n            }\n        }\n\n        function extractSubtree(iterator) {\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n\n                if (iterator.isPartiallySelectedSubtree()) {\n                    node = node.cloneNode(false);\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(extractSubtree(subIterator));\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException("HIERARCHY_REQUEST_ERR");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function getNodesInRange(range, nodeTypes, filter) {\n            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;\n            var filterExists = !!filter;\n            if (filterNodeTypes) {\n                regex = new RegExp("^(" + nodeTypes.join("|") + ")$");\n            }\n\n            var nodes = [];\n            iterateSubtree(new RangeIterator(range, false), function(node) {\n                if (filterNodeTypes && !regex.test(node.nodeType)) {\n                    return;\n                }\n                if (filterExists && !filter(node)) {\n                    return;\n                }\n                // Don\'t include a boundary container if it is a character data node and the range does not contain any\n                // of its character data. See issue 190.\n                var sc = range.startContainer;\n                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {\n                    return;\n                }\n\n                var ec = range.endContainer;\n                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {\n                    return;\n                }\n\n                nodes.push(node);\n            });\n            return nodes;\n        }\n\n        function inspect(range) {\n            var name = (typeof range.getName == "undefined") ? "Range" : range.getName();\n            return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +\n                    dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n        function RangeIterator(range, clonePartiallySelectedTextNodes) {\n            this.range = range;\n            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n\n            if (!range.collapsed) {\n                this.sc = range.startContainer;\n                this.so = range.startOffset;\n                this.ec = range.endContainer;\n                this.eo = range.endOffset;\n                var root = range.commonAncestorContainer;\n\n                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n                    this.isSingleCharacterDataNode = true;\n                    this._first = this._last = this._next = this.sc;\n                } else {\n                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?\n                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);\n                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?\n                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);\n                }\n            }\n        }\n\n        RangeIterator.prototype = {\n            _current: null,\n            _next: null,\n            _first: null,\n            _last: null,\n            isSingleCharacterDataNode: false,\n\n            reset: function() {\n                this._current = null;\n                this._next = this._first;\n            },\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                // Move to next node\n                var current = this._current = this._next;\n                if (current) {\n                    this._next = (current !== this._last) ? current.nextSibling : null;\n\n                    // Check for partially selected text nodes\n                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n                        if (current === this.ec) {\n                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n                        }\n                        if (this._current === this.sc) {\n                            (current = current.cloneNode(true)).deleteData(0, this.so);\n                        }\n                    }\n                }\n\n                return current;\n            },\n\n            remove: function() {\n                var current = this._current, start, end;\n\n                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n                    start = (current === this.sc) ? this.so : 0;\n                    end = (current === this.ec) ? this.eo : current.length;\n                    if (start != end) {\n                        current.deleteData(start, end - start);\n                    }\n                } else {\n                    if (current.parentNode) {\n                        removeNode(current);\n                    } else {\n                    }\n                }\n            },\n\n            // Checks if the current node is partially selected\n            isPartiallySelectedSubtree: function() {\n                var current = this._current;\n                return isNonTextPartiallySelected(current, this.range);\n            },\n\n            getSubtreeIterator: function() {\n                var subRange;\n                if (this.isSingleCharacterDataNode) {\n                    subRange = this.range.cloneRange();\n                    subRange.collapse(false);\n                } else {\n                    subRange = new Range(getRangeDocument(this.range));\n                    var current = this._current;\n                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n                    if (isOrIsAncestorOf(current, this.sc)) {\n                        startContainer = this.sc;\n                        startOffset = this.so;\n                    }\n                    if (isOrIsAncestorOf(current, this.ec)) {\n                        endContainer = this.ec;\n                        endOffset = this.eo;\n                    }\n\n                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n                }\n                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n            },\n\n            detach: function() {\n                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n            }\n        };\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n        var rootContainerNodeTypes = [2, 9, 11];\n        var readonlyNodeTypes = [5, 6, 10, 12];\n        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n        function createAncestorFinder(nodeTypes) {\n            return function(node, selfIsAncestor) {\n                var t, n = selfIsAncestor ? node : node.parentNode;\n                while (n) {\n                    t = n.nodeType;\n                    if (arrayContains(nodeTypes, t)) {\n                        return n;\n                    }\n                    n = n.parentNode;\n                }\n                return null;\n            };\n        }\n\n        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );\n        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );\n\n        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n                throw new DOMException("INVALID_NODE_TYPE_ERR");\n            }\n        }\n\n        function assertValidNodeType(node, invalidTypes) {\n            if (!arrayContains(invalidTypes, node.nodeType)) {\n                throw new DOMException("INVALID_NODE_TYPE_ERR");\n            }\n        }\n\n        function assertValidOffset(node, offset) {\n            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n                throw new DOMException("INDEX_SIZE_ERR");\n            }\n        }\n\n        function assertSameDocumentOrFragment(node1, node2) {\n            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n                throw new DOMException("WRONG_DOCUMENT_ERR");\n            }\n        }\n\n        function assertNodeNotReadOnly(node) {\n            if (getReadonlyAncestor(node, true)) {\n                throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");\n            }\n        }\n\n        function assertNode(node, codeName) {\n            if (!node) {\n                throw new DOMException(codeName);\n            }\n        }\n\n        function isValidOffset(node, offset) {\n            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);\n        }\n\n        function isRangeValid(range) {\n            return (!!range.startContainer && !!range.endContainer &&\n                    !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&\n                    getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&\n                    isValidOffset(range.startContainer, range.startOffset) &&\n                    isValidOffset(range.endContainer, range.endOffset));\n        }\n\n        function assertRangeValid(range) {\n            if (!isRangeValid(range)) {\n                throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test the browser\'s innerHTML support to decide how to implement createContextualFragment\n        var styleEl = document.createElement("style");\n        var htmlParsingConforms = false;\n        try {\n            styleEl.innerHTML = "<b>x</b>";\n            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node\n        } catch (e) {\n            // IE 6 and 7 throw\n        }\n\n        api.features.htmlParsingConforms = htmlParsingConforms;\n\n        var createContextualFragment = htmlParsingConforms ?\n\n            // Implementation as per HTML parsing spec, trusting in the browser\'s implementation of innerHTML. See\n            // discussion and base code for this implementation at issue 67.\n            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n            // Thanks to Aleks Williams.\n            function(fragmentStr) {\n                // "Let node the context object\'s start\'s node."\n                var node = this.startContainer;\n                var doc = getDocument(node);\n\n                // "If the context object\'s start\'s node is null, raise an INVALID_STATE_ERR\n                // exception and abort these steps."\n                if (!node) {\n                    throw new DOMException("INVALID_STATE_ERR");\n                }\n\n                // "Let element be as follows, depending on node\'s interface:"\n                // Document, Document Fragment: null\n                var el = null;\n\n                // "Element: node"\n                if (node.nodeType == 1) {\n                    el = node;\n\n                // "Text, Comment: node\'s parentElement"\n                } else if (isCharacterDataNode(node)) {\n                    el = dom.parentElement(node);\n                }\n\n                // "If either element is null or element\'s ownerDocument is an HTML document\n                // and element\'s local name is "html" and element\'s namespace is the HTML\n                // namespace"\n                if (el === null || (\n                    el.nodeName == "HTML" &&\n                    dom.isHtmlNamespace(getDocument(el).documentElement) &&\n                    dom.isHtmlNamespace(el)\n                )) {\n\n                // "let element be a new Element with "body" as its local name and the HTML\n                // namespace as its namespace.""\n                    el = doc.createElement("body");\n                } else {\n                    el = el.cloneNode(false);\n                }\n\n                // "If the node\'s document is an HTML document: Invoke the HTML fragment parsing algorithm."\n                // "If the node\'s document is an XML document: Invoke the XML fragment parsing algorithm."\n                // "In either case, the algorithm must be invoked with fragment as the input\n                // and element as the context element."\n                el.innerHTML = fragmentStr;\n\n                // "If this raises an exception, then abort these steps. Otherwise, let new\n                // children be the nodes returned."\n\n                // "Let fragment be a new DocumentFragment."\n                // "Append all new children to fragment."\n                // "Return fragment."\n                return dom.fragmentFromNodeChildren(el);\n            } :\n\n            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n            // previous versions of Rangy used (with the exception of using a body element rather than a div)\n            function(fragmentStr) {\n                var doc = getRangeDocument(this);\n                var el = doc.createElement("body");\n                el.innerHTML = fragmentStr;\n\n                return dom.fragmentFromNodeChildren(el);\n            };\n\n        function splitRangeBoundaries(range, positionsToPreserve) {\n            assertRangeValid(range);\n\n            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;\n            var startEndSame = (sc === ec);\n\n            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n                splitDataNode(ec, eo, positionsToPreserve);\n            }\n\n            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n                sc = splitDataNode(sc, so, positionsToPreserve);\n                if (startEndSame) {\n                    eo -= so;\n                    ec = sc;\n                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {\n                    eo++;\n                }\n                so = 0;\n            }\n            range.setStartAndEnd(sc, so, ec, eo);\n        }\n\n        function rangeToHtml(range) {\n            assertRangeValid(range);\n            var container = range.commonAncestorContainer.parentNode.cloneNode(false);\n            container.appendChild( range.cloneContents() );\n            return container.innerHTML;\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",\n            "commonAncestorContainer"];\n\n        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;\n        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;\n\n        util.extend(api.rangePrototype, {\n            compareBoundaryPoints: function(how, range) {\n                assertRangeValid(this);\n                assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n                var nodeA, offsetA, nodeB, offsetB;\n                var prefixA = (how == e2s || how == s2s) ? "start" : "end";\n                var prefixB = (how == s2e || how == s2s) ? "start" : "end";\n                nodeA = this[prefixA + "Container"];\n                offsetA = this[prefixA + "Offset"];\n                nodeB = range[prefixB + "Container"];\n                offsetB = range[prefixB + "Offset"];\n                return comparePoints(nodeA, offsetA, nodeB, offsetB);\n            },\n\n            insertNode: function(node) {\n                assertRangeValid(this);\n                assertValidNodeType(node, insertableNodeTypes);\n                assertNodeNotReadOnly(this.startContainer);\n\n                if (isOrIsAncestorOf(node, this.startContainer)) {\n                    throw new DOMException("HIERARCHY_REQUEST_ERR");\n                }\n\n                // No check for whether the container of the start of the Range is of a type that does not allow\n                // children of the type of node: the browser\'s DOM implementation should do this for us when we attempt\n                // to add the node\n\n                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                this.setStartBefore(firstNodeInserted);\n            },\n\n            cloneContents: function() {\n                assertRangeValid(this);\n\n                var clone, frag;\n                if (this.collapsed) {\n                    return getRangeDocument(this).createDocumentFragment();\n                } else {\n                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {\n                        clone = this.startContainer.cloneNode(true);\n                        clone.data = clone.data.slice(this.startOffset, this.endOffset);\n                        frag = getRangeDocument(this).createDocumentFragment();\n                        frag.appendChild(clone);\n                        return frag;\n                    } else {\n                        var iterator = new RangeIterator(this, true);\n                        clone = cloneSubtree(iterator);\n                        iterator.detach();\n                    }\n                    return clone;\n                }\n            },\n\n            canSurroundContents: function() {\n                assertRangeValid(this);\n                assertNodeNotReadOnly(this.startContainer);\n                assertNodeNotReadOnly(this.endContainer);\n\n                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                // no non-text nodes.\n                var iterator = new RangeIterator(this, true);\n                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||\n                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                iterator.detach();\n                return !boundariesInvalid;\n            },\n\n            surroundContents: function(node) {\n                assertValidNodeType(node, surroundNodeTypes);\n\n                if (!this.canSurroundContents()) {\n                    throw new DOMException("INVALID_STATE_ERR");\n                }\n\n                // Extract the contents\n                var content = this.extractContents();\n\n                // Clear the children of the node\n                if (node.hasChildNodes()) {\n                    while (node.lastChild) {\n                        node.removeChild(node.lastChild);\n                    }\n                }\n\n                // Insert the new node and add the extracted contents\n                insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                node.appendChild(content);\n\n                this.selectNode(node);\n            },\n\n            cloneRange: function() {\n                assertRangeValid(this);\n                var range = new Range(getRangeDocument(this));\n                var i = rangeProperties.length, prop;\n                while (i--) {\n                    prop = rangeProperties[i];\n                    range[prop] = this[prop];\n                }\n                return range;\n            },\n\n            toString: function() {\n                assertRangeValid(this);\n                var sc = this.startContainer;\n                if (sc === this.endContainer && isCharacterDataNode(sc)) {\n                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";\n                } else {\n                    var textParts = [], iterator = new RangeIterator(this, true);\n                    iterateSubtree(iterator, function(node) {\n                        // Accept only text or CDATA nodes, not comments\n                        if (node.nodeType == 3 || node.nodeType == 4) {\n                            textParts.push(node.data);\n                        }\n                    });\n                    iterator.detach();\n                    return textParts.join("");\n                }\n            },\n\n            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n            // been removed from Mozilla.\n\n            compareNode: function(node) {\n                assertRangeValid(this);\n\n                var parent = node.parentNode;\n                var nodeIndex = getNodeIndex(node);\n\n                if (!parent) {\n                    throw new DOMException("NOT_FOUND_ERR");\n                }\n\n                var startComparison = this.comparePoint(parent, nodeIndex),\n                    endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n                if (startComparison < 0) { // Node starts before\n                    return (endComparison > 0) ? n_b_a : n_b;\n                } else {\n                    return (endComparison > 0) ? n_a : n_i;\n                }\n            },\n\n            comparePoint: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, "HIERARCHY_REQUEST_ERR");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n                    return -1;\n                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n                    return 1;\n                }\n                return 0;\n            },\n\n            createContextualFragment: createContextualFragment,\n\n            toHtml: function() {\n                return rangeToHtml(this);\n            },\n\n            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n            intersectsNode: function(node, touchingIsIntersecting) {\n                assertRangeValid(this);\n                if (getRootContainer(node) != getRangeRoot(this)) {\n                    return false;\n                }\n\n                var parent = node.parentNode, offset = getNodeIndex(node);\n                if (!parent) {\n                    return true;\n                }\n\n                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),\n                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n            },\n\n            isPointInRange: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, "HIERARCHY_REQUEST_ERR");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&\n                       (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);\n            },\n\n            // The methods below are non-standard and invented by me.\n\n            // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n            intersectsRange: function(range) {\n                return rangesIntersect(this, range, false);\n            },\n\n            // Sharing a boundary start-to-end or end-to-start does count as intersection.\n            intersectsOrTouchesRange: function(range) {\n                return rangesIntersect(this, range, true);\n            },\n\n            intersection: function(range) {\n                if (this.intersectsRange(range)) {\n                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n                    var intersectionRange = this.cloneRange();\n                    if (startComparison == -1) {\n                        intersectionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (endComparison == 1) {\n                        intersectionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return intersectionRange;\n                }\n                return null;\n            },\n\n            union: function(range) {\n                if (this.intersectsOrTouchesRange(range)) {\n                    var unionRange = this.cloneRange();\n                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n                        unionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n                        unionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return unionRange;\n                } else {\n                    throw new DOMException("Ranges do not intersect");\n                }\n            },\n\n            containsNode: function(node, allowPartial) {\n                if (allowPartial) {\n                    return this.intersectsNode(node, false);\n                } else {\n                    return this.compareNode(node) == n_i;\n                }\n            },\n\n            containsNodeContents: function(node) {\n                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;\n            },\n\n            containsRange: function(range) {\n                var intersection = this.intersection(range);\n                return intersection !== null && range.equals(intersection);\n            },\n\n            containsNodeText: function(node) {\n                var nodeRange = this.cloneRange();\n                nodeRange.selectNode(node);\n                var textNodes = nodeRange.getNodes([3]);\n                if (textNodes.length > 0) {\n                    nodeRange.setStart(textNodes[0], 0);\n                    var lastTextNode = textNodes.pop();\n                    nodeRange.setEnd(lastTextNode, lastTextNode.length);\n                    return this.containsRange(nodeRange);\n                } else {\n                    return this.containsNodeContents(node);\n                }\n            },\n\n            getNodes: function(nodeTypes, filter) {\n                assertRangeValid(this);\n                return getNodesInRange(this, nodeTypes, filter);\n            },\n\n            getDocument: function() {\n                return getRangeDocument(this);\n            },\n\n            collapseBefore: function(node) {\n                this.setEndBefore(node);\n                this.collapse(false);\n            },\n\n            collapseAfter: function(node) {\n                this.setStartAfter(node);\n                this.collapse(true);\n            },\n\n            getBookmark: function(containerNode) {\n                var doc = getRangeDocument(this);\n                var preSelectionRange = api.createRange(doc);\n                containerNode = containerNode || dom.getBody(doc);\n                preSelectionRange.selectNodeContents(containerNode);\n                var range = this.intersection(preSelectionRange);\n                var start = 0, end = 0;\n                if (range) {\n                    preSelectionRange.setEnd(range.startContainer, range.startOffset);\n                    start = preSelectionRange.toString().length;\n                    end = start + range.toString().length;\n                }\n\n                return {\n                    start: start,\n                    end: end,\n                    containerNode: containerNode\n                };\n            },\n\n            moveToBookmark: function(bookmark) {\n                var containerNode = bookmark.containerNode;\n                var charIndex = 0;\n                this.setStart(containerNode, 0);\n                this.collapse(true);\n                var nodeStack = [containerNode], node, foundStart = false, stop = false;\n                var nextCharIndex, i, childNodes;\n\n                while (!stop && (node = nodeStack.pop())) {\n                    if (node.nodeType == 3) {\n                        nextCharIndex = charIndex + node.length;\n                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {\n                            this.setStart(node, bookmark.start - charIndex);\n                            foundStart = true;\n                        }\n                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {\n                            this.setEnd(node, bookmark.end - charIndex);\n                            stop = true;\n                        }\n                        charIndex = nextCharIndex;\n                    } else {\n                        childNodes = node.childNodes;\n                        i = childNodes.length;\n                        while (i--) {\n                            nodeStack.push(childNodes[i]);\n                        }\n                    }\n                }\n            },\n\n            getName: function() {\n                return "DomRange";\n            },\n\n            equals: function(range) {\n                return Range.rangesEqual(this, range);\n            },\n\n            isValid: function() {\n                return isRangeValid(this);\n            },\n\n            inspect: function() {\n                return inspect(this);\n            },\n\n            detach: function() {\n                // In DOM4, detach() is now a no-op.\n            }\n        });\n\n        function copyComparisonConstantsToObject(obj) {\n            obj.START_TO_START = s2s;\n            obj.START_TO_END = s2e;\n            obj.END_TO_END = e2e;\n            obj.END_TO_START = e2s;\n\n            obj.NODE_BEFORE = n_b;\n            obj.NODE_AFTER = n_a;\n            obj.NODE_BEFORE_AND_AFTER = n_b_a;\n            obj.NODE_INSIDE = n_i;\n        }\n\n        function copyComparisonConstants(constructor) {\n            copyComparisonConstantsToObject(constructor);\n            copyComparisonConstantsToObject(constructor.prototype);\n        }\n\n        function createRangeContentRemover(remover, boundaryUpdater) {\n            return function() {\n                assertRangeValid(this);\n\n                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;\n\n                var iterator = new RangeIterator(this, true);\n\n                // Work out where to position the range after content removal\n                var node, boundary;\n                if (sc !== root) {\n                    node = getClosestAncestorIn(sc, root, true);\n                    boundary = getBoundaryAfterNode(node);\n                    sc = boundary.node;\n                    so = boundary.offset;\n                }\n\n                // Check none of the range is read-only\n                iterateSubtree(iterator, assertNodeNotReadOnly);\n\n                iterator.reset();\n\n                // Remove the content\n                var returnValue = remover(iterator);\n                iterator.detach();\n\n                // Move to the new position\n                boundaryUpdater(this, sc, so, sc, so);\n\n                return returnValue;\n            };\n        }\n\n        function createPrototypeRange(constructor, boundaryUpdater) {\n            function createBeforeAfterNodeSetter(isBefore, isStart) {\n                return function(node) {\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n                };\n            }\n\n            function setRangeStart(range, node, offset) {\n                var ec = range.endContainer, eo = range.endOffset;\n                if (node !== range.startContainer || offset !== range.startOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {\n                        ec = node;\n                        eo = offset;\n                    }\n                    boundaryUpdater(range, node, offset, ec, eo);\n                }\n            }\n\n            function setRangeEnd(range, node, offset) {\n                var sc = range.startContainer, so = range.startOffset;\n                if (node !== range.endContainer || offset !== range.endOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {\n                        sc = node;\n                        so = offset;\n                    }\n                    boundaryUpdater(range, sc, so, node, offset);\n                }\n            }\n\n            // Set up inheritance\n            var F = function() {};\n            F.prototype = api.rangePrototype;\n            constructor.prototype = new F();\n\n            util.extend(constructor.prototype, {\n                setStart: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeStart(this, node, offset);\n                },\n\n                setEnd: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeEnd(this, node, offset);\n                },\n\n                /**\n                 * Convenience method to set a range\'s start and end boundaries. Overloaded as follows:\n                 * - Two parameters (node, offset) creates a collapsed range at that position\n                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at\n                 *   startOffset and ending at endOffset\n                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in\n                 *   startNode and ending at endOffset in endNode\n                 */\n                setStartAndEnd: function() {\n                    var args = arguments;\n                    var sc = args[0], so = args[1], ec = sc, eo = so;\n\n                    switch (args.length) {\n                        case 3:\n                            eo = args[2];\n                            break;\n                        case 4:\n                            ec = args[2];\n                            eo = args[3];\n                            break;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                setBoundary: function(node, offset, isStart) {\n                    this["set" + (isStart ? "Start" : "End")](node, offset);\n                },\n\n                setStartBefore: createBeforeAfterNodeSetter(true, true),\n                setStartAfter: createBeforeAfterNodeSetter(false, true),\n                setEndBefore: createBeforeAfterNodeSetter(true, false),\n                setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n                collapse: function(isStart) {\n                    assertRangeValid(this);\n                    if (isStart) {\n                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n                    } else {\n                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n                    }\n                },\n\n                selectNodeContents: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n\n                    boundaryUpdater(this, node, 0, node, getNodeLength(node));\n                },\n\n                selectNode: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, false);\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n\n                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);\n                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n                },\n\n                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n                canSurroundContents: function() {\n                    assertRangeValid(this);\n                    assertNodeNotReadOnly(this.startContainer);\n                    assertNodeNotReadOnly(this.endContainer);\n\n                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                    // no non-text nodes.\n                    var iterator = new RangeIterator(this, true);\n                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||\n                            (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                    iterator.detach();\n                    return !boundariesInvalid;\n                },\n\n                splitBoundaries: function() {\n                    splitRangeBoundaries(this);\n                },\n\n                splitBoundariesPreservingPositions: function(positionsToPreserve) {\n                    splitRangeBoundaries(this, positionsToPreserve);\n                },\n\n                normalizeBoundaries: function() {\n                    assertRangeValid(this);\n\n                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;\n\n                    var mergeForward = function(node) {\n                        var sibling = node.nextSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            ec = node;\n                            eo = node.length;\n                            node.appendData(sibling.data);\n                            removeNode(sibling);\n                        }\n                    };\n\n                    var mergeBackward = function(node) {\n                        var sibling = node.previousSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            sc = node;\n                            var nodeLength = node.length;\n                            so = sibling.length;\n                            node.insertData(0, sibling.data);\n                            removeNode(sibling);\n                            if (sc == ec) {\n                                eo += so;\n                                ec = sc;\n                            } else if (ec == node.parentNode) {\n                                var nodeIndex = getNodeIndex(node);\n                                if (eo == nodeIndex) {\n                                    ec = node;\n                                    eo = nodeLength;\n                                } else if (eo > nodeIndex) {\n                                    eo--;\n                                }\n                            }\n                        }\n                    };\n\n                    var normalizeStart = true;\n                    var sibling;\n\n                    if (isCharacterDataNode(ec)) {\n                        if (eo == ec.length) {\n                            mergeForward(ec);\n                        } else if (eo == 0) {\n                            sibling = ec.previousSibling;\n                            if (sibling && sibling.nodeType == ec.nodeType) {\n                                eo = sibling.length;\n                                if (sc == ec) {\n                                    normalizeStart = false;\n                                }\n                                sibling.appendData(ec.data);\n                                removeNode(ec);\n                                ec = sibling;\n                            }\n                        }\n                    } else {\n                        if (eo > 0) {\n                            var endNode = ec.childNodes[eo - 1];\n                            if (endNode && isCharacterDataNode(endNode)) {\n                                mergeForward(endNode);\n                            }\n                        }\n                        normalizeStart = !this.collapsed;\n                    }\n\n                    if (normalizeStart) {\n                        if (isCharacterDataNode(sc)) {\n                            if (so == 0) {\n                                mergeBackward(sc);\n                            } else if (so == sc.length) {\n                                sibling = sc.nextSibling;\n                                if (sibling && sibling.nodeType == sc.nodeType) {\n                                    if (ec == sibling) {\n                                        ec = sc;\n                                        eo += sc.length;\n                                    }\n                                    sc.appendData(sibling.data);\n                                    removeNode(sibling);\n                                }\n                            }\n                        } else {\n                            if (so < sc.childNodes.length) {\n                                var startNode = sc.childNodes[so];\n                                if (startNode && isCharacterDataNode(startNode)) {\n                                    mergeBackward(startNode);\n                                }\n                            }\n                        }\n                    } else {\n                        sc = ec;\n                        so = eo;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                collapseToPoint: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n                    this.setStartAndEnd(node, offset);\n                }\n            });\n\n            copyComparisonConstants(constructor);\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Updates commonAncestorContainer and collapsed after boundary change\n        function updateCollapsedAndCommonAncestor(range) {\n            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n            range.commonAncestorContainer = range.collapsed ?\n                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n        }\n\n        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n            range.startContainer = startContainer;\n            range.startOffset = startOffset;\n            range.endContainer = endContainer;\n            range.endOffset = endOffset;\n            range.document = dom.getDocument(startContainer);\n\n            updateCollapsedAndCommonAncestor(range);\n        }\n\n        function Range(doc) {\n            this.startContainer = doc;\n            this.startOffset = 0;\n            this.endContainer = doc;\n            this.endOffset = 0;\n            this.document = doc;\n            updateCollapsedAndCommonAncestor(this);\n        }\n\n        createPrototypeRange(Range, updateBoundaries);\n\n        util.extend(Range, {\n            rangeProperties: rangeProperties,\n            RangeIterator: RangeIterator,\n            copyComparisonConstants: copyComparisonConstants,\n            createPrototypeRange: createPrototypeRange,\n            inspect: inspect,\n            toHtml: rangeToHtml,\n            getRangeDocument: getRangeDocument,\n            rangesEqual: function(r1, r2) {\n                return r1.startContainer === r2.startContainer &&\n                    r1.startOffset === r2.startOffset &&\n                    r1.endContainer === r2.endContainer &&\n                    r1.endOffset === r2.endOffset;\n            }\n        });\n\n        api.DomRange = Range;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wrappers for the browser\'s native DOM Range and/or TextRange implementation\n    api.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {\n        var WrappedRange, WrappedTextRange;\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DomRange = api.DomRange;\n        var getBody = dom.getBody;\n        var getContentDocument = dom.getContentDocument;\n        var isCharacterDataNode = dom.isCharacterDataNode;\n\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        if (api.features.implementsDomRange) {\n            // This is a wrapper around the browser\'s native DOM Range. It has two aims:\n            // - Provide workarounds for specific browser bugs\n            // - provide convenient extensions, which are inherited from Rangy\'s DomRange\n\n            (function() {\n                var rangeProto;\n                var rangeProperties = DomRange.rangeProperties;\n\n                function updateRangeProperties(range) {\n                    var i = rangeProperties.length, prop;\n                    while (i--) {\n                        prop = rangeProperties[i];\n                        range[prop] = range.nativeRange[prop];\n                    }\n                    // Fix for broken collapsed property in IE 9.\n                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n                }\n\n                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);\n                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);\n                    var nativeRangeDifferent = !range.equals(range.nativeRange);\n\n                    // Always set both boundaries for the benefit of IE9 (see issue 35)\n                    if (startMoved || endMoved || nativeRangeDifferent) {\n                        range.setEnd(endContainer, endOffset);\n                        range.setStart(startContainer, startOffset);\n                    }\n                }\n\n                var createBeforeAfterNodeSetter;\n\n                WrappedRange = function(range) {\n                    if (!range) {\n                        throw module.createError("WrappedRange: Range must be specified");\n                    }\n                    this.nativeRange = range;\n                    updateRangeProperties(this);\n                };\n\n                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);\n\n                rangeProto = WrappedRange.prototype;\n\n                rangeProto.selectNode = function(node) {\n                    this.nativeRange.selectNode(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneContents = function() {\n                    return this.nativeRange.cloneContents();\n                };\n\n                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,\n                // insertNode() is never delegated to the native range.\n\n                rangeProto.surroundContents = function(node) {\n                    this.nativeRange.surroundContents(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.collapse = function(isStart) {\n                    this.nativeRange.collapse(isStart);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneRange = function() {\n                    return new WrappedRange(this.nativeRange.cloneRange());\n                };\n\n                rangeProto.refresh = function() {\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.toString = function() {\n                    return this.nativeRange.toString();\n                };\n\n                // Create test range and node for feature detection\n\n                var testTextNode = document.createTextNode("test");\n                getBody(document).appendChild(testTextNode);\n                var range = document.createRange();\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n                // correct for it\n\n                range.setStart(testTextNode, 0);\n                range.setEnd(testTextNode, 0);\n\n                try {\n                    range.setStart(testTextNode, 1);\n\n                    rangeProto.setStart = function(node, offset) {\n                        this.nativeRange.setStart(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        this.nativeRange.setEnd(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name) {\n                        return function(node) {\n                            this.nativeRange[name](node);\n                            updateRangeProperties(this);\n                        };\n                    };\n\n                } catch(ex) {\n\n                    rangeProto.setStart = function(node, offset) {\n                        try {\n                            this.nativeRange.setStart(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setEnd(node, offset);\n                            this.nativeRange.setStart(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        try {\n                            this.nativeRange.setEnd(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setStart(node, offset);\n                            this.nativeRange.setEnd(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name, oppositeName) {\n                        return function(node) {\n                            try {\n                                this.nativeRange[name](node);\n                            } catch (ex) {\n                                this.nativeRange[oppositeName](node);\n                                this.nativeRange[name](node);\n                            }\n                            updateRangeProperties(this);\n                        };\n                    };\n                }\n\n                rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");\n                rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");\n                rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");\n                rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Always use DOM4-compliant selectNodeContents implementation: it\'s simpler and less code than testing\n                // whether the native implementation can be trusted\n                rangeProto.selectNodeContents = function(node) {\n                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));\n                };\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for\n                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n                range.selectNodeContents(testTextNode);\n                range.setEnd(testTextNode, 3);\n\n                var range2 = document.createRange();\n                range2.selectNodeContents(testTextNode);\n                range2.setEnd(testTextNode, 4);\n                range2.setStart(testTextNode, 2);\n\n                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&\n                        range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n                    // This is the wrong way round, so correct for it\n\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        range = range.nativeRange || range;\n                        if (type == range.START_TO_END) {\n                            type = range.END_TO_START;\n                        } else if (type == range.END_TO_START) {\n                            type = range.START_TO_END;\n                        }\n                        return this.nativeRange.compareBoundaryPoints(type, range);\n                    };\n                } else {\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.\n\n                var el = document.createElement("div");\n                el.innerHTML = "123";\n                var textNode = el.firstChild;\n                var body = getBody(document);\n                body.appendChild(el);\n\n                range.setStart(textNode, 1);\n                range.setEnd(textNode, 2);\n                range.deleteContents();\n\n                if (textNode.data == "13") {\n                    // Behaviour is correct per DOM4 Range so wrap the browser\'s implementation of deleteContents() and\n                    // extractContents()\n                    rangeProto.deleteContents = function() {\n                        this.nativeRange.deleteContents();\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.extractContents = function() {\n                        var frag = this.nativeRange.extractContents();\n                        updateRangeProperties(this);\n                        return frag;\n                    };\n                } else {\n                }\n\n                body.removeChild(el);\n                body = null;\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for existence of createContextualFragment and delegate to it if it exists\n                if (util.isHostMethod(range, "createContextualFragment")) {\n                    rangeProto.createContextualFragment = function(fragmentStr) {\n                        return this.nativeRange.createContextualFragment(fragmentStr);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Clean up\n                getBody(document).removeChild(testTextNode);\n\n                rangeProto.getName = function() {\n                    return "WrappedRange";\n                };\n\n                api.WrappedRange = WrappedRange;\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, "createNativeRange");\n                    return doc.createRange();\n                };\n            })();\n        }\n\n        if (api.features.implementsTextRange) {\n            /*\n            This is a workaround for a bug where IE returns the wrong container element from the TextRange\'s parentElement()\n            method. For example, in the following (where pipes denote the selection boundaries):\n\n            <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>\n\n            var range = document.selection.createRange();\n            alert(range.parentElement().id); // Should alert "ul" but alerts "b"\n\n            This method returns the common ancestor node of the following:\n            - the parentElement() of the textRange\n            - the parentElement() of the textRange after calling collapse(true)\n            - the parentElement() of the textRange after calling collapse(false)\n            */\n            var getTextRangeContainerElement = function(textRange) {\n                var parentEl = textRange.parentElement();\n                var range = textRange.duplicate();\n                range.collapse(true);\n                var startEl = range.parentElement();\n                range = textRange.duplicate();\n                range.collapse(false);\n                var endEl = range.parentElement();\n                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n            };\n\n            var textRangeIsCollapsed = function(textRange) {\n                return textRange.compareEndPoints("StartToEnd", textRange) == 0;\n            };\n\n            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started\n            // out as an improved version of code found in Tim Cameron Ryan\'s IERange (http://code.google.com/p/ierange/)\n            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange\n            // bugs, handling for inputs and images, plus optimizations.\n            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {\n                var workingRange = textRange.duplicate();\n                workingRange.collapse(isStart);\n                var containerElement = workingRange.parentElement();\n\n                // Sometimes collapsing a TextRange that\'s at the start of a text node can move it into the previous node, so\n                // check for that\n                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {\n                    containerElement = wholeRangeContainerElement;\n                }\n\n\n                // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and\n                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n                if (!containerElement.canHaveHTML) {\n                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n                    return {\n                        boundaryPosition: pos,\n                        nodeInfo: {\n                            nodeIndex: pos.offset,\n                            containerElement: pos.node\n                        }\n                    };\n                }\n\n                var workingNode = dom.getDocument(containerElement).createElement("span");\n\n                // Workaround for HTML5 Shiv\'s insane violation of document.createElement(). See Rangy issue 104 and HTML5\n                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64\n                if (workingNode.parentNode) {\n                    dom.removeNode(workingNode);\n                }\n\n                var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";\n                var previousNode, nextNode, boundaryPosition, boundaryNode;\n                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;\n                var childNodeCount = containerElement.childNodes.length;\n                var end = childNodeCount;\n\n                // Check end first. Code within the loop assumes that the endth child node of the container is definitely\n                // after the range boundary.\n                var nodeIndex = end;\n\n                while (true) {\n                    if (nodeIndex == childNodeCount) {\n                        containerElement.appendChild(workingNode);\n                    } else {\n                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);\n                    }\n                    workingRange.moveToElementText(workingNode);\n                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);\n                    if (comparison == 0 || start == end) {\n                        break;\n                    } else if (comparison == -1) {\n                        if (end == start + 1) {\n                            // We know the endth child node is after the range boundary, so we must be done.\n                            break;\n                        } else {\n                            start = nodeIndex;\n                        }\n                    } else {\n                        end = (end == start + 1) ? start : nodeIndex;\n                    }\n                    nodeIndex = Math.floor((start + end) / 2);\n                    containerElement.removeChild(workingNode);\n                }\n\n\n                // We\'ve now reached or gone past the boundary of the text range we\'re interested in\n                // so have identified the node we want\n                boundaryNode = workingNode.nextSibling;\n\n                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {\n                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of\n                    // the node containing the text range\'s boundary, so we move the end of the working range to the\n                    // boundary point and measure the length of its text to get the boundary\'s offset within the node.\n                    workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);\n\n                    var offset;\n\n                    if (/[\\r\\n]/.test(boundaryNode.data)) {\n                        /*\n                        For the particular case of a boundary within a text node containing rendered line breaks (within a\n                        <pre> element, for example), we need a slightly complicated approach to get the boundary\'s offset in\n                        IE. The facts:\n\n                        - Each line break is represented as \\r in the text node\'s data/nodeValue properties\n                        - Each line break is represented as \\r\\n in the TextRange\'s \'text\' property\n                        - The \'text\' property of the TextRange does not contain trailing line breaks\n\n                        To get round the problem presented by the final fact above, we can use the fact that TextRange\'s\n                        moveStart() and moveEnd() methods return the actual number of characters moved, which is not\n                        necessarily the same as the number of characters it was instructed to move. The simplest approach is\n                        to use this to store the characters moved when moving both the start and end of the range to the\n                        start of the document body and subtracting the start offset from the end offset (the\n                        "move-negative-gazillion" method). However, this is extremely slow when the document is large and\n                        the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to\n                        the end of the document) has the same problem.\n\n                        Another approach that works is to use moveStart() to move the start boundary of the range up to the\n                        end boundary one character at a time and incrementing a counter with the value returned by the\n                        moveStart() call. However, the check for whether the start boundary has reached the end boundary is\n                        expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected\n                        by the location of the range within the document).\n\n                        The approach used below is a hybrid of the two methods above. It uses the fact that a string\n                        containing the TextRange\'s \'text\' property with each \\r\\n converted to a single \\r character cannot\n                        be longer than the text of the TextRange, so the start of the range is moved that length initially\n                        and then a character at a time to make up for any trailing line breaks not contained in the \'text\'\n                        property. This has good performance in most situations compared to the previous two methods.\n                        */\n                        var tempRange = workingRange.duplicate();\n                        var rangeLength = tempRange.text.replace(/\\r\\n/g, "\\r").length;\n\n                        offset = tempRange.moveStart("character", rangeLength);\n                        while ( (comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {\n                            offset++;\n                            tempRange.moveStart("character", 1);\n                        }\n                    } else {\n                        offset = workingRange.text.length;\n                    }\n                    boundaryPosition = new DomPosition(boundaryNode, offset);\n                } else {\n\n                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n                    // a position within that, and likewise for a start boundary preceding a character data node\n                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n                    if (nextNode && isCharacterDataNode(nextNode)) {\n                        boundaryPosition = new DomPosition(nextNode, 0);\n                    } else if (previousNode && isCharacterDataNode(previousNode)) {\n                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);\n                    } else {\n                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n                    }\n                }\n\n                // Clean up\n                dom.removeNode(workingNode);\n\n                return {\n                    boundaryPosition: boundaryPosition,\n                    nodeInfo: {\n                        nodeIndex: nodeIndex,\n                        containerElement: containerElement\n                    }\n                };\n            };\n\n            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that\n            // node. This function started out as an optimized version of code found in Tim Cameron Ryan\'s IERange\n            // (http://code.google.com/p/ierange/)\n            var createBoundaryTextRange = function(boundaryPosition, isStart) {\n                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;\n                var doc = dom.getDocument(boundaryPosition.node);\n                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();\n                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);\n\n                if (nodeIsDataNode) {\n                    boundaryNode = boundaryPosition.node;\n                    boundaryParent = boundaryNode.parentNode;\n                } else {\n                    childNodes = boundaryPosition.node.childNodes;\n                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;\n                    boundaryParent = boundaryPosition.node;\n                }\n\n                // Position the range immediately before the node containing the boundary\n                workingNode = doc.createElement("span");\n\n                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within\n                // the element rather than immediately before or after it\n                workingNode.innerHTML = "&#feff;";\n\n                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n                if (boundaryNode) {\n                    boundaryParent.insertBefore(workingNode, boundaryNode);\n                } else {\n                    boundaryParent.appendChild(workingNode);\n                }\n\n                workingRange.moveToElementText(workingNode);\n                workingRange.collapse(!isStart);\n\n                // Clean up\n                boundaryParent.removeChild(workingNode);\n\n                // Move the working range to the text offset, if required\n                if (nodeIsDataNode) {\n                    workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);\n                }\n\n                return workingRange;\n            };\n\n            /*------------------------------------------------------------------------------------------------------------*/\n\n            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy\'s DomRange as a\n            // prototype\n\n            WrappedTextRange = function(textRange) {\n                this.textRange = textRange;\n                this.refresh();\n            };\n\n            WrappedTextRange.prototype = new DomRange(document);\n\n            WrappedTextRange.prototype.refresh = function() {\n                var start, end, startBoundary;\n\n                // TextRange\'s parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n                var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n                if (textRangeIsCollapsed(this.textRange)) {\n                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,\n                        true).boundaryPosition;\n                } else {\n                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n                    start = startBoundary.boundaryPosition;\n\n                    // An optimization used here is that if the start and end boundaries have the same parent element, the\n                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes\n                    // the start boundary\n                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,\n                        startBoundary.nodeInfo).boundaryPosition;\n                }\n\n                this.setStart(start.node, start.offset);\n                this.setEnd(end.node, end.offset);\n            };\n\n            WrappedTextRange.prototype.getName = function() {\n                return "WrappedTextRange";\n            };\n\n            DomRange.copyComparisonConstants(WrappedTextRange);\n\n            var rangeToTextRange = function(range) {\n                if (range.collapsed) {\n                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                } else {\n                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();\n                    textRange.setEndPoint("StartToStart", startRange);\n                    textRange.setEndPoint("EndToEnd", endRange);\n                    return textRange;\n                }\n            };\n\n            WrappedTextRange.rangeToTextRange = rangeToTextRange;\n\n            WrappedTextRange.prototype.toTextRange = function() {\n                return rangeToTextRange(this);\n            };\n\n            api.WrappedTextRange = WrappedTextRange;\n\n            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which\n            // implementation to use by default.\n            if (!api.features.implementsDomRange || api.config.preferTextRange) {\n                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n                var globalObj = (function(f) { return f("return this;")(); })(Function);\n                if (typeof globalObj.Range == "undefined") {\n                    globalObj.Range = WrappedTextRange;\n                }\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, "createNativeRange");\n                    return getBody(doc).createTextRange();\n                };\n\n                api.WrappedRange = WrappedTextRange;\n            }\n        }\n\n        api.createRange = function(doc) {\n            doc = getContentDocument(doc, module, "createRange");\n            return new api.WrappedRange(api.createNativeRange(doc));\n        };\n\n        api.createRangyRange = function(doc) {\n            doc = getContentDocument(doc, module, "createRangyRange");\n            return new DomRange(doc);\n        };\n\n        util.createAliasForDeprecatedMethod(api, "createIframeRange", "createRange");\n        util.createAliasForDeprecatedMethod(api, "createIframeRangyRange", "createRangyRange");\n\n        api.addShimListener(function(win) {\n            var doc = win.document;\n            if (typeof doc.createRange == "undefined") {\n                doc.createRange = function() {\n                    return api.createRange(doc);\n                };\n            }\n            doc = win = null;\n        });\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification\n    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)\n    api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {\n        api.config.checkSelectionRanges = true;\n\n        var BOOLEAN = "boolean";\n        var NUMBER = "number";\n        var dom = api.dom;\n        var util = api.util;\n        var isHostMethod = util.isHostMethod;\n        var DomRange = api.DomRange;\n        var WrappedRange = api.WrappedRange;\n        var DOMException = api.DOMException;\n        var DomPosition = dom.DomPosition;\n        var getNativeSelection;\n        var selectionIsCollapsed;\n        var features = api.features;\n        var CONTROL = "Control";\n        var getDocument = dom.getDocument;\n        var getBody = dom.getBody;\n        var rangesEqual = DomRange.rangesEqual;\n\n\n        // Utility function to support direction parameters in the API that may be a string ("backward", "backwards",\n        // "forward" or "forwards") or a Boolean (true for backwards).\n        function isDirectionBackward(dir) {\n            return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;\n        }\n\n        function getWindow(win, methodName) {\n            if (!win) {\n                return window;\n            } else if (dom.isWindow(win)) {\n                return win;\n            } else if (win instanceof WrappedSelection) {\n                return win.win;\n            } else {\n                var doc = dom.getContentDocument(win, module, methodName);\n                return dom.getWindow(doc);\n            }\n        }\n\n        function getWinSelection(winParam) {\n            return getWindow(winParam, "getWinSelection").getSelection();\n        }\n\n        function getDocSelection(winParam) {\n            return getWindow(winParam, "getDocSelection").document.selection;\n        }\n\n        function winSelectionIsBackward(sel) {\n            var backward = false;\n            if (sel.anchorNode) {\n                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);\n            }\n            return backward;\n        }\n\n        // Test for the Range/TextRange and Selection features required\n        // Test for ability to retrieve selection\n        var implementsWinGetSelection = isHostMethod(window, "getSelection"),\n            implementsDocSelection = util.isHostObject(document, "selection");\n\n        features.implementsWinGetSelection = implementsWinGetSelection;\n        features.implementsDocSelection = implementsDocSelection;\n\n        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n        if (useDocumentSelection) {\n            getNativeSelection = getDocSelection;\n            api.isSelectionValid = function(winParam) {\n                var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;\n\n                // Check whether the selection TextRange is actually contained within the correct document\n                return (nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc);\n            };\n        } else if (implementsWinGetSelection) {\n            getNativeSelection = getWinSelection;\n            api.isSelectionValid = function() {\n                return true;\n            };\n        } else {\n            module.fail("Neither document.selection or window.getSelection() detected.");\n            return false;\n        }\n\n        api.getNativeSelection = getNativeSelection;\n\n        var testSelection = getNativeSelection();\n\n        // In Firefox, the selection is null in an iframe with display: none. See issue #138.\n        if (!testSelection) {\n            module.fail("Native selection was null (possibly issue 138?)");\n            return false;\n        }\n\n        var testRange = api.createNativeRange(document);\n        var body = getBody(document);\n\n        // Obtaining a range from a selection\n        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,\n            ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);\n\n        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n        // Test for existence of native selection extend() method\n        var selectionHasExtend = isHostMethod(testSelection, "extend");\n        features.selectionHasExtend = selectionHasExtend;\n\n        // Test if rangeCount exists\n        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);\n        features.selectionHasRangeCount = selectionHasRangeCount;\n\n        var selectionSupportsMultipleRanges = false;\n        var collapsedNonEditableSelectionsSupported = true;\n\n        var addRangeBackwardToNative = selectionHasExtend ?\n            function(nativeSelection, range) {\n                var doc = DomRange.getRangeDocument(range);\n                var endRange = api.createRange(doc);\n                endRange.collapseToPoint(range.endContainer, range.endOffset);\n                nativeSelection.addRange(getNativeRange(endRange));\n                nativeSelection.extend(range.startContainer, range.startOffset);\n            } : null;\n\n        if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&\n                typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {\n\n            (function() {\n                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are\n                // performed on the current document\'s selection. See issue 109.\n\n                // Note also that if a selection previously existed, it is wiped and later restored by these tests. This\n                // will result in the selection direction begin reversed if the original selection was backwards and the\n                // browser does not support setting backwards selections (Internet Explorer, I\'m looking at you).\n                var sel = window.getSelection();\n                if (sel) {\n                    // Store the current selection\n                    var originalSelectionRangeCount = sel.rangeCount;\n                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);\n                    var originalSelectionRanges = [];\n                    var originalSelectionBackward = winSelectionIsBackward(sel);\n                    for (var i = 0; i < originalSelectionRangeCount; ++i) {\n                        originalSelectionRanges[i] = sel.getRangeAt(i);\n                    }\n\n                    // Create some test elements\n                    var testEl = dom.createTestElement(document, "", false);\n                    var textNode = testEl.appendChild( document.createTextNode("\\u00a0\\u00a0\\u00a0") );\n\n                    // Test whether the native selection will allow a collapsed selection within a non-editable element\n                    var r1 = document.createRange();\n\n                    r1.setStart(textNode, 1);\n                    r1.collapse(true);\n                    sel.removeAllRanges();\n                    sel.addRange(r1);\n                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);\n                    sel.removeAllRanges();\n\n                    // Test whether the native selection is capable of supporting multiple ranges.\n                    if (!selectionHasMultipleRanges) {\n                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a\n                        // console error of "Discontiguous selection is not supported." that cannot be suppressed. There\'s\n                        // nothing we can do about this while retaining the feature test so we have to resort to a browser\n                        // sniff. I\'m not happy about it. See\n                        // https://code.google.com/p/chromium/issues/detail?id=399791\n                        var chromeMatch = window.navigator.appVersion.match(/Chrome\\/(.*?) /);\n                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {\n                            selectionSupportsMultipleRanges = false;\n                        } else {\n                            var r2 = r1.cloneRange();\n                            r1.setStart(textNode, 0);\n                            r2.setEnd(textNode, 3);\n                            r2.setStart(textNode, 2);\n                            sel.addRange(r1);\n                            sel.addRange(r2);\n                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);\n                        }\n                    }\n\n                    // Clean up\n                    dom.removeNode(testEl);\n                    sel.removeAllRanges();\n\n                    for (i = 0; i < originalSelectionRangeCount; ++i) {\n                        if (i == 0 && originalSelectionBackward) {\n                            if (addRangeBackwardToNative) {\n                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);\n                            } else {\n                                api.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");\n                                sel.addRange(originalSelectionRanges[i]);\n                            }\n                        } else {\n                            sel.addRange(originalSelectionRanges[i]);\n                        }\n                    }\n                }\n            })();\n        }\n\n        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n        // ControlRanges\n        var implementsControlRange = false, testControlRange;\n\n        if (body && isHostMethod(body, "createControlRange")) {\n            testControlRange = body.createControlRange();\n            if (util.areHostProperties(testControlRange, ["item", "add"])) {\n                implementsControlRange = true;\n            }\n        }\n        features.implementsControlRange = implementsControlRange;\n\n        // Selection collapsedness\n        if (selectionHasAnchorAndFocus) {\n            selectionIsCollapsed = function(sel) {\n                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n            };\n        } else {\n            selectionIsCollapsed = function(sel) {\n                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n            };\n        }\n\n        function updateAnchorAndFocusFromRange(sel, range, backward) {\n            var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";\n            sel.anchorNode = range[anchorPrefix + "Container"];\n            sel.anchorOffset = range[anchorPrefix + "Offset"];\n            sel.focusNode = range[focusPrefix + "Container"];\n            sel.focusOffset = range[focusPrefix + "Offset"];\n        }\n\n        function updateAnchorAndFocusFromNativeSelection(sel) {\n            var nativeSel = sel.nativeSelection;\n            sel.anchorNode = nativeSel.anchorNode;\n            sel.anchorOffset = nativeSel.anchorOffset;\n            sel.focusNode = nativeSel.focusNode;\n            sel.focusOffset = nativeSel.focusOffset;\n        }\n\n        function updateEmptySelection(sel) {\n            sel.anchorNode = sel.focusNode = null;\n            sel.anchorOffset = sel.focusOffset = 0;\n            sel.rangeCount = 0;\n            sel.isCollapsed = true;\n            sel._ranges.length = 0;\n        }\n\n        function getNativeRange(range) {\n            var nativeRange;\n            if (range instanceof DomRange) {\n                nativeRange = api.createNativeRange(range.getDocument());\n                nativeRange.setEnd(range.endContainer, range.endOffset);\n                nativeRange.setStart(range.startContainer, range.startOffset);\n            } else if (range instanceof WrappedRange) {\n                nativeRange = range.nativeRange;\n            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {\n                nativeRange = range;\n            }\n            return nativeRange;\n        }\n\n        function rangeContainsSingleElement(rangeNodes) {\n            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n                return false;\n            }\n            for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function getSingleElementFromRange(range) {\n            var nodes = range.getNodes();\n            if (!rangeContainsSingleElement(nodes)) {\n                throw module.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");\n            }\n            return nodes[0];\n        }\n\n        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange\n        function isTextRange(range) {\n            return !!range && typeof range.text != "undefined";\n        }\n\n        function updateFromTextRange(sel, range) {\n            // Create a Range from the selected TextRange\n            var wrappedRange = new WrappedRange(range);\n            sel._ranges = [wrappedRange];\n\n            updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n            sel.rangeCount = 1;\n            sel.isCollapsed = wrappedRange.collapsed;\n        }\n\n        function updateControlSelection(sel) {\n            // Update the wrapped selection based on what\'s now in the native selection\n            sel._ranges.length = 0;\n            if (sel.docSelection.type == "None") {\n                updateEmptySelection(sel);\n            } else {\n                var controlRange = sel.docSelection.createRange();\n                if (isTextRange(controlRange)) {\n                    // This case (where the selection type is "Control" and calling createRange() on the selection returns\n                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n                    // ControlRange have been removed from the ControlRange and removed from the document.\n                    updateFromTextRange(sel, controlRange);\n                } else {\n                    sel.rangeCount = controlRange.length;\n                    var range, doc = getDocument(controlRange.item(0));\n                    for (var i = 0; i < sel.rangeCount; ++i) {\n                        range = api.createRange(doc);\n                        range.selectNode(controlRange.item(i));\n                        sel._ranges.push(range);\n                    }\n                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n                }\n            }\n        }\n\n        function addRangeToControlSelection(sel, range) {\n            var controlRange = sel.docSelection.createRange();\n            var rangeElement = getSingleElementFromRange(range);\n\n            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n            // contained by the supplied range\n            var doc = getDocument(controlRange.item(0));\n            var newControlRange = getBody(doc).createControlRange();\n            for (var i = 0, len = controlRange.length; i < len; ++i) {\n                newControlRange.add(controlRange.item(i));\n            }\n            try {\n                newControlRange.add(rangeElement);\n            } catch (ex) {\n                throw module.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");\n            }\n            newControlRange.select();\n\n            // Update the wrapped selection based on what\'s now in the native selection\n            updateControlSelection(sel);\n        }\n\n        var getSelectionRangeAt;\n\n        if (isHostMethod(testSelection, "getRangeAt")) {\n            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.\n            // Unfortunately, I didn\'t write a comment about the specifics and am now scared to take it out. Let that be a\n            // lesson to us all, especially me.\n            getSelectionRangeAt = function(sel, index) {\n                try {\n                    return sel.getRangeAt(index);\n                } catch (ex) {\n                    return null;\n                }\n            };\n        } else if (selectionHasAnchorAndFocus) {\n            getSelectionRangeAt = function(sel) {\n                var doc = getDocument(sel.anchorNode);\n                var range = api.createRange(doc);\n                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n\n                // Handle the case when the selection was selected backwards (from the end to the start in the\n                // document)\n                if (range.collapsed !== this.isCollapsed) {\n                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);\n                }\n\n                return range;\n            };\n        }\n\n        function WrappedSelection(selection, docSelection, win) {\n            this.nativeSelection = selection;\n            this.docSelection = docSelection;\n            this._ranges = [];\n            this.win = win;\n            this.refresh();\n        }\n\n        WrappedSelection.prototype = api.selectionPrototype;\n\n        function deleteProperties(sel) {\n            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;\n            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;\n            sel.detached = true;\n        }\n\n        var cachedRangySelections = [];\n\n        function actOnCachedSelection(win, action) {\n            var i = cachedRangySelections.length, cached, sel;\n            while (i--) {\n                cached = cachedRangySelections[i];\n                sel = cached.selection;\n                if (action == "deleteAll") {\n                    deleteProperties(sel);\n                } else if (cached.win == win) {\n                    if (action == "delete") {\n                        cachedRangySelections.splice(i, 1);\n                        return true;\n                    } else {\n                        return sel;\n                    }\n                }\n            }\n            if (action == "deleteAll") {\n                cachedRangySelections.length = 0;\n            }\n            return null;\n        }\n\n        var getSelection = function(win) {\n            // Check if the parameter is a Rangy Selection object\n            if (win && win instanceof WrappedSelection) {\n                win.refresh();\n                return win;\n            }\n\n            win = getWindow(win, "getNativeSelection");\n\n            var sel = actOnCachedSelection(win);\n            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;\n            if (sel) {\n                sel.nativeSelection = nativeSel;\n                sel.docSelection = docSel;\n                sel.refresh();\n            } else {\n                sel = new WrappedSelection(nativeSel, docSel, win);\n                cachedRangySelections.push( { win: win, selection: sel } );\n            }\n            return sel;\n        };\n\n        api.getSelection = getSelection;\n\n        util.createAliasForDeprecatedMethod(api, "getIframeSelection", "getSelection");\n\n        var selProto = WrappedSelection.prototype;\n\n        function createControlSelection(sel, ranges) {\n            // Ensure that the selection becomes of type "Control"\n            var doc = getDocument(ranges[0].startContainer);\n            var controlRange = getBody(doc).createControlRange();\n            for (var i = 0, el, len = ranges.length; i < len; ++i) {\n                el = getSingleElementFromRange(ranges[i]);\n                try {\n                    controlRange.add(el);\n                } catch (ex) {\n                    throw module.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");\n                }\n            }\n            controlRange.select();\n\n            // Update the wrapped selection based on what\'s now in the native selection\n            updateControlSelection(sel);\n        }\n\n        // Selecting a range\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {\n            selProto.removeAllRanges = function() {\n                this.nativeSelection.removeAllRanges();\n                updateEmptySelection(this);\n            };\n\n            var addRangeBackward = function(sel, range) {\n                addRangeBackwardToNative(sel.nativeSelection, range);\n                sel.refresh();\n            };\n\n            if (selectionHasRangeCount) {\n                selProto.addRange = function(range, direction) {\n                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                        addRangeToControlSelection(this, range);\n                    } else {\n                        if (isDirectionBackward(direction) && selectionHasExtend) {\n                            addRangeBackward(this, range);\n                        } else {\n                            var previousRangeCount;\n                            if (selectionSupportsMultipleRanges) {\n                                previousRangeCount = this.rangeCount;\n                            } else {\n                                this.removeAllRanges();\n                                previousRangeCount = 0;\n                            }\n                            // Clone the native range so that changing the selected range does not affect the selection.\n                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See\n                            // issue 80.\n                            var clonedNativeRange = getNativeRange(range).cloneRange();\n                            try {\n                                this.nativeSelection.addRange(clonedNativeRange);\n                            } catch (ex) {\n                            }\n\n                            // Check whether adding the range was successful\n                            this.rangeCount = this.nativeSelection.rangeCount;\n\n                            if (this.rangeCount == previousRangeCount + 1) {\n                                // The range was added successfully\n\n                                // Check whether the range that we added to the selection is reflected in the last range extracted from\n                                // the selection\n                                if (api.config.checkSelectionRanges) {\n                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                                    if (nativeRange && !rangesEqual(nativeRange, range)) {\n                                        // Happens in WebKit with, for example, a selection placed at the start of a text node\n                                        range = new WrappedRange(nativeRange);\n                                    }\n                                }\n                                this._ranges[this.rangeCount - 1] = range;\n                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));\n                                this.isCollapsed = selectionIsCollapsed(this);\n                            } else {\n                                // The range was not added successfully. The simplest thing is to refresh\n                                this.refresh();\n                            }\n                        }\n                    }\n                };\n            } else {\n                selProto.addRange = function(range, direction) {\n                    if (isDirectionBackward(direction) && selectionHasExtend) {\n                        addRangeBackward(this, range);\n                    } else {\n                        this.nativeSelection.addRange(getNativeRange(range));\n                        this.refresh();\n                    }\n                };\n            }\n\n            selProto.setRanges = function(ranges) {\n                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {\n                    createControlSelection(this, ranges);\n                } else {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        this.addRange(ranges[i]);\n                    }\n                }\n            };\n        } else if (isHostMethod(testSelection, "empty") && isHostMethod(testRange, "select") &&\n                   implementsControlRange && useDocumentSelection) {\n\n            selProto.removeAllRanges = function() {\n                // Added try/catch as fix for issue #21\n                try {\n                    this.docSelection.empty();\n\n                    // Check for empty() not working (issue #24)\n                    if (this.docSelection.type != "None") {\n                        // Work around failure to empty a control selection by instead selecting a TextRange and then\n                        // calling empty()\n                        var doc;\n                        if (this.anchorNode) {\n                            doc = getDocument(this.anchorNode);\n                        } else if (this.docSelection.type == CONTROL) {\n                            var controlRange = this.docSelection.createRange();\n                            if (controlRange.length) {\n                                doc = getDocument( controlRange.item(0) );\n                            }\n                        }\n                        if (doc) {\n                            var textRange = getBody(doc).createTextRange();\n                            textRange.select();\n                            this.docSelection.empty();\n                        }\n                    }\n                } catch(ex) {}\n                updateEmptySelection(this);\n            };\n\n            selProto.addRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    addRangeToControlSelection(this, range);\n                } else {\n                    api.WrappedTextRange.rangeToTextRange(range).select();\n                    this._ranges[0] = range;\n                    this.rangeCount = 1;\n                    this.isCollapsed = this._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(this, range, false);\n                }\n            };\n\n            selProto.setRanges = function(ranges) {\n                this.removeAllRanges();\n                var rangeCount = ranges.length;\n                if (rangeCount > 1) {\n                    createControlSelection(this, ranges);\n                } else if (rangeCount) {\n                    this.addRange(ranges[0]);\n                }\n            };\n        } else {\n            module.fail("No means of selecting a Range or TextRange was found");\n            return false;\n        }\n\n        selProto.getRangeAt = function(index) {\n            if (index < 0 || index >= this.rangeCount) {\n                throw new DOMException("INDEX_SIZE_ERR");\n            } else {\n                // Clone the range to preserve selection-range independence. See issue 80.\n                return this._ranges[index].cloneRange();\n            }\n        };\n\n        var refreshSelection;\n\n        if (useDocumentSelection) {\n            refreshSelection = function(sel) {\n                var range;\n                if (api.isSelectionValid(sel.win)) {\n                    range = sel.docSelection.createRange();\n                } else {\n                    range = getBody(sel.win.document).createTextRange();\n                    range.collapse(true);\n                }\n\n                if (sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else if (isTextRange(range)) {\n                    updateFromTextRange(sel, range);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {\n            refreshSelection = function(sel) {\n                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else {\n                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n                    if (sel.rangeCount) {\n                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n                        }\n                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));\n                        sel.isCollapsed = selectionIsCollapsed(sel);\n                    } else {\n                        updateEmptySelection(sel);\n                    }\n                }\n            };\n        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {\n            refreshSelection = function(sel) {\n                var range, nativeSel = sel.nativeSelection;\n                if (nativeSel.anchorNode) {\n                    range = getSelectionRangeAt(nativeSel, 0);\n                    sel._ranges = [range];\n                    sel.rangeCount = 1;\n                    updateAnchorAndFocusFromNativeSelection(sel);\n                    sel.isCollapsed = selectionIsCollapsed(sel);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else {\n            module.fail("No means of obtaining a Range or TextRange from the user\'s selection was found");\n            return false;\n        }\n\n        selProto.refresh = function(checkForChanges) {\n            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;\n\n            refreshSelection(this);\n            if (checkForChanges) {\n                // Check the range count first\n                var i = oldRanges.length;\n                if (i != this._ranges.length) {\n                    return true;\n                }\n\n                // Now check the direction. Checking the anchor position is the same is enough since we\'re checking all the\n                // ranges after this\n                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {\n                    return true;\n                }\n\n                // Finally, compare each range in turn\n                while (i--) {\n                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n\n        // Removal of a single range\n        var removeRangeManually = function(sel, range) {\n            var ranges = sel.getAllRanges();\n            sel.removeAllRanges();\n            for (var i = 0, len = ranges.length; i < len; ++i) {\n                if (!rangesEqual(range, ranges[i])) {\n                    sel.addRange(ranges[i]);\n                }\n            }\n            if (!sel.rangeCount) {\n                updateEmptySelection(sel);\n            }\n        };\n\n        if (implementsControlRange && implementsDocSelection) {\n            selProto.removeRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    var controlRange = this.docSelection.createRange();\n                    var rangeElement = getSingleElementFromRange(range);\n\n                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n                    // element contained by the supplied range\n                    var doc = getDocument(controlRange.item(0));\n                    var newControlRange = getBody(doc).createControlRange();\n                    var el, removed = false;\n                    for (var i = 0, len = controlRange.length; i < len; ++i) {\n                        el = controlRange.item(i);\n                        if (el !== rangeElement || removed) {\n                            newControlRange.add(controlRange.item(i));\n                        } else {\n                            removed = true;\n                        }\n                    }\n                    newControlRange.select();\n\n                    // Update the wrapped selection based on what\'s now in the native selection\n                    updateControlSelection(this);\n                } else {\n                    removeRangeManually(this, range);\n                }\n            };\n        } else {\n            selProto.removeRange = function(range) {\n                removeRangeManually(this, range);\n            };\n        }\n\n        // Detecting if a selection is backward\n        var selectionIsBackward;\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {\n            selectionIsBackward = winSelectionIsBackward;\n\n            selProto.isBackward = function() {\n                return selectionIsBackward(this);\n            };\n        } else {\n            selectionIsBackward = selProto.isBackward = function() {\n                return false;\n            };\n        }\n\n        // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"\n        selProto.isBackwards = selProto.isBackward;\n\n        // Selection stringifier\n        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla\'s implementation.\n        // The current spec does not yet define this method.\n        selProto.toString = function() {\n            var rangeTexts = [];\n            for (var i = 0, len = this.rangeCount; i < len; ++i) {\n                rangeTexts[i] = "" + this._ranges[i];\n            }\n            return rangeTexts.join("");\n        };\n\n        function assertNodeInSameDocument(sel, node) {\n            if (sel.win.document != getDocument(node)) {\n                throw new DOMException("WRONG_DOCUMENT_ERR");\n            }\n        }\n\n        // No current browser conforms fully to the spec for this method, so Rangy\'s own method is always used\n        selProto.collapse = function(node, offset) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.collapseToPoint(node, offset);\n            this.setSingleRange(range);\n            this.isCollapsed = true;\n        };\n\n        selProto.collapseToStart = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[0];\n                this.collapse(range.startContainer, range.startOffset);\n            } else {\n                throw new DOMException("INVALID_STATE_ERR");\n            }\n        };\n\n        selProto.collapseToEnd = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[this.rangeCount - 1];\n                this.collapse(range.endContainer, range.endOffset);\n            } else {\n                throw new DOMException("INVALID_STATE_ERR");\n            }\n        };\n\n        // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as\n        // specified so the native implementation is never used by Rangy.\n        selProto.selectAllChildren = function(node) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.selectNodeContents(node);\n            this.setSingleRange(range);\n        };\n\n        selProto.deleteFromDocument = function() {\n            // Sepcial behaviour required for IE\'s control selections\n            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                var controlRange = this.docSelection.createRange();\n                var element;\n                while (controlRange.length) {\n                    element = controlRange.item(0);\n                    controlRange.remove(element);\n                    dom.removeNode(element);\n                }\n                this.refresh();\n            } else if (this.rangeCount) {\n                var ranges = this.getAllRanges();\n                if (ranges.length) {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        ranges[i].deleteContents();\n                    }\n                    // The spec says nothing about what the selection should contain after calling deleteContents on each\n                    // range. Firefox moves the selection to where the final selected range was, so we emulate that\n                    this.addRange(ranges[len - 1]);\n                }\n            }\n        };\n\n        // The following are non-standard extensions\n        selProto.eachRange = function(func, returnValue) {\n            for (var i = 0, len = this._ranges.length; i < len; ++i) {\n                if ( func( this.getRangeAt(i) ) ) {\n                    return returnValue;\n                }\n            }\n        };\n\n        selProto.getAllRanges = function() {\n            var ranges = [];\n            this.eachRange(function(range) {\n                ranges.push(range);\n            });\n            return ranges;\n        };\n\n        selProto.setSingleRange = function(range, direction) {\n            this.removeAllRanges();\n            this.addRange(range, direction);\n        };\n\n        selProto.callMethodOnEachRange = function(methodName, params) {\n            var results = [];\n            this.eachRange( function(range) {\n                results.push( range[methodName].apply(range, params || []) );\n            } );\n            return results;\n        };\n\n        function createStartOrEndSetter(isStart) {\n            return function(node, offset) {\n                var range;\n                if (this.rangeCount) {\n                    range = this.getRangeAt(0);\n                    range["set" + (isStart ? "Start" : "End")](node, offset);\n                } else {\n                    range = api.createRange(this.win.document);\n                    range.setStartAndEnd(node, offset);\n                }\n                this.setSingleRange(range, this.isBackward());\n            };\n        }\n\n        selProto.setStart = createStartOrEndSetter(true);\n        selProto.setEnd = createStartOrEndSetter(false);\n\n        // Add select() method to Range prototype. Any existing selection will be removed.\n        api.rangePrototype.select = function(direction) {\n            getSelection( this.getDocument() ).setSingleRange(this, direction);\n        };\n\n        selProto.changeEachRange = function(func) {\n            var ranges = [];\n            var backward = this.isBackward();\n\n            this.eachRange(function(range) {\n                func(range);\n                ranges.push(range);\n            });\n\n            this.removeAllRanges();\n            if (backward && ranges.length == 1) {\n                this.addRange(ranges[0], "backward");\n            } else {\n                this.setRanges(ranges);\n            }\n        };\n\n        selProto.containsNode = function(node, allowPartial) {\n            return this.eachRange( function(range) {\n                return range.containsNode(node, allowPartial);\n            }, true ) || false;\n        };\n\n        selProto.getBookmark = function(containerNode) {\n            return {\n                backward: this.isBackward(),\n                rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])\n            };\n        };\n\n        selProto.moveToBookmark = function(bookmark) {\n            var selRanges = [];\n            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {\n                range = api.createRange(this.win);\n                range.moveToBookmark(rangeBookmark);\n                selRanges.push(range);\n            }\n            if (bookmark.backward) {\n                this.setSingleRange(selRanges[0], "backward");\n            } else {\n                this.setRanges(selRanges);\n            }\n        };\n\n        selProto.saveRanges = function() {\n            return {\n                backward: this.isBackward(),\n                ranges: this.callMethodOnEachRange("cloneRange")\n            };\n        };\n\n        selProto.restoreRanges = function(selRanges) {\n            this.removeAllRanges();\n            for (var i = 0, range; range = selRanges.ranges[i]; ++i) {\n                this.addRange(range, (selRanges.backward && i == 0));\n            }\n        };\n\n        selProto.toHtml = function() {\n            var rangeHtmls = [];\n            this.eachRange(function(range) {\n                rangeHtmls.push( DomRange.toHtml(range) );\n            });\n            return rangeHtmls.join("");\n        };\n\n        if (features.implementsTextRange) {\n            selProto.getNativeTextRange = function() {\n                var sel, textRange;\n                if ( (sel = this.docSelection) ) {\n                    var range = sel.createRange();\n                    if (isTextRange(range)) {\n                        return range;\n                    } else {\n                        throw module.createError("getNativeTextRange: selection is a control selection");\n                    }\n                } else if (this.rangeCount > 0) {\n                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );\n                } else {\n                    throw module.createError("getNativeTextRange: selection contains no range");\n                }\n            };\n        }\n\n        function inspect(sel) {\n            var rangeInspects = [];\n            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n            var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n            var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";\n\n            if (typeof sel.rangeCount != "undefined") {\n                for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n                }\n            }\n            return "[" + name + "(Ranges: " + rangeInspects.join(", ") +\n                    ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";\n        }\n\n        selProto.getName = function() {\n            return "WrappedSelection";\n        };\n\n        selProto.inspect = function() {\n            return inspect(this);\n        };\n\n        selProto.detach = function() {\n            actOnCachedSelection(this.win, "delete");\n            deleteProperties(this);\n        };\n\n        WrappedSelection.detachAll = function() {\n            actOnCachedSelection(null, "deleteAll");\n        };\n\n        WrappedSelection.inspect = inspect;\n        WrappedSelection.isDirectionBackward = isDirectionBackward;\n\n        api.Selection = WrappedSelection;\n\n        api.selectionPrototype = selProto;\n\n        api.addShimListener(function(win) {\n            if (typeof win.getSelection == "undefined") {\n                win.getSelection = function() {\n                    return getSelection(win);\n                };\n            }\n            win = null;\n        });\n    });\n    \n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wait for document to load before initializing\n    var docReady = false;\n\n    var loadHandler = function(e) {\n        if (!docReady) {\n            docReady = true;\n            if (!api.initialized && api.config.autoInitialize) {\n                init();\n            }\n        }\n    };\n\n    if (isBrowser) {\n        // Test whether the document has already been loaded and initialize immediately if so\n        if (document.readyState == "complete") {\n            loadHandler();\n        } else {\n            if (isHostMethod(document, "addEventListener")) {\n                document.addEventListener("DOMContentLoaded", loadHandler, false);\n            }\n\n            // Add a fallback in case the DOMContentLoaded event isn\'t supported\n            addListener(window, "load", loadHandler);\n        }\n    }\n\n    return api;\n}, this);'},184:function(t,n,e){e(1)(e(185))},185:function(t,n){t.exports="/* Hallo 1.1.1 - rich text editor for jQuery UI\n* by Henri Bergius and contributors. Available under the MIT license.\n* See http://hallojs.org for more information\n*/(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.hallo', {\n      toolbar: null,\n      bound: false,\n      originalContent: '',\n      previousContent: '',\n      uuid: '',\n      selection: null,\n      _keepActivated: false,\n      originalHref: null,\n      options: {\n        editable: true,\n        plugins: {},\n        toolbar: 'halloToolbarContextual',\n        parentElement: 'body',\n        buttonCssClass: null,\n        toolbarCssClass: null,\n        toolbarPositionAbove: false,\n        toolbarOptions: {},\n        placeholder: '',\n        forceStructured: true,\n        checkTouch: true,\n        touchScreen: null\n      },\n      _create: function() {\n        var options, plugin, _ref,\n          _this = this;\n        this.id = this._generateUUID();\n        if (this.options.checkTouch && this.options.touchScreen === null) {\n          this.checkTouch();\n        }\n        _ref = this.options.plugins;\n        for (plugin in _ref) {\n          options = _ref[plugin];\n          if (!jQuery.isPlainObject(options)) {\n            options = {};\n          }\n          jQuery.extend(options, {\n            editable: this,\n            uuid: this.id,\n            buttonCssClass: this.options.buttonCssClass\n          });\n          jQuery(this.element)[plugin](options);\n        }\n        this.element.one('halloactivated', function() {\n          return _this._prepareToolbar();\n        });\n        return this.originalContent = this.getContents();\n      },\n      _init: function() {\n        if (this.options.editable) {\n          return this.enable();\n        } else {\n          return this.disable();\n        }\n      },\n      destroy: function() {\n        var options, plugin, _ref;\n        this.disable();\n        if (this.toolbar) {\n          this.toolbar.remove();\n          this.element[this.options.toolbar]('destroy');\n        }\n        _ref = this.options.plugins;\n        for (plugin in _ref) {\n          options = _ref[plugin];\n          jQuery(this.element)[plugin]('destroy');\n        }\n        return jQuery.Widget.prototype.destroy.call(this);\n      },\n      disable: function() {\n        var _this = this;\n        this.element.attr(\"contentEditable\", false);\n        this.element.off(\"focus\", this._activated);\n        this.element.off(\"blur\", this._deactivated);\n        this.element.off(\"keyup paste change\", this._checkModified);\n        this.element.off(\"keyup\", this._keys);\n        this.element.off(\"keyup mouseup\", this._checkSelection);\n        this.bound = false;\n        jQuery(this.element).removeClass('isModified');\n        jQuery(this.element).removeClass('inEditMode');\n        this.element.parents('a').addBack().each(function(idx, elem) {\n          var element;\n          element = jQuery(elem);\n          if (!element.is('a')) {\n            return;\n          }\n          if (!_this.originalHref) {\n            return;\n          }\n          return element.attr('href', _this.originalHref);\n        });\n        return this._trigger(\"disabled\", null);\n      },\n      enable: function() {\n        var _this = this;\n        this.element.parents('a[href]').addBack().each(function(idx, elem) {\n          var element;\n          element = jQuery(elem);\n          if (!element.is('a[href]')) {\n            return;\n          }\n          _this.originalHref = element.attr('href');\n          return element.removeAttr('href');\n        });\n        this.element.attr(\"contentEditable\", true);\n        if (!jQuery.parseHTML(this.element.html())) {\n          this.element.html(this.options.placeholder);\n          jQuery(this.element).addClass('inPlaceholderMode');\n          this.element.css({\n            'min-width': this.element.innerWidth(),\n            'min-height': this.element.innerHeight()\n          });\n        }\n        if (!this.bound) {\n          this.element.on(\"focus\", this, this._activated);\n          this.element.on(\"blur\", this, this._deactivated);\n          this.element.on(\"keyup paste change\", this, this._checkModified);\n          this.element.on(\"keyup\", this, this._keys);\n          this.element.on(\"keyup mouseup\", this, this._checkSelection);\n          this.bound = true;\n        }\n        if (this.options.forceStructured) {\n          this._forceStructured();\n        }\n        return this._trigger(\"enabled\", null);\n      },\n      activate: function() {\n        return this.element.focus();\n      },\n      containsSelection: function() {\n        var range;\n        range = this.getSelection();\n        return this.element.has(range.startContainer).length > 0;\n      },\n      getSelection: function() {\n        var range, sel;\n        sel = rangy.getSelection();\n        range = null;\n        if (sel.rangeCount > 0) {\n          range = sel.getRangeAt(0);\n        } else {\n          range = rangy.createRange();\n        }\n        return range;\n      },\n      restoreSelection: function(range) {\n        var sel;\n        sel = rangy.getSelection();\n        return sel.setSingleRange(range);\n      },\n      replaceSelection: function(cb) {\n        var newTextNode, r, range, sel, t;\n        if (navigator.appName === 'Microsoft Internet Explorer') {\n          t = document.selection.createRange().text;\n          r = document.selection.createRange();\n          return r.pasteHTML(cb(t));\n        } else {\n          sel = window.getSelection();\n          range = sel.getRangeAt(0);\n          newTextNode = document.createTextNode(cb(range.extractContents()));\n          range.insertNode(newTextNode);\n          range.setStartAfter(newTextNode);\n          sel.removeAllRanges();\n          return sel.addRange(range);\n        }\n      },\n      removeAllSelections: function() {\n        if (navigator.appName === 'Microsoft Internet Explorer') {\n          return range.empty();\n        } else {\n          return window.getSelection().removeAllRanges();\n        }\n      },\n      getPluginInstance: function(plugin) {\n        var instance;\n        instance = jQuery(this.element).data(\"IKS-\" + plugin);\n        if (instance) {\n          return instance;\n        }\n        instance = jQuery(this.element).data(plugin);\n        if (instance) {\n          return instance;\n        }\n        throw new Error(\"Plugin \" + plugin + \" not found\");\n      },\n      getContents: function() {\n        var cleanup, instance, plugin;\n        for (plugin in this.options.plugins) {\n          instance = this.getPluginInstance(plugin);\n          if (!instance) {\n            continue;\n          }\n          cleanup = instance.cleanupContentClone;\n          if (!jQuery.isFunction(cleanup)) {\n            continue;\n          }\n          jQuery(this.element)[plugin]('cleanupContentClone', this.element);\n        }\n        return this.element.html();\n      },\n      setContents: function(contents) {\n        return this.element.html(contents);\n      },\n      isModified: function() {\n        if (!this.previousContent) {\n          this.previousContent = this.originalContent;\n        }\n        return this.previousContent !== this.getContents();\n      },\n      setUnmodified: function() {\n        jQuery(this.element).removeClass('isModified');\n        return this.previousContent = this.getContents();\n      },\n      setModified: function() {\n        jQuery(this.element).addClass('isModified');\n        return this._trigger('modified', null, {\n          editable: this,\n          content: this.getContents()\n        });\n      },\n      restoreOriginalContent: function() {\n        return this.element.html(this.originalContent);\n      },\n      execute: function(command, value) {\n        if (document.execCommand(command, false, value)) {\n          return this.element.trigger(\"change\");\n        }\n      },\n      protectFocusFrom: function(el) {\n        var _this = this;\n        return el.on(\"mousedown\", function(event) {\n          event.preventDefault();\n          _this._protectToolbarFocus = true;\n          return setTimeout(function() {\n            return _this._protectToolbarFocus = false;\n          }, 300);\n        });\n      },\n      keepActivated: function(_keepActivated) {\n        this._keepActivated = _keepActivated;\n      },\n      _generateUUID: function() {\n        var S4;\n        S4 = function() {\n          return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);\n        };\n        return \"\" + (S4()) + (S4()) + \"-\" + (S4()) + \"-\" + (S4()) + \"-\" + (S4()) + \"-\" + (S4()) + (S4()) + (S4());\n      },\n      _prepareToolbar: function() {\n        var defaults, instance, plugin, populate, toolbarOptions;\n        this.toolbar = jQuery('<div class=\"hallotoolbar\"></div>').hide();\n        if (this.options.toolbarCssClass) {\n          this.toolbar.addClass(this.options.toolbarCssClass);\n        }\n        defaults = {\n          editable: this,\n          parentElement: this.options.parentElement,\n          toolbar: this.toolbar,\n          positionAbove: this.options.toolbarPositionAbove\n        };\n        toolbarOptions = jQuery.extend({}, defaults, this.options.toolbarOptions);\n        this.element[this.options.toolbar](toolbarOptions);\n        for (plugin in this.options.plugins) {\n          instance = this.getPluginInstance(plugin);\n          if (!instance) {\n            continue;\n          }\n          populate = instance.populateToolbar;\n          if (!jQuery.isFunction(populate)) {\n            continue;\n          }\n          this.element[plugin]('populateToolbar', this.toolbar);\n        }\n        this.element[this.options.toolbar]('setPosition');\n        return this.protectFocusFrom(this.toolbar);\n      },\n      changeToolbar: function(element, toolbar, hide) {\n        var originalToolbar;\n        if (hide == null) {\n          hide = false;\n        }\n        originalToolbar = this.options.toolbar;\n        this.options.parentElement = element;\n        if (toolbar) {\n          this.options.toolbar = toolbar;\n        }\n        if (!this.toolbar) {\n          return;\n        }\n        this.element[originalToolbar]('destroy');\n        this.toolbar.remove();\n        this._prepareToolbar();\n        if (hide) {\n          return this.toolbar.hide();\n        }\n      },\n      _checkModified: function(event) {\n        var widget;\n        widget = event.data;\n        if (widget.isModified()) {\n          return widget.setModified();\n        }\n      },\n      _keys: function(event) {\n        var old, widget;\n        widget = event.data;\n        if (event.keyCode === 27) {\n          old = widget.getContents();\n          widget.restoreOriginalContent(event);\n          widget._trigger(\"restored\", null, {\n            editable: widget,\n            content: widget.getContents(),\n            thrown: old\n          });\n          return widget.turnOff();\n        }\n      },\n      _rangesEqual: function(r1, r2) {\n        if (r1.startContainer !== r2.startContainer) {\n          return false;\n        }\n        if (r1.startOffset !== r2.startOffset) {\n          return false;\n        }\n        if (r1.endContainer !== r2.endContainer) {\n          return false;\n        }\n        if (r1.endOffset !== r2.endOffset) {\n          return false;\n        }\n        return true;\n      },\n      _checkSelection: function(event) {\n        var widget;\n        if (event.keyCode === 27) {\n          return;\n        }\n        widget = event.data;\n        return setTimeout(function() {\n          var sel;\n          sel = widget.getSelection();\n          if (widget._isEmptySelection(sel) || widget._isEmptyRange(sel)) {\n            if (widget.selection) {\n              widget.selection = null;\n              widget._trigger(\"unselected\", null, {\n                editable: widget,\n                originalEvent: event\n              });\n            }\n            return;\n          }\n          if (!widget.selection || !widget._rangesEqual(sel, widget.selection)) {\n            widget.selection = sel.cloneRange();\n            return widget._trigger(\"selected\", null, {\n              editable: widget,\n              selection: widget.selection,\n              ranges: [widget.selection],\n              originalEvent: event\n            });\n          }\n        }, 0);\n      },\n      _isEmptySelection: function(selection) {\n        if (selection.type === \"Caret\") {\n          return true;\n        }\n        return false;\n      },\n      _isEmptyRange: function(range) {\n        if (range.collapsed) {\n          return true;\n        }\n        if (range.isCollapsed) {\n          if (typeof range.isCollapsed === 'function') {\n            return range.isCollapsed();\n          }\n          return range.isCollapsed;\n        }\n        return false;\n      },\n      turnOn: function() {\n        if (this.getContents() === this.options.placeholder) {\n          this.setContents('');\n        }\n        jQuery(this.element).removeClass('inPlaceholderMode');\n        jQuery(this.element).addClass('inEditMode');\n        return this._trigger(\"activated\", null, this);\n      },\n      turnOff: function() {\n        jQuery(this.element).removeClass('inEditMode');\n        this._trigger(\"deactivated\", null, this);\n        if (!this.getContents()) {\n          jQuery(this.element).addClass('inPlaceholderMode');\n          return this.setContents(this.options.placeholder);\n        }\n      },\n      _activated: function(event) {\n        return event.data.turnOn();\n      },\n      _deactivated: function(event) {\n        if (event.data._keepActivated) {\n          return;\n        }\n        if (event.data._protectToolbarFocus !== true) {\n          return event.data.turnOff();\n        } else {\n          return setTimeout(function() {\n            return jQuery(event.data.element).focus();\n          }, 300);\n        }\n      },\n      _forceStructured: function(event) {\n        var e;\n        try {\n          return document.execCommand('styleWithCSS', 0, false);\n        } catch (_error) {\n          e = _error;\n          try {\n            return document.execCommand('useCSS', 0, true);\n          } catch (_error) {\n            e = _error;\n            try {\n              return document.execCommand('styleWithCSS', false, false);\n            } catch (_error) {\n              e = _error;\n            }\n          }\n        }\n      },\n      checkTouch: function() {\n        return this.options.touchScreen = !!('createTouch' in document);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    var z;\n    z = null;\n    if (this.VIE !== void 0) {\n      z = new VIE;\n      z.use(new z.StanbolService({\n        proxyDisabled: true,\n        url: 'http://dev.iks-project.eu:8081'\n      }));\n    }\n    return jQuery.widget('IKS.halloannotate', {\n      options: {\n        vie: z,\n        editable: null,\n        toolbar: null,\n        uuid: '',\n        select: function() {},\n        decline: function() {},\n        remove: function() {},\n        buttonCssClass: null\n      },\n      _create: function() {\n        var editableElement, turnOffAnnotate, widget;\n        widget = this;\n        if (this.options.vie === void 0) {\n          throw new Error('The halloannotate plugin requires VIE');\n          return;\n        }\n        if (typeof this.element.annotate !== 'function') {\n          throw new Error('The halloannotate plugin requires annotate.js');\n          return;\n        }\n        this.state = 'off';\n        this.instantiate();\n        turnOffAnnotate = function() {\n          var editable;\n          editable = this;\n          return jQuery(editable).halloannotate('turnOff');\n        };\n        editableElement = this.options.editable.element;\n        return editableElement.on('hallodisabled', turnOffAnnotate);\n      },\n      populateToolbar: function(toolbar) {\n        var buttonHolder,\n          _this = this;\n        buttonHolder = jQuery(\"<span class=\\\"\" + this.widgetName + \"\\\"></span>\");\n        this.button = buttonHolder.hallobutton({\n          label: 'Annotate',\n          icon: 'fa-tags',\n          editable: this.options.editable,\n          command: null,\n          uuid: this.options.uuid,\n          cssClass: this.options.buttonCssClass,\n          queryState: false\n        });\n        buttonHolder.on('change', function(event) {\n          if (_this.state === \"pending\") {\n            return;\n          }\n          if (_this.state === \"off\") {\n            return _this.turnOn();\n          }\n          return _this.turnOff();\n        });\n        buttonHolder.buttonset();\n        return toolbar.append(this.button);\n      },\n      cleanupContentClone: function(el) {\n        if (this.state === 'on') {\n          return el.find(\".entity:not([about])\").each(function() {\n            return jQuery(this).replaceWith(jQuery(this).html());\n          });\n        }\n      },\n      instantiate: function() {\n        var widget;\n        widget = this;\n        return this.options.editable.element.annotate({\n          vie: this.options.vie,\n          debug: false,\n          showTooltip: true,\n          select: this.options.select,\n          remove: this.options.remove,\n          success: this.options.success,\n          error: this.options.error\n        }).on('annotateselect', function(event, data) {\n          return widget.options.editable.setModified();\n        }).on('annotateremove', function() {\n          return jQuery.noop();\n        });\n      },\n      turnPending: function() {\n        this.state = 'pending';\n        this.button.hallobutton('checked', false);\n        return this.button.hallobutton('disable');\n      },\n      turnOn: function() {\n        var e, widget,\n          _this = this;\n        this.turnPending();\n        widget = this;\n        try {\n          return this.options.editable.element.annotate('enable', function(success) {\n            if (!success) {\n              return;\n            }\n            _this.state = 'on';\n            _this.button.hallobutton('checked', true);\n            return _this.button.hallobutton('enable');\n          });\n        } catch (_error) {\n          e = _error;\n          return alert(e);\n        }\n      },\n      turnOff: function() {\n        this.options.editable.element.annotate('disable');\n        this.state = 'off';\n        if (!this.button) {\n          return;\n        }\n        this.button.attr('checked', false);\n        this.button.find(\"label\").removeClass(\"ui-state-clicked\");\n        return this.button.button('refresh');\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloblacklist', {\n      options: {\n        tags: []\n      },\n      _init: function() {\n        if (this.options.tags.indexOf('br') !== -1) {\n          return this.element.on('keydown', function(event) {\n            if (event.originalEvent.keyCode === 13) {\n              return event.preventDefault();\n            }\n          });\n        }\n      },\n      cleanupContentClone: function(el) {\n        var tag, _i, _len, _ref, _results;\n        _ref = this.options.tags;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          tag = _ref[_i];\n          _results.push(jQuery(tag, el).remove());\n        }\n        return _results;\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloblock', {\n      options: {\n        editable: null,\n        toolbar: null,\n        uuid: '',\n        elements: ['h1', 'h2', 'h3', 'p', 'pre', 'blockquote'],\n        buttonCssClass: null\n      },\n      populateToolbar: function(toolbar) {\n        var buttonset, contentId, target;\n        buttonset = jQuery(\"<span class=\\\"\" + this.widgetName + \"\\\"></span>\");\n        contentId = \"\" + this.options.uuid + \"-\" + this.widgetName + \"-data\";\n        target = this._prepareDropdown(contentId);\n        toolbar.append(buttonset);\n        buttonset.hallobuttonset();\n        buttonset.append(target);\n        return buttonset.append(this._prepareButton(target));\n      },\n      _prepareDropdown: function(contentId) {\n        var addElement, containingElement, contentArea, element, _i, _len, _ref,\n          _this = this;\n        contentArea = jQuery(\"<div id=\\\"\" + contentId + \"\\\"></div>\");\n        containingElement = this.options.editable.element.get(0).tagName.toLowerCase();\n        addElement = function(element) {\n          var el, events, queryState;\n          el = jQuery(\"<button class='blockselector'>          <\" + element + \" class=\\\"menu-item\\\">\" + element + \"</\" + element + \">        </button>\");\n          if (containingElement === element) {\n            el.addClass('selected');\n          }\n          if (containingElement !== 'div') {\n            el.addClass('disabled');\n          }\n          el.on('click', function() {\n            var tagName;\n            tagName = element.toUpperCase();\n            if (el.hasClass('disabled')) {\n              return;\n            }\n            if (navigator.appName === 'Microsoft Internet Explorer') {\n              _this.options.editable.execute('FormatBlock', \"<\" + tagName + \">\");\n              return;\n            }\n            return _this.options.editable.execute('formatBlock', tagName);\n          });\n          queryState = function(event) {\n            var block;\n            block = document.queryCommandValue('formatBlock');\n            if (block.toLowerCase() === element) {\n              el.addClass('selected');\n              return;\n            }\n            return el.removeClass('selected');\n          };\n          events = 'keyup paste change mouseup';\n          _this.options.editable.element.on(events, queryState);\n          _this.options.editable.element.on('halloenabled', function() {\n            return _this.options.editable.element.on(events, queryState);\n          });\n          _this.options.editable.element.on('hallodisabled', function() {\n            return _this.options.editable.element.off(events, queryState);\n          });\n          return el;\n        };\n        _ref = this.options.elements;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          element = _ref[_i];\n          contentArea.append(addElement(element));\n        }\n        return contentArea;\n      },\n      _prepareButton: function(target) {\n        var buttonElement;\n        buttonElement = jQuery('<span></span>');\n        buttonElement.hallodropdownbutton({\n          uuid: this.options.uuid,\n          editable: this.options.editable,\n          label: 'block',\n          icon: 'fa-text-height',\n          target: target,\n          cssClass: this.options.buttonCssClass\n        });\n        return buttonElement;\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    var rangyMessage;\n    rangyMessage = 'The hallocleanhtml plugin requires the selection save and\\\n    restore module from Rangy';\n    return jQuery.widget('IKS.hallocleanhtml', {\n      _create: function() {\n        var editor,\n          _this = this;\n        if (jQuery.htmlClean === void 0) {\n          throw new Error('The hallocleanhtml plugin requires jQuery.htmlClean');\n          return;\n        }\n        editor = this.element;\n        return editor.bind('paste', this, function(event) {\n          var lastContent, lastRange, widget;\n          if (rangy.saveSelection === void 0) {\n            throw new Error(rangyMessage);\n            return;\n          }\n          widget = event.data;\n          widget.options.editable.getSelection().deleteContents();\n          lastRange = rangy.saveSelection();\n          lastContent = editor.html();\n          editor.html('');\n          return setTimeout(function() {\n            var cleanPasted, error, pasted, range;\n            pasted = editor.html();\n            cleanPasted = jQuery.htmlClean(pasted, _this.options);\n            editor.html(lastContent);\n            rangy.restoreSelection(lastRange);\n            if (cleanPasted !== '') {\n              try {\n                return document.execCommand('insertHTML', false, cleanPasted);\n              } catch (_error) {\n                error = _error;\n                range = widget.options.editable.getSelection();\n                return range.insertNode(range.createContextualFragment(cleanPasted));\n              }\n            }\n          }, 4);\n        });\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.halloformat\", {\n      options: {\n        editable: null,\n        uuid: '',\n        formattings: {\n          bold: true,\n          italic: true,\n          strikeThrough: false,\n          underline: false\n        },\n        buttonCssClass: null\n      },\n      populateToolbar: function(toolbar) {\n        var buttonize, buttonset, enabled, format, widget, _ref,\n          _this = this;\n        widget = this;\n        buttonset = jQuery(\"<span class=\\\"\" + widget.widgetName + \"\\\"></span>\");\n        buttonize = function(format) {\n          var buttonHolder;\n          buttonHolder = jQuery('<span></span>');\n          buttonHolder.hallobutton({\n            label: format,\n            editable: _this.options.editable,\n            command: format,\n            uuid: _this.options.uuid,\n            cssClass: _this.options.buttonCssClass\n          });\n          return buttonset.append(buttonHolder);\n        };\n        _ref = this.options.formattings;\n        for (format in _ref) {\n          enabled = _ref[format];\n          if (!enabled) {\n            continue;\n          }\n          buttonize(format);\n        }\n        buttonset.hallobuttonset();\n        return toolbar.append(buttonset);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.halloheadings\", {\n      options: {\n        editable: null,\n        uuid: '',\n        formatBlocks: [\"p\", \"h1\", \"h2\", \"h3\"],\n        buttonCssClass: null\n      },\n      populateToolbar: function(toolbar) {\n        var buttonize, buttonset, command, format, ie, widget, _i, _len, _ref,\n          _this = this;\n        widget = this;\n        buttonset = jQuery(\"<span class=\\\"\" + widget.widgetName + \"\\\"></span>\");\n        ie = navigator.appName === 'Microsoft Internet Explorer';\n        command = (ie ? \"FormatBlock\" : \"formatBlock\");\n        buttonize = function(format) {\n          var buttonHolder;\n          buttonHolder = jQuery('<span></span>');\n          buttonHolder.hallobutton({\n            label: format,\n            editable: _this.options.editable,\n            command: command,\n            commandValue: (ie ? \"<\" + format + \">\" : format),\n            uuid: _this.options.uuid,\n            cssClass: _this.options.buttonCssClass,\n            queryState: function(event) {\n              var compared, e, map, result, val, value, _i, _len, _ref;\n              try {\n                value = document.queryCommandValue(command);\n                if (ie) {\n                  map = {\n                    p: \"normal\"\n                  };\n                  _ref = [1, 2, 3, 4, 5, 6];\n                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                    val = _ref[_i];\n                    map[\"h\" + val] = val;\n                  }\n                  compared = value.match(new RegExp(map[format], \"i\"));\n                } else {\n                  compared = value.match(new RegExp(format, \"i\"));\n                }\n                result = compared ? true : false;\n                return buttonHolder.hallobutton('checked', result);\n              } catch (_error) {\n                e = _error;\n              }\n            }\n          });\n          buttonHolder.find('button .ui-button-text').text(format.toUpperCase());\n          return buttonset.append(buttonHolder);\n        };\n        _ref = this.options.formatBlocks;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          format = _ref[_i];\n          buttonize(format);\n        }\n        buttonset.hallobuttonset();\n        return toolbar.append(buttonset);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.hallohtml\", {\n      options: {\n        editable: null,\n        toolbar: null,\n        uuid: \"\",\n        lang: 'en',\n        dialogOpts: {\n          autoOpen: false,\n          width: 600,\n          height: 'auto',\n          modal: false,\n          resizable: true,\n          draggable: true,\n          dialogClass: 'htmledit-dialog'\n        },\n        dialog: null,\n        buttonCssClass: null\n      },\n      translations: {\n        en: {\n          title: 'Edit HTML',\n          update: 'Update'\n        },\n        de: {\n          title: 'HTML bearbeiten',\n          update: 'Aktualisieren'\n        }\n      },\n      texts: null,\n      populateToolbar: function($toolbar) {\n        var $buttonHolder, $buttonset, id, selector, widget;\n        widget = this;\n        this.texts = this.translations[this.options.lang];\n        this.options.toolbar = $toolbar;\n        selector = \"\" + this.options.uuid + \"-htmledit-dialog\";\n        this.options.dialog = jQuery(\"<div>\").attr('id', selector);\n        $buttonset = jQuery(\"<span>\").addClass(widget.widgetName);\n        id = \"\" + this.options.uuid + \"-htmledit\";\n        $buttonHolder = jQuery('<span>');\n        $buttonHolder.hallobutton({\n          label: this.texts.title,\n          icon: 'fa-list-alt',\n          editable: this.options.editable,\n          command: null,\n          queryState: false,\n          uuid: this.options.uuid,\n          cssClass: this.options.buttonCssClass\n        });\n        $buttonset.append($buttonHolder);\n        this.button = $buttonHolder;\n        this.button.click(function() {\n          if (widget.options.dialog.dialog(\"isOpen\")) {\n            widget._closeDialog();\n          } else {\n            widget._openDialog();\n          }\n          return false;\n        });\n        this.options.editable.element.on(\"hallodeactivated\", function() {\n          return widget._closeDialog();\n        });\n        $toolbar.append($buttonset);\n        this.options.dialog.dialog(this.options.dialogOpts);\n        return this.options.dialog.dialog(\"option\", \"title\", this.texts.title);\n      },\n      _openDialog: function() {\n        var $editableEl, html, widget, xposition, yposition,\n          _this = this;\n        widget = this;\n        $editableEl = jQuery(this.options.editable.element);\n        xposition = $editableEl.offset().left + $editableEl.outerWidth() + 10;\n        yposition = this.options.toolbar.offset().top - jQuery(document).scrollTop();\n        this.options.dialog.dialog(\"option\", \"position\", [xposition, yposition]);\n        this.options.editable.keepActivated(true);\n        this.options.dialog.dialog(\"open\");\n        this.options.dialog.on('dialogclose', function() {\n          jQuery('label', _this.button).removeClass('ui-state-active');\n          _this.options.editable.element.focus();\n          return _this.options.editable.keepActivated(false);\n        });\n        this.options.dialog.html(jQuery(\"<textarea>\").addClass('html_source'));\n        html = this.options.editable.element.html();\n        this.options.dialog.children('.html_source').val(html);\n        this.options.dialog.prepend(jQuery(\"<button>\" + this.texts.update + \"</button>\"));\n        return this.options.dialog.on('click', 'button', function() {\n          html = widget.options.dialog.children('.html_source').val();\n          widget.options.editable.element.html(html);\n          widget.options.editable.element.trigger('change');\n          return false;\n        });\n      },\n      _closeDialog: function() {\n        return this.options.dialog.dialog(\"close\");\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.halloimage\", {\n      options: {\n        editable: null,\n        toolbar: null,\n        uuid: \"\",\n        limit: 8,\n        search: null,\n        searchUrl: null,\n        suggestions: null,\n        loaded: null,\n        upload: null,\n        uploadUrl: null,\n        dialogOpts: {\n          autoOpen: false,\n          width: 270,\n          height: \"auto\",\n          title: \"Insert Images\",\n          modal: false,\n          resizable: false,\n          draggable: true,\n          dialogClass: 'halloimage-dialog'\n        },\n        dialog: null,\n        buttonCssClass: null,\n        entity: null,\n        vie: null,\n        dbPediaUrl: \"http://dev.iks-project.eu/stanbolfull\",\n        maxWidth: 250,\n        maxHeight: 250\n      },\n      populateToolbar: function(toolbar) {\n        var buttonHolder, buttonset, dialogId, id, tabContent, tabs, widget;\n        this.options.toolbar = toolbar;\n        widget = this;\n        dialogId = \"\" + this.options.uuid + \"-image-dialog\";\n        this.options.dialog = jQuery(\"<div id=\\\"\" + dialogId + \"\\\">        <div class=\\\"nav\\\">          <ul class=\\\"tabs\\\">          </ul>          <div id=\\\"\" + this.options.uuid + \"-tab-activeIndicator\\\"            class=\\\"tab-activeIndicator\\\" />        </div>        <div class=\\\"dialogcontent\\\">        </div>\");\n        tabs = jQuery('.tabs', this.options.dialog);\n        tabContent = jQuery('.dialogcontent', this.options.dialog);\n        if (widget.options.suggestions) {\n          this._addGuiTabSuggestions(tabs, tabContent);\n        }\n        if (widget.options.search || widget.options.searchUrl) {\n          this._addGuiTabSearch(tabs, tabContent);\n        }\n        if (widget.options.upload || widget.options.uploadUrl) {\n          this._addGuiTabUpload(tabs, tabContent);\n        }\n        this.current = jQuery('<div class=\"currentImage\"></div>').halloimagecurrent({\n          uuid: this.options.uuid,\n          imageWidget: this,\n          editable: this.options.editable,\n          dialog: this.options.dialog,\n          maxWidth: this.options.maxWidth,\n          maxHeight: this.options.maxHeight\n        });\n        jQuery('.dialogcontent', this.options.dialog).append(this.current);\n        buttonset = jQuery(\"<span class=\\\"\" + widget.widgetName + \"\\\"></span>\");\n        id = \"\" + this.options.uuid + \"-image\";\n        buttonHolder = jQuery('<span></span>');\n        buttonHolder.hallobutton({\n          label: 'Images',\n          icon: 'fa-picture-o',\n          editable: this.options.editable,\n          command: null,\n          queryState: false,\n          uuid: this.options.uuid,\n          cssClass: this.options.buttonCssClass\n        });\n        buttonset.append(buttonHolder);\n        this.button = buttonHolder;\n        this.button.on(\"click\", function(event) {\n          if (widget.options.dialog.dialog(\"isOpen\")) {\n            widget._closeDialog();\n          } else {\n            widget._openDialog();\n          }\n          return false;\n        });\n        this.options.editable.element.on(\"hallodeactivated\", function(event) {\n          return widget._closeDialog();\n        });\n        jQuery(this.options.editable.element).delegate(\"img\", \"click\", function(event) {\n          return widget._openDialog();\n        });\n        toolbar.append(buttonset);\n        this.options.dialog.dialog(this.options.dialogOpts);\n        return this._handleTabs();\n      },\n      setCurrent: function(image) {\n        return this.current.halloimagecurrent('setImage', image);\n      },\n      _handleTabs: function() {\n        var widget;\n        widget = this;\n        jQuery('.nav li', this.options.dialog).on('click', function() {\n          var id, left;\n          jQuery(\".\" + widget.widgetName + \"-tab\").hide();\n          id = jQuery(this).attr('id');\n          jQuery(\"#\" + id + \"-content\").show();\n          left = jQuery(this).position().left + (jQuery(this).width() / 2);\n          return jQuery(\"#\" + widget.options.uuid + \"-tab-activeIndicator\").css({\n            \"margin-left\": left\n          });\n        });\n        return jQuery('.nav li', this.options.dialog).first().click();\n      },\n      _openDialog: function() {\n        var cleanUp, editableEl, getActive, suggestionSelector, toolbarEl, widget, xposition, yposition,\n          _this = this;\n        widget = this;\n        cleanUp = function() {\n          return window.setTimeout(function() {\n            var thumbnails;\n            thumbnails = jQuery(\".imageThumbnail\");\n            return jQuery(thumbnails).each(function() {\n              var size;\n              size = jQuery(\"#\" + this.id).width();\n              if (size <= 20) {\n                return jQuery(\"#\" + this.id).parent(\"li\").remove();\n              }\n            });\n          }, 15000);\n        };\n        suggestionSelector = \"#\" + this.options.uuid + \"-tab-suggestions-content\";\n        getActive = function() {\n          return jQuery('.imageThumbnailActive', suggestionSelector).first().attr(\"src\");\n        };\n        jQuery(\"#\" + this.options.uuid + \"-sugg-activeImage\").attr(\"src\", getActive());\n        jQuery(\"#\" + this.options.uuid + \"-sugg-activeImageBg\").attr(\"src\", getActive());\n        this.lastSelection = this.options.editable.getSelection();\n        editableEl = jQuery(this.options.editable.element);\n        toolbarEl = jQuery(this.options.toolbar);\n        xposition = editableEl.offset().left + editableEl.outerWidth() - 3;\n        yposition = toolbarEl.offset().top + toolbarEl.outerHeight() + 29;\n        yposition -= jQuery(document).scrollTop();\n        this.options.dialog.dialog(\"option\", \"position\", [xposition, yposition]);\n        cleanUp();\n        widget.options.loaded = 1;\n        this.options.editable.keepActivated(true);\n        this.options.dialog.dialog(\"open\");\n        return this.options.dialog.on('dialogclose', function() {\n          jQuery('label', _this.button).removeClass('ui-state-active');\n          _this.options.editable.element.focus();\n          return _this.options.editable.keepActivated(false);\n        });\n      },\n      _closeDialog: function() {\n        return this.options.dialog.dialog(\"close\");\n      },\n      _addGuiTabSuggestions: function(tabs, element) {\n        var tab;\n        tabs.append(jQuery(\"<li id=\\\"\" + this.options.uuid + \"-tab-suggestions\\\"        class=\\\"\" + this.widgetName + \"-tabselector \" + this.widgetName + \"-tab-suggestions\\\">          <span>Suggestions</span>        </li>\"));\n        tab = jQuery(\"<div id=\\\"\" + this.options.uuid + \"-tab-suggestions-content\\\"        class=\\\"\" + this.widgetName + \"-tab tab-suggestions\\\"></div>\");\n        element.append(tab);\n        return tab.halloimagesuggestions({\n          uuid: this.options.uuid,\n          imageWidget: this,\n          entity: this.options.entity\n        });\n      },\n      _addGuiTabSearch: function(tabs, element) {\n        var dialogId, tab, widget;\n        widget = this;\n        dialogId = \"\" + this.options.uuid + \"-image-dialog\";\n        tabs.append(jQuery(\"<li id=\\\"\" + this.options.uuid + \"-tab-search\\\"        class=\\\"\" + this.widgetName + \"-tabselector \" + this.widgetName + \"-tab-search\\\">          <span>Search</span>        </li>\"));\n        tab = jQuery(\"<div id=\\\"\" + this.options.uuid + \"-tab-search-content\\\"        class=\\\"\" + widget.widgetName + \"-tab tab-search\\\"></div>\");\n        element.append(tab);\n        return tab.halloimagesearch({\n          uuid: this.options.uuid,\n          imageWidget: this,\n          searchCallback: this.options.search,\n          searchUrl: this.options.searchUrl,\n          limit: this.options.limit,\n          entity: this.options.entity\n        });\n      },\n      _addGuiTabUpload: function(tabs, element) {\n        var tab;\n        tabs.append(jQuery(\"<li id=\\\"\" + this.options.uuid + \"-tab-upload\\\"        class=\\\"\" + this.widgetName + \"-tabselector \" + this.widgetName + \"-tab-upload\\\">          <span>Upload</span>        </li>\"));\n        tab = jQuery(\"<div id=\\\"\" + this.options.uuid + \"-tab-upload-content\\\"        class=\\\"\" + this.widgetName + \"-tab tab-upload\\\"></div>\");\n        element.append(tab);\n        return tab.halloimageupload({\n          uuid: this.options.uuid,\n          uploadCallback: this.options.upload,\n          uploadUrl: this.options.uploadUrl,\n          imageWidget: this,\n          entity: this.options.entity\n        });\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloimagecurrent', {\n      options: {\n        imageWidget: null,\n        startPlace: '',\n        draggables: [],\n        maxWidth: 400,\n        maxHeight: 200\n      },\n      _create: function() {\n        this.element.html('<div>\\\n        <div class=\"activeImageContainer\">\\\n          <div class=\"rotationWrapper\">\\\n            <div class=\"hintArrow\"></div>\\\n              <img src=\"\" class=\"activeImage\" />\\\n            </div>\\\n            <img src=\"\" class=\"activeImage activeImageBg\" />\\\n          </div>\\\n        </div>');\n        this.element.hide();\n        return this._prepareDnD();\n      },\n      _init: function() {\n        var editable, widget;\n        editable = jQuery(this.options.editable.element);\n        widget = this;\n        jQuery('img', editable).each(function(index, elem) {\n          return widget._initDraggable(elem, editable);\n        });\n        return jQuery('p', editable).each(function(index, elem) {\n          if (jQuery(elem).data('jquery_droppable_initialized')) {\n            return;\n          }\n          jQuery(elem).droppable({\n            tolerance: 'pointer',\n            drop: function(event, ui) {\n              return widget._handleDropEvent(event, ui);\n            },\n            over: function(event, ui) {\n              return widget._handleOverEvent(event, ui);\n            },\n            out: function(event, ui) {\n              return widget._handleLeaveEvent(event, ui);\n            }\n          });\n          return jQuery(elem).data('jquery_droppable_initialized', true);\n        });\n      },\n      _prepareDnD: function() {\n        var editable, overlayMiddleConfig, widget;\n        widget = this;\n        editable = jQuery(this.options.editable.element);\n        this.options.offset = editable.offset();\n        this.options.third = parseFloat(editable.width() / 3);\n        overlayMiddleConfig = {\n          width: this.options.third,\n          height: editable.height()\n        };\n        this.overlay = {\n          big: jQuery(\"<div/>\").addClass(\"bigOverlay\").css({\n            width: this.options.third * 2,\n            height: editable.height()\n          }),\n          left: jQuery(\"<div/>\").addClass(\"smallOverlay smallOverlayLeft\"),\n          right: jQuery(\"<div/>\").addClass(\"smallOverlay smallOverlayRight\")\n        };\n        this.overlay.left.css(overlayMiddleConfig);\n        this.overlay.right.css(overlayMiddleConfig).css(\"left\", this.options.third * 2);\n        editable.on('halloactivated', function() {\n          return widget._enableDragging();\n        });\n        return editable.on('hallodeactivated', function() {\n          return widget._disableDragging();\n        });\n      },\n      setImage: function(image) {\n        if (!image) {\n          return;\n        }\n        this.element.show();\n        jQuery('.activeImage', this.element).attr('src', image.url);\n        if (image.label) {\n          jQuery('input', this.element).val(image.label);\n        }\n        return this._initImage(jQuery(this.options.editable.element));\n      },\n      _delayAction: function(functionToCall, delay) {\n        var timer;\n        timer = clearTimeout(timer);\n        if (!timer) {\n          return timer = setTimeout(functionToCall, delay);\n        }\n      },\n      _calcDropPosition: function(offset, event) {\n        var position, rightTreshold;\n        position = offset.left + this.options.third;\n        rightTreshold = offset.left + this.options.third * 2;\n        if (event.pageX >= position && event.pageX <= rightTreshold) {\n          return 'middle';\n        } else if (event.pageX < position) {\n          return 'left';\n        } else if (event.pageX > rightTreshold) {\n          return 'right';\n        }\n      },\n      _createInsertElement: function(image, tmp) {\n        var imageInsert, tmpImg;\n        imageInsert = jQuery('<img>');\n        tmpImg = new Image();\n        jQuery(tmpImg).on('load', function() {});\n        tmpImg.src = image.src;\n        imageInsert.attr({\n          src: tmpImg.src,\n          alt: !tmp ? jQuery(image).attr('alt') : void 0,\n          \"class\": tmp ? 'halloTmp' : 'imageInText'\n        });\n        imageInsert.show();\n        return imageInsert;\n      },\n      _createLineFeedbackElement: function() {\n        return jQuery('<div/>').addClass('halloTmpLine');\n      },\n      _removeFeedbackElements: function() {\n        this.overlay.big.remove();\n        this.overlay.left.remove();\n        this.overlay.right.remove();\n        return jQuery('.halloTmp, .halloTmpLine', this.options.editable.element).remove();\n      },\n      _removeCustomHelper: function() {\n        return jQuery('.customHelper').remove();\n      },\n      _showOverlay: function(position) {\n        var eHeight, editable;\n        editable = jQuery(this.options.editable.element);\n        eHeight = editable.height();\n        eHeight += parseFloat(editable.css('paddingTop'));\n        eHeight += parseFloat(editable.css('paddingBottom'));\n        this.overlay.big.css({\n          height: eHeight\n        });\n        this.overlay.left.css({\n          height: eHeight\n        });\n        this.overlay.right.css({\n          height: eHeight\n        });\n        switch (position) {\n          case 'left':\n            this.overlay.big.addClass(\"bigOverlayLeft\");\n            this.overlay.big.removeClass(\"bigOverlayRight\");\n            this.overlay.big.css({\n              left: this.options.third\n            });\n            this.overlay.big.show();\n            this.overlay.left.hide();\n            return this.overlay.right.hide();\n          case 'middle':\n            this.overlay.big.removeClass(\"bigOverlayLeft bigOverlayRight\");\n            this.overlay.big.hide();\n            this.overlay.left.show();\n            return this.overlay.right.show();\n          case 'right':\n            this.overlay.big.addClass(\"bigOverlayRight\");\n            this.overlay.big.removeClass(\"bigOverlayLeft\");\n            this.overlay.big.css({\n              left: 0\n            });\n            this.overlay.big.show();\n            this.overlay.left.hide();\n            return this.overlay.right.hide();\n        }\n      },\n      _checkOrigin: function(event) {\n        if (jQuery(event.target).parents(\"[contenteditable]\").length !== 0) {\n          return true;\n        }\n        return false;\n      },\n      _createFeedback: function(image, position) {\n        var el;\n        if (position === 'middle') {\n          return this._createLineFeedbackElement();\n        }\n        el = this._createInsertElement(image, true);\n        return el.addClass(\"inlineImage-\" + position);\n      },\n      _handleOverEvent: function(event, ui) {\n        var editable, postPone, widget;\n        widget = this;\n        editable = jQuery(this.options.editable);\n        postPone = function() {\n          var position, target;\n          window.waitWithTrash = clearTimeout(window.waitWithTrash);\n          position = widget._calcDropPosition(widget.options.offset, event);\n          jQuery('.trashcan', ui.helper).remove();\n          editable[0].element.append(widget.overlay.big);\n          editable[0].element.append(widget.overlay.left);\n          editable[0].element.append(widget.overlay.right);\n          widget._removeFeedbackElements();\n          target = jQuery(event.target);\n          target.prepend(widget._createFeedback(ui.draggable[0], position));\n          if (position === 'middle') {\n            target.prepend(widget._createFeedback(ui.draggable[0], 'right'));\n            jQuery('.halloTmp', event.target).hide();\n          } else {\n            target.prepend(widget._createFeedback(ui.draggable[0], 'middle'));\n            jQuery('.halloTmpLine', event.target).hide();\n          }\n          return widget._showOverlay(position);\n        };\n        return setTimeout(postPone, 5);\n      },\n      _handleDragEvent: function(event, ui) {\n        var position, tmpFeedbackLR, tmpFeedbackMiddle;\n        position = this._calcDropPosition(this.options.offset, event);\n        if (position === this._lastPositionDrag) {\n          return;\n        }\n        this._lastPositionDrag = position;\n        tmpFeedbackLR = jQuery('.halloTmp', this.options.editable.element);\n        tmpFeedbackMiddle = jQuery('.halloTmpLine', this.options.editable.element);\n        if (position === 'middle') {\n          tmpFeedbackMiddle.show();\n          tmpFeedbackLR.hide();\n        } else {\n          tmpFeedbackMiddle.hide();\n          tmpFeedbackLR.removeClass('inlineImage-left inlineImage-right');\n          tmpFeedbackLR.addClass(\"inlineImage-\" + position);\n          tmpFeedbackLR.show();\n        }\n        return this._showOverlay(position);\n      },\n      _handleLeaveEvent: function(event, ui) {\n        var func;\n        func = function() {\n          if (!jQuery('div.trashcan', ui.helper).length) {\n            jQuery(ui.helper).append(jQuery('<div class=\"trashcan\"></div>'));\n            return jQuery('.bigOverlay, .smallOverlay').remove();\n          }\n        };\n        window.waitWithTrash = setTimeout(func, 200);\n        return this._removeFeedbackElements();\n      },\n      _handleStartEvent: function(event, ui) {\n        var internalDrop;\n        internalDrop = this._checkOrigin(event);\n        if (internalDrop) {\n          jQuery(event.target).remove();\n        }\n        jQuery(document).trigger('startPreventSave');\n        return this.options.startPlace = jQuery(event.target);\n      },\n      _handleStopEvent: function(event, ui) {\n        var internalDrop;\n        internalDrop = this._checkOrigin(event);\n        if (internalDrop) {\n          jQuery(event.target).remove();\n        } else {\n          jQuery(this.options.editable.element).trigger('change');\n        }\n        this.overlay.big.hide();\n        this.overlay.left.hide();\n        this.overlay.right.hide();\n        return jQuery(document).trigger('stopPreventSave');\n      },\n      _handleDropEvent: function(event, ui) {\n        var classes, editable, imageInsert, internalDrop, left, position;\n        editable = jQuery(this.options.editable.element);\n        internalDrop = this._checkOrigin(event);\n        position = this._calcDropPosition(this.options.offset, event);\n        this._removeFeedbackElements();\n        this._removeCustomHelper();\n        imageInsert = this._createInsertElement(ui.draggable[0], false);\n        classes = 'inlineImage-middle inlineImage-left inlineImage-right';\n        if (position === 'middle') {\n          imageInsert.show();\n          imageInsert.removeClass(classes);\n          left = editable.width();\n          left += parseFloat(editable.css('paddingLeft'));\n          left += parseFloat(editable.css('paddingRight'));\n          left -= imageInsert.attr('width');\n          imageInsert.addClass(\"inlineImage-\" + position).css({\n            position: 'relative',\n            left: left / 2\n          });\n          imageInsert.insertBefore(jQuery(event.target));\n        } else {\n          imageInsert.removeClass(classes);\n          imageInsert.addClass(\"inlineImage-\" + position);\n          imageInsert.css('display', 'block');\n          jQuery(event.target).prepend(imageInsert);\n        }\n        this.overlay.big.hide();\n        this.overlay.left.hide();\n        this.overlay.right.hide();\n        editable.trigger('change');\n        return this._initImage(editable);\n      },\n      _createHelper: function(event) {\n        return jQuery('<div>').css({\n          backgroundImage: \"url(\" + (jQuery(event.currentTarget).attr('src')) + \")\"\n        }).addClass('customHelper').appendTo('body');\n      },\n      _initDraggable: function(elem, editable) {\n        var widget;\n        widget = this;\n        if (!elem.jquery_draggable_initialized) {\n          elem.jquery_draggable_initialized = true;\n          jQuery(elem).draggable({\n            cursor: 'move',\n            helper: function(event) {\n              return widget._createHelper(event);\n            },\n            drag: function(event, ui) {\n              return widget._handleDragEvent(event, ui);\n            },\n            start: function(event, ui) {\n              return widget._handleStartEvent(event, ui);\n            },\n            stop: function(event, ui) {\n              return widget._handleStopEvent(event, ui);\n            },\n            disabled: !editable.hasClass('inEditMode'),\n            cursorAt: {\n              top: 50,\n              left: 50\n            }\n          });\n        }\n        return widget.options.draggables.push(elem);\n      },\n      _initImage: function(editable) {\n        var widget;\n        widget = this;\n        return jQuery('.rotationWrapper img', this.options.dialog).each(function(index, elem) {\n          return widget._initDraggable(elem, editable);\n        });\n      },\n      _enableDragging: function() {\n        return jQuery.each(this.options.draggables, function(index, d) {\n          return jQuery(d).draggable('option', 'disabled', false);\n        });\n      },\n      _disableDragging: function() {\n        return jQuery.each(this.options.draggables, function(index, d) {\n          return jQuery(d).draggable('option', 'disabled', true);\n        });\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloimagesearch', {\n      options: {\n        imageWidget: null,\n        searchCallback: null,\n        searchUrl: null,\n        limit: 5\n      },\n      _create: function() {\n        return this.element.html('<div>\\\n        <form method=\"get\">\\\n          <input type=\"text\" class=\"searchInput\" placeholder=\"Search\" />\\\n          <input type=\"submit\" class=\"btn searchButton\" value=\"OK\" />\\\n        </form>\\\n        <div class=\"searchResults imageThumbnailContainer\">\\\n          <div class=\"activitySpinner\">Loading images...</div>\\\n          <ul></ul>\\\n        </div>\\\n      </div>');\n      },\n      _init: function() {\n        var _this = this;\n        if (this.options.searchUrl && !this.options.searchCallback) {\n          this.options.searchCallback = this._ajaxSearch;\n        }\n        jQuery('.activitySpinner', this.element).hide();\n        return jQuery('form', this.element).submit(function(event) {\n          var query;\n          event.preventDefault();\n          jQuery('.activitySpinner', _this.element).show();\n          query = jQuery('.searchInput', _this.element.element).val();\n          return _this.options.searchCallback(query, _this.options.limit, 0, function(results) {\n            return _this._showResults(results);\n          });\n        });\n      },\n      _showResult: function(image) {\n        var html,\n          _this = this;\n        if (!image.label) {\n          image.label = image.alt;\n        }\n        html = jQuery(\"<li>        <img src=\\\"\" + image.url + \"\\\" class=\\\"imageThumbnail\\\"          title=\\\"\" + image.label + \"\\\"></li>\");\n        html.on('click', function() {\n          return _this.options.imageWidget.setCurrent(image);\n        });\n        jQuery('img', html).on('mousedown', function(event) {\n          event.preventDefault();\n          return _this.options.imageWidget.setCurrent(image);\n        });\n        return jQuery('.imageThumbnailContainer ul', this.element).append(html);\n      },\n      _showNextPrev: function(results) {\n        var container,\n          _this = this;\n        container = jQuery('imageThumbnailContainer ul', this.element);\n        container.prepend(jQuery('<div class=\"pager-prev\" style=\"display:none\" />'));\n        container.append(jQuery('<div class=\"pager-next\" style=\"display:none\" />'));\n        if (results.offset > 0) {\n          jQuery('.pager-prev', container).show();\n        }\n        if (results.offset < results.total) {\n          jQuery('.pager-next', container).show();\n        }\n        jQuery('.pager-prev', container).click(function(event) {\n          var offset;\n          offset = results.offset - _this.options.limit;\n          return _this.options.searchCallback(query, _this.options.limit, offset, function(results) {\n            return _this._showResults(results);\n          });\n        });\n        return jQuery('.pager-next', container).click(function(event) {\n          var offset;\n          offset = results.offset + _this.options.limit;\n          return _this.options.searchCallback(query, _this.options.limit, offset, function(results) {\n            return _this._showResults(results);\n          });\n        });\n      },\n      _showResults: function(results) {\n        var image, _i, _len, _ref;\n        jQuery('.activitySpinner', this.element).hide();\n        jQuery('.imageThumbnailContainer ul', this.element).empty();\n        jQuery('.imageThumbnailContainer ul', this.element).show();\n        _ref = results.assets;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          image = _ref[_i];\n          this._showResult(image);\n        }\n        this.options.imageWidget.setCurrent(results.assets.shift());\n        return this._showNextPrev(results);\n      },\n      _ajaxSearch: function(query, limit, offset, success) {\n        var searchUrl;\n        searchUrl = this.searchUrl + '?' + jQuery.param({\n          q: query,\n          limit: limit,\n          offset: offset\n        });\n        return jQuery.getJSON(searchUrl, success);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloimagesuggestions', {\n      loaded: false,\n      options: {\n        entity: null,\n        vie: null,\n        dbPediaUrl: null,\n        getSuggestions: null,\n        thumbnailUri: '<http://dbpedia.org/ontology/thumbnail>'\n      },\n      _create: function() {\n        return this.element.html('\\\n      <div id=\"' + this.options.uuid + '-tab-suggestions\">\\\n        <div class=\"imageThumbnailContainer\">\\\n          <div class=\"activitySpinner\">Loading images...</div>\\\n          <ul></ul>\\\n        </div>\\\n      </div>');\n      },\n      _init: function() {\n        return jQuery('.activitySpinner', this.element).hide();\n      },\n      _normalizeRelated: function(related) {\n        if (_.isString(related)) {\n          return related;\n        }\n        if (_.isArray(related)) {\n          return related.join(',');\n        }\n        return related.pluck('@subject').join(',');\n      },\n      _prepareVIE: function() {\n        if (!this.options.vie) {\n          this.options.vie = new VIE;\n        }\n        if (this.options.vie.services.dbpedia) {\n          return;\n        }\n        if (!this.options.dbPediaUrl) {\n          return;\n        }\n        return this.options.vie.use(new vie.DBPediaService({\n          url: this.options.dbPediaUrl,\n          proxyDisabled: true\n        }));\n      },\n      _getSuggestions: function() {\n        var limit, normalizedTags, tags;\n        if (this.loaded) {\n          return;\n        }\n        if (!this.options.entity) {\n          return;\n        }\n        jQuery('.activitySpinner', this.element).show();\n        tags = this.options.entity.get('skos:related');\n        if (tags.length === 0) {\n          jQuery(\"#activitySpinner\").html('No images found.');\n          return;\n        }\n        jQuery('.imageThumbnailContainer ul', this.element).empty();\n        normalizedTags = this._normalizeRelated(tags);\n        limit = this.options.limit;\n        if (this.options.getSuggestions) {\n          this.options.getSuggestions(normalizedTags, limit, 0, this._showSuggestions);\n        }\n        this._prepareVIE();\n        if (this.options.vie.services.dbpedia) {\n          this._getSuggestionsDbPedia(tags);\n        }\n        return this.loaded = true;\n      },\n      _getSuggestionsDbPedia: function(tags) {\n        var thumbId, widget;\n        widget = this;\n        thumbId = 1;\n        return _.each(tags, function(tag) {\n          return vie.load({\n            entity: tag\n          }).using('dbpedia').execute().done(function(entities) {\n            jQuery('.activitySpinner', this.element).hide();\n            return _.each(entities, function(entity) {\n              var img, thumbnail;\n              thumbnail = entity.attributes[widget.options.thumbnailUri];\n              if (!thumbnail) {\n                return;\n              }\n              if (_.isObject(thumbnail)) {\n                img = thumbnail[0].value;\n              }\n              if (_.isString(thumbnail)) {\n                img = widget.options.entity.fromReference(thumbnail);\n              }\n              return widget._showSuggestion({\n                url: img,\n                label: tag\n              });\n            });\n          });\n        });\n      },\n      _showSuggestion: function(image) {\n        var html,\n          _this = this;\n        html = jQuery(\"<li>        <img src=\\\"\" + image.url + \"\\\" class=\\\"imageThumbnail\\\"          title=\\\"\" + image.label + \"\\\">        </li>\");\n        html.on('click', function() {\n          return _this.options.imageWidget.setCurrent(image);\n        });\n        return jQuery('.imageThumbnailContainer ul', this.element).append(html);\n      },\n      _showSuggestions: function(suggestions) {\n        var _this = this;\n        jQuery('.activitySpinner', this.element).hide();\n        return _.each(suggestions, function(image) {\n          return _this._showSuggestion(image);\n        });\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloimageupload', {\n      options: {\n        uploadCallback: null,\n        uploadUrl: null,\n        imageWidget: null,\n        entity: null\n      },\n      _create: function() {\n        return this.element.html('\\\n        <form class=\"upload\">\\\n        <input type=\"file\" class=\"file\" name=\"userfile\" accept=\"image/*\" />\\\n        <input type=\"hidden\" name=\"tags\" value=\"\" />\\\n        <input type=\"text\" class=\"caption\" name=\"caption\" placeholder=\"Title\" />\\\n        <button class=\"uploadSubmit\">Upload</button>\\\n        </form>\\\n      ');\n      },\n      _init: function() {\n        var widget;\n        widget = this;\n        if (widget.options.uploadUrl && !widget.options.uploadCallback) {\n          widget.options.uploadCallback = widget._iframeUpload;\n        }\n        return jQuery('.uploadSubmit', this.element).on('click', function(event) {\n          event.preventDefault();\n          event.stopPropagation();\n          return widget.options.uploadCallback({\n            widget: widget,\n            success: function(url) {\n              return widget.options.imageWidget.setCurrent({\n                url: url,\n                label: ''\n              });\n            }\n          });\n        });\n      },\n      _prepareIframe: function(widget) {\n        var iframe, iframeName;\n        iframeName = \"\" + widget.widgetName + \"_postframe_\" + widget.options.uuid;\n        iframeName = iframeName.replace(/-/g, '_');\n        iframe = jQuery(\"#\" + iframeName);\n        if (iframe.length) {\n          return iframe;\n        }\n        iframe = jQuery(\"<iframe name=\\\"\" + iframeName + \"\\\" id=\\\"\" + iframeName + \"\\\"        class=\\\"hidden\\\" style=\\\"display:none\\\" />\");\n        this.element.append(iframe);\n        iframe.get(0).name = iframeName;\n        return iframe;\n      },\n      _iframeUpload: function(data) {\n        var iframe, uploadForm, uploadUrl, widget;\n        widget = data.widget;\n        iframe = widget._prepareIframe(widget);\n        uploadForm = jQuery('form.upload', widget.element);\n        if (typeof widget.options.uploadUrl === 'function') {\n          uploadUrl = widget.options.uploadUrl(widget.options.entity);\n        } else {\n          uploadUrl = widget.options.uploadUrl;\n        }\n        iframe.on('load', function() {\n          var imageUrl;\n          imageUrl = iframe.get(0).contentWindow.location.href;\n          widget.element.hide();\n          return data.success(imageUrl);\n        });\n        uploadForm.attr('action', uploadUrl);\n        uploadForm.attr('method', 'post');\n        uploadForm.attr('target', iframe.get(0).name);\n        uploadForm.attr('enctype', 'multipart/form-data');\n        uploadForm.attr('encoding', 'multipart/form-data');\n        return uploadForm.submit();\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.hallo-image-insert-edit\", {\n      options: {\n        editable: null,\n        toolbar: null,\n        uuid: \"\",\n        insert_file_dialog_ui_url: null,\n        lang: 'en',\n        dialogOpts: {\n          autoOpen: false,\n          width: 560,\n          height: 'auto',\n          modal: false,\n          resizable: true,\n          draggable: true,\n          dialogClass: 'insert-image-dialog'\n        },\n        dialog: null,\n        buttonCssClass: null\n      },\n      translations: {\n        en: {\n          title_insert: 'Insert Image',\n          title_properties: 'Image Properties',\n          insert: 'Insert',\n          chage_image: 'Change Image:',\n          source: 'URL',\n          width: 'Width',\n          height: 'Height',\n          alt: 'Alt Text',\n          padding: 'Padding',\n          'float': 'Float',\n          float_left: 'left',\n          float_right: 'right',\n          float_none: 'No'\n        },\n        de: {\n          title_insert: 'Bild einfügen',\n          title_properties: 'Bildeigenschaften',\n          insert: 'Einfügen',\n          chage_image: 'Bild ändern:',\n          source: 'URL',\n          width: 'Breite',\n          height: 'Höhe',\n          alt: 'Alt Text',\n          padding: 'Padding',\n          'float': 'Float',\n          float_left: 'Links',\n          float_right: 'Rechts',\n          float_none: 'Nein'\n        }\n      },\n      texts: null,\n      dialog_image_selection_ui_loaded: false,\n      $image: null,\n      populateToolbar: function($toolbar) {\n        var $buttonHolder, $buttonset, dialog_html, widget;\n        widget = this;\n        this.texts = this.translations[this.options.lang];\n        this.options.toolbar = $toolbar;\n        dialog_html = \"<div id='hallo_img_properties'></div>\";\n        if (this.options.insert_file_dialog_ui_url) {\n          dialog_html += \"<div id='hallo_img_file_select_ui'></div>\";\n        }\n        this.options.dialog = jQuery(\"<div>\").attr('id', \"\" + this.options.uuid + \"-insert-image-dialog\").html(dialog_html);\n        $buttonset = jQuery(\"<span>\").addClass(this.widgetName);\n        $buttonHolder = jQuery('<span>');\n        $buttonHolder.hallobutton({\n          label: this.texts.title_insert,\n          icon: 'fa-picture-o',\n          editable: this.options.editable,\n          command: null,\n          queryState: false,\n          uuid: this.options.uuid,\n          cssClass: this.options.buttonCssClass\n        });\n        $buttonset.append($buttonHolder);\n        this.button = $buttonHolder;\n        this.button.click(function() {\n          if (widget.options.dialog.dialog(\"isOpen\")) {\n            widget._closeDialog();\n          } else {\n            widget.lastSelection = widget.options.editable.getSelection();\n            widget._openDialog();\n          }\n          return false;\n        });\n        this.options.editable.element.on(\"halloselected, hallounselected\", function() {\n          if (widget.options.dialog.dialog(\"isOpen\")) {\n            return widget.lastSelection = widget.options.editable.getSelection();\n          }\n        });\n        this.options.editable.element.on(\"hallodeactivated\", function() {\n          return widget._closeDialog();\n        });\n        jQuery(this.options.editable.element).on(\"click\", \"img\", function(e) {\n          widget._openDialog(jQuery(this));\n          return false;\n        });\n        this.options.editable.element.on('halloselected', function(event, data) {\n          var toolbar_option;\n          toolbar_option = widget.options.editable.options.toolbar;\n          if (toolbar_option === \"halloToolbarContextual\" && jQuery(data.originalEvent.target).is('img')) {\n            $toolbar.hide();\n            return false;\n          }\n        });\n        $toolbar.append($buttonset);\n        return this.options.dialog.dialog(this.options.dialogOpts);\n      },\n      _openDialog: function($image) {\n        var $editableEl, widget, xposition, yposition,\n          _this = this;\n        this.$image = $image;\n        widget = this;\n        $editableEl = jQuery(this.options.editable.element);\n        xposition = $editableEl.offset().left + $editableEl.outerWidth() + 10;\n        if (this.$image) {\n          yposition = this.$image.offset().top - jQuery(document).scrollTop();\n        } else {\n          yposition = this.options.toolbar.offset().top - jQuery(document).scrollTop();\n        }\n        this.options.dialog.dialog(\"option\", \"position\", [xposition, yposition]);\n        this.options.editable.keepActivated(true);\n        this.options.dialog.dialog(\"open\");\n        if (this.$image) {\n          this.options.dialog.dialog(\"option\", \"title\", this.texts.title_properties);\n          jQuery(document).keyup(function(e) {\n            if (e.keyCode === 46 || e.keyCode === 8) {\n              jQuery(document).off();\n              widget._closeDialog();\n              widget.$image.remove();\n              widget.$image = null;\n            }\n            return e.preventDefault();\n          });\n          this.options.editable.element.on(\"click\", function() {\n            widget.$image = null;\n            return widget._closeDialog();\n          });\n        } else {\n          this.options.dialog.children('#hallo_img_properties').hide();\n          this.options.dialog.dialog(\"option\", \"title\", this.texts.title_insert);\n          if (jQuery('#hallo_img_file_select_title').length > 0) {\n            jQuery('#hallo_img_file_select_title').text('');\n          }\n        }\n        this._load_dialog_image_properties_ui();\n        this.options.dialog.on('dialogclose', function() {\n          var scrollbar_pos;\n          jQuery('label', _this.button).removeClass('ui-state-active');\n          scrollbar_pos = jQuery(document).scrollTop();\n          _this.options.editable.element.focus();\n          jQuery(document).scrollTop(scrollbar_pos);\n          return _this.options.editable.keepActivated(false);\n        });\n        if (this.options.insert_file_dialog_ui_url && !this.dialog_image_selection_ui_loaded) {\n          this.options.dialog.on('click', \".reload_link\", function() {\n            widget._load_dialog_image_selection_ui();\n            return false;\n          });\n          this.options.dialog.on('click', '.file_preview img', function() {\n            var new_source;\n            if (widget.$image) {\n              new_source = jQuery(this).attr('src').replace(/-thumb/, '');\n              widget.$image.attr('src', new_source);\n              jQuery('#hallo_img_source').val(new_source);\n            } else {\n              widget._insert_image(jQuery(this).attr('src').replace(/-thumb/, ''));\n            }\n            return false;\n          });\n          return this._load_dialog_image_selection_ui();\n        }\n      },\n      _insert_image: function(source) {\n        this.options.editable.restoreSelection(this.lastSelection);\n        document.execCommand(\"insertImage\", null, source);\n        this.options.editable.element.trigger('change');\n        this.options.editable.removeAllSelections();\n        return this._closeDialog();\n      },\n      _closeDialog: function() {\n        return this.options.dialog.dialog(\"close\");\n      },\n      _load_dialog_image_selection_ui: function() {\n        var widget;\n        widget = this;\n        return jQuery.ajax({\n          url: this.options.insert_file_dialog_ui_url,\n          success: function(data, textStatus, jqXHR) {\n            var $properties, file_select_title, t;\n            file_select_title = '';\n            $properties = widget.options.dialog.children('#hallo_img_properties');\n            if ($properties.is(':visible')) {\n              file_select_title = widget.texts.change_image;\n            }\n            t = \"<div id='hallo_img_file_select_title'>\" + file_select_title + \"</div>\";\n            widget.options.dialog.children('#hallo_img_file_select_ui').html(t + data);\n            return widget.dialog_image_selection_ui_loaded = true;\n          },\n          beforeSend: function() {\n            return widget.options.dialog.children('#hallo_img_file_select_ui').html('<div class=\"hallo_insert_file_loader\"></div>');\n          }\n        });\n      },\n      _load_dialog_image_properties_ui: function() {\n        var $img_properties, button, height, html, widget, width;\n        widget = this;\n        $img_properties = this.options.dialog.children('#hallo_img_properties');\n        if (this.$image) {\n          width = this.$image.is('[width]') ? this.$image.attr('width') : '';\n          height = this.$image.is('[height]') ? this.$image.attr('height') : '';\n          html = this._property_input_html('source', this.$image.attr('src'), {\n            label: this.texts.source\n          }) + this._property_input_html('alt', this.$image.attr('alt') || '', {\n            label: this.texts.alt\n          }) + this._property_row_html(this._property_input_html('width', width, {\n            label: this.texts.width,\n            row: false\n          }) + this._property_input_html('height', height, {\n            label: this.texts.height,\n            row: false\n          })) + this._property_input_html('padding', this.$image.css('padding'), {\n            label: this.texts.padding\n          }) + this._property_row_html(this._property_cb_html('float_left', this.$image.css('float') === 'left', {\n            label: this.texts.float_left,\n            row: false\n          }) + this._property_cb_html('float_right', this.$image.css('float') === 'right', {\n            label: this.texts.float_right,\n            row: false\n          }) + this._property_cb_html('unfloat', this.$image.css('float') === 'none', {\n            label: this.texts.float_none,\n            row: false\n          }), this.texts[float]);\n          $img_properties.html(html);\n          $img_properties.show();\n        } else {\n          if (!this.options.insert_file_dialog_ui_url) {\n            $img_properties.html(this._property_input_html('source', '', {\n              label: this.texts.source\n            }));\n            $img_properties.show();\n          }\n        }\n        if (this.$image) {\n          if (!this.options.insert_file_dialog_ui_url) {\n            jQuery('#insert_image_btn').remove();\n          }\n          if (jQuery('#hallo_img_file_select_title').length > 0) {\n            jQuery('#hallo_img_file_select_title').text(this.texts.chage_image);\n          }\n          jQuery('#hallo_img_properties #hallo_img_source').keyup(function() {\n            return widget.$image.attr('src', this.value);\n          });\n          jQuery('#hallo_img_properties #hallo_img_alt').keyup(function() {\n            return widget.$image.attr('alt', this.value);\n          });\n          jQuery('#hallo_img_properties #hallo_img_padding').keyup(function() {\n            return widget.$image.css('padding', this.value);\n          });\n          jQuery('#hallo_img_properties #hallo_img_height').keyup(function() {\n            widget.$image.css('height', this.value);\n            return widget.$image.attr('height', this.value);\n          });\n          jQuery('#hallo_img_properties #hallo_img_width').keyup(function() {\n            widget.$image.css('width', this.value);\n            return widget.$image.attr('width', this.value);\n          });\n          jQuery('#hallo_img_properties #hallo_img_float_left').click(function() {\n            if (!this.checked) {\n              return false;\n            }\n            widget.$image.css('float', 'left');\n            jQuery('#hallo_img_properties #hallo_img_float_right').removeAttr('checked');\n            return jQuery('#hallo_img_properties #hallo_img_unfloat').removeAttr('checked');\n          });\n          jQuery('#hallo_img_properties #hallo_img_float_right').click(function() {\n            if (!this.checked) {\n              return false;\n            }\n            widget.$image.css('float', 'right');\n            jQuery('#hallo_img_properties #hallo_img_unfloat').removeAttr('checked');\n            return jQuery('#hallo_img_properties #hallo_img_float_left').removeAttr('checked');\n          });\n          return jQuery('#hallo_img_properties #hallo_img_unfloat').click(function() {\n            if (!this.checked) {\n              return false;\n            }\n            widget.$image.css('float', 'none');\n            jQuery('#hallo_img_properties #hallo_img_float_right').removeAttr('checked');\n            return jQuery('#hallo_img_properties #hallo_img_float_left').removeAttr('checked');\n          });\n        } else {\n          if (!this.options.insert_file_dialog_ui_url) {\n            button = \"<button id=\\\"insert_image_btn\\\">\" + this.texts.insert + \"</button>\";\n            $img_properties.after(button);\n            return jQuery('#insert_image_btn').click(function() {\n              var $img_source;\n              $img_source = jQuery('#hallo_img_properties #hallo_img_source');\n              return widget._insert_image($img_source.val());\n            });\n          }\n        }\n      },\n      _property_col_html: function(col_html) {\n        return \"<div class='hallo_img_property_col'>\" + col_html + \"</div>\";\n      },\n      _property_row_html: function(row_html, label) {\n        if (label == null) {\n          label = '';\n        }\n        row_html = this._property_col_html(label) + this._property_col_html(row_html);\n        return \"<div class='hallo_img_property_row'>\" + row_html + \"</div>\";\n      },\n      _property_html: function(property_html, options) {\n        var entry;\n        if (options == null) {\n          options = {};\n        }\n        if (options.row === false) {\n          if (options.label) {\n            entry = \"\" + options.label + \" \" + property_html;\n            property_html = \"<span class='img_property_entry'>\" + entry + \"</span>\";\n          }\n          return property_html;\n        } else {\n          entry = \"<span class='img_property_entry'>\" + property_html + \"</span>\";\n          return this._property_row_html(entry, options.label);\n        }\n      },\n      _property_input_html: function(id, value, options) {\n        var text_field;\n        if (options == null) {\n          options = {};\n        }\n        text_field = \"<input type='text' id='hallo_img_\" + id + \"' value='\" + value + \"'>\";\n        return this._property_html(text_field, options);\n      },\n      _property_cb_html: function(id, checked, options) {\n        var cb, checked_attr;\n        if (options == null) {\n          options = {};\n        }\n        checked_attr = checked ? 'checked=checked' : '';\n        cb = \"<input type='checkbox' id='hallo_img_\" + id + \"' \" + checked_attr + \"'>\";\n        return this._property_html(cb, options);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloindicator', {\n      options: {\n        editable: null,\n        className: 'halloEditIndicator'\n      },\n      _create: function() {\n        var _this = this;\n        return this.element.on('halloenabled', function() {\n          return _this.buildIndicator();\n        });\n      },\n      populateToolbar: function() {},\n      buildIndicator: function() {\n        var editButton;\n        editButton = jQuery('<div><i class=\"fa fa-edit\"></i> Edit</div>');\n        editButton.addClass(this.options.className);\n        editButton.hide();\n        this.element.before(editButton);\n        this.bindIndicator(editButton);\n        return this.setIndicatorPosition(editButton);\n      },\n      bindIndicator: function(indicator) {\n        var _this = this;\n        indicator.on('click', function() {\n          return _this.options.editable.element.focus();\n        });\n        this.element.on('halloactivated', function() {\n          return indicator.hide();\n        });\n        this.element.on('hallodisabled', function() {\n          return indicator.remove();\n        });\n        return this.options.editable.element.hover(function() {\n          if (jQuery(this).hasClass('inEditMode')) {\n            return;\n          }\n          return indicator.show();\n        }, function(data) {\n          if (jQuery(this).hasClass('inEditMode')) {\n            return;\n          }\n          if (data.relatedTarget === indicator.get(0)) {\n            return;\n          }\n          return indicator.hide();\n        });\n      },\n      setIndicatorPosition: function(indicator) {\n        var offset;\n        indicator.css('position', 'absolute');\n        offset = this.element.position();\n        indicator.css('top', offset.top + 2);\n        return indicator.css('left', offset.left + 2);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.hallojustify\", {\n      options: {\n        editable: null,\n        toolbar: null,\n        uuid: '',\n        buttonCssClass: null\n      },\n      populateToolbar: function(toolbar) {\n        var buttonize, buttonset,\n          _this = this;\n        buttonset = jQuery(\"<span class=\\\"\" + this.widgetName + \"\\\"></span>\");\n        buttonize = function(alignment) {\n          var buttonElement;\n          buttonElement = jQuery('<span></span>');\n          buttonElement.hallobutton({\n            uuid: _this.options.uuid,\n            editable: _this.options.editable,\n            label: alignment,\n            command: \"justify\" + alignment,\n            icon: \"fa-align-\" + (alignment.toLowerCase()),\n            cssClass: _this.options.buttonCssClass\n          });\n          return buttonset.append(buttonElement);\n        };\n        buttonize(\"Left\");\n        buttonize(\"Center\");\n        buttonize(\"Right\");\n        buttonset.hallobuttonset();\n        return toolbar.append(buttonset);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.hallolink\", {\n      options: {\n        editable: null,\n        uuid: \"\",\n        link: true,\n        image: true,\n        defaultUrl: 'http://',\n        dialogOpts: {\n          autoOpen: false,\n          width: 540,\n          height: 200,\n          title: \"Enter Link\",\n          buttonTitle: \"Insert\",\n          buttonUpdateTitle: \"Update\",\n          modal: true,\n          resizable: false,\n          draggable: false,\n          dialogClass: 'hallolink-dialog'\n        },\n        buttonCssClass: null\n      },\n      populateToolbar: function(toolbar) {\n        var butTitle, butUpdateTitle, buttonize, buttonset, dialog, dialogId, dialogSubmitCb, isEmptyLink, urlInput, widget,\n          _this = this;\n        widget = this;\n        dialogId = \"\" + this.options.uuid + \"-dialog\";\n        butTitle = this.options.dialogOpts.buttonTitle;\n        butUpdateTitle = this.options.dialogOpts.buttonUpdateTitle;\n        dialog = jQuery(\"<div id=\\\"\" + dialogId + \"\\\">        <form action=\\\"#\\\" method=\\\"post\\\" class=\\\"linkForm\\\">          <input class=\\\"url\\\" type=\\\"text\\\" name=\\\"url\\\"            value=\\\"\" + this.options.defaultUrl + \"\\\" />          <input type=\\\"submit\\\" id=\\\"addlinkButton\\\" value=\\\"\" + butTitle + \"\\\"/>        </form></div>\");\n        urlInput = jQuery('input[name=url]', dialog);\n        isEmptyLink = function(link) {\n          if ((new RegExp(/^\\s*$/)).test(link)) {\n            return true;\n          }\n          if (link === widget.options.defaultUrl) {\n            return true;\n          }\n          return false;\n        };\n        dialogSubmitCb = function(event) {\n          var link, linkNode;\n          event.preventDefault();\n          link = urlInput.val();\n          dialog.dialog('close');\n          widget.options.editable.restoreSelection(widget.lastSelection);\n          if (isEmptyLink(link)) {\n            document.execCommand(\"unlink\", null, \"\");\n          } else {\n            if (!(/:\\/\\//.test(link)) && !(/^mailto:/.test(link))) {\n              link = 'http://' + link;\n            }\n            if (widget.lastSelection.startContainer.parentNode.href === void 0) {\n              if (widget.lastSelection.collapsed) {\n                linkNode = jQuery(\"<a href='\" + link + \"'>\" + link + \"</a>\")[0];\n                widget.lastSelection.insertNode(linkNode);\n              } else {\n                //XXX not working?\n                //document.execCommand(\"createLink\", null, link);\n                var title = widget.lastSelection.toString();\n                widget.lastSelection.surroundContents(jQuery(\"<a href='\" + link + \"'></a>\")[0]);\n              }\n            } else {\n              widget.lastSelection.startContainer.parentNode.href = link;\n            }\n          }\n          widget.options.editable.element.trigger('change');\n          return false;\n        };\n        dialog.find(\"input[type=submit]\").click(dialogSubmitCb);\n        buttonset = jQuery(\"<span class=\\\"\" + widget.widgetName + \"\\\"></span>\");\n        buttonize = function(type) {\n          var button, buttonHolder, id;\n          id = \"\" + _this.options.uuid + \"-\" + type;\n          buttonHolder = jQuery('<span></span>');\n          buttonHolder.hallobutton({\n            label: 'Link',\n            icon: 'fa fa-link',\n            editable: _this.options.editable,\n            command: null,\n            queryState: false,\n            uuid: _this.options.uuid,\n            cssClass: _this.options.buttonCssClass\n          });\n          buttonset.append(buttonHolder);\n          button = buttonHolder;\n          button.on(\"click\", function(event) {\n            var button_selector, selectionParent;\n            widget.lastSelection = widget.options.editable.getSelection();\n            urlInput = jQuery('input[name=url]', dialog);\n            selectionParent = widget.lastSelection.startContainer.parentNode;\n            if (!selectionParent.href) {\n              urlInput.val(widget.options.defaultUrl);\n              jQuery(urlInput[0].form).find('input[type=submit]').val(butTitle);\n            } else {\n              urlInput.val(jQuery(selectionParent).attr('href'));\n              button_selector = 'input[type=submit]';\n              jQuery(urlInput[0].form).find(button_selector).val(butUpdateTitle);\n            }\n            widget.options.editable.keepActivated(true);\n            dialog.dialog('open');\n            dialog.on('dialogclose', function() {\n              widget.options.editable.restoreSelection(widget.lastSelection);\n              jQuery('label', buttonHolder).removeClass('ui-state-active');\n              widget.options.editable.element.focus();\n              return widget.options.editable.keepActivated(false);\n            });\n            return false;\n          });\n          return _this.element.on(\"keyup paste change mouseup\", function(event) {\n            var nodeName, start;\n            start = jQuery(widget.options.editable.getSelection().startContainer);\n            if (start.prop('nodeName')) {\n              nodeName = start.prop('nodeName');\n            } else {\n              nodeName = start.parent().prop('nodeName');\n            }\n            if (nodeName && nodeName.toUpperCase() === \"A\") {\n              jQuery('label', button).addClass('ui-state-active');\n              return;\n            }\n            return jQuery('label', button).removeClass('ui-state-active');\n          });\n        };\n        if (this.options.link) {\n          buttonize(\"A\");\n        }\n        if (this.options.link) {\n          toolbar.append(buttonset);\n          buttonset.hallobuttonset();\n          return dialog.dialog(this.options.dialogOpts);\n        }\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.hallolists\", {\n      options: {\n        editable: null,\n        toolbar: null,\n        uuid: '',\n        lists: {\n          ordered: true,\n          unordered: true\n        },\n        buttonCssClass: null\n      },\n      populateToolbar: function(toolbar) {\n        var buttonize, buttonset,\n          _this = this;\n        buttonset = jQuery(\"<span class=\\\"\" + this.widgetName + \"\\\"></span>\");\n        buttonize = function(type, label) {\n          var buttonElement;\n          buttonElement = jQuery('<span></span>');\n          buttonElement.hallobutton({\n            uuid: _this.options.uuid,\n            editable: _this.options.editable,\n            label: label,\n            command: \"insert\" + type + \"List\",\n            icon: \"fa-list-\" + (label.toLowerCase()),\n            cssClass: _this.options.buttonCssClass\n          });\n          return buttonset.append(buttonElement);\n        };\n        if (this.options.lists.ordered) {\n          buttonize(\"Ordered\", \"OL\");\n        }\n        if (this.options.lists.unordered) {\n          buttonize(\"Unordered\", \"UL\");\n        }\n        buttonset.hallobuttonset();\n        return toolbar.append(buttonset);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.hallooverlay\", {\n      options: {\n        editable: null,\n        toolbar: null,\n        uuid: \"\",\n        overlay: null,\n        padding: 10,\n        background: null\n      },\n      _create: function() {\n        var widget;\n        widget = this;\n        if (!this.options.bound) {\n          this.options.bound = true;\n          this.options.editable.element.on(\"halloactivated\", function(event, data) {\n            widget.options.currentEditable = jQuery(event.target);\n            if (!widget.options.visible) {\n              return widget.showOverlay();\n            }\n          });\n          this.options.editable.element.on(\"hallomodified\", function(event, data) {\n            widget.options.currentEditable = jQuery(event.target);\n            if (widget.options.visible) {\n              return widget.resizeOverlay();\n            }\n          });\n          return this.options.editable.element.on(\"hallodeactivated\", function(event, data) {\n            widget.options.currentEditable = jQuery(event.target);\n            if (widget.options.visible) {\n              return widget.hideOverlay();\n            }\n          });\n        }\n      },\n      showOverlay: function() {\n        this.options.visible = true;\n        if (this.options.overlay === null) {\n          if (jQuery(\"#halloOverlay\").length > 0) {\n            this.options.overlay = jQuery(\"#halloOverlay\");\n          } else {\n            this.options.overlay = jQuery(\"<div id=\\\"halloOverlay\\\"            class=\\\"halloOverlay\\\">\");\n            jQuery(document.body).append(this.options.overlay);\n          }\n          this.options.overlay.on('click', jQuery.proxy(this.options.editable.turnOff, this.options.editable));\n        }\n        this.options.overlay.show();\n        if (this.options.background === null) {\n          if (jQuery(\"#halloBackground\").length > 0) {\n            this.options.background = jQuery(\"#halloBackground\");\n          } else {\n            this.options.background = jQuery(\"<div id=\\\"halloBackground\\\"            class=\\\"halloBackground\\\">\");\n            jQuery(document.body).append(this.options.background);\n          }\n        }\n        this.resizeOverlay();\n        this.options.background.show();\n        if (!this.options.originalZIndex) {\n          this.options.originalZIndex = this.options.currentEditable.css(\"z-index\");\n        }\n        return this.options.currentEditable.css('z-index', '350');\n      },\n      resizeOverlay: function() {\n        var offset;\n        offset = this.options.currentEditable.offset();\n        return this.options.background.css({\n          top: offset.top - this.options.padding,\n          left: offset.left - this.options.padding,\n          width: this.options.currentEditable.width() + 2 * this.options.padding,\n          height: this.options.currentEditable.height() + 2 * this.options.padding\n        });\n      },\n      hideOverlay: function() {\n        this.options.visible = false;\n        this.options.overlay.hide();\n        this.options.background.hide();\n        return this.options.currentEditable.css('z-index', this.options.originalZIndex);\n      },\n      _findBackgroundColor: function(jQueryfield) {\n        var color;\n        color = jQueryfield.css(\"background-color\");\n        if (color !== 'rgba(0, 0, 0, 0)' && color !== 'transparent') {\n          return color;\n        }\n        if (jQueryfield.is(\"body\")) {\n          return \"white\";\n        } else {\n          return this._findBackgroundColor(jQueryfield.parent());\n        }\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.halloreundo\", {\n      options: {\n        editable: null,\n        toolbar: null,\n        uuid: '',\n        buttonCssClass: null\n      },\n      populateToolbar: function(toolbar) {\n        var buttonize, buttonset,\n          _this = this;\n        buttonset = jQuery(\"<span class=\\\"\" + this.widgetName + \"\\\"></span>\");\n        buttonize = function(cmd, label) {\n          var buttonElement;\n          buttonElement = jQuery('<span></span>');\n          buttonElement.hallobutton({\n            uuid: _this.options.uuid,\n            editable: _this.options.editable,\n            label: label,\n            icon: cmd === 'undo' ? 'fa-undo' : 'fa-repeat',\n            command: cmd,\n            queryState: false,\n            cssClass: _this.options.buttonCssClass\n          });\n          return buttonset.append(buttonElement);\n        };\n        buttonize(\"undo\", \"Undo\");\n        buttonize(\"redo\", \"Redo\");\n        buttonset.hallobuttonset();\n        return toolbar.append(buttonset);\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget(\"IKS.hallotoolbarlinebreak\", {\n      options: {\n        editable: null,\n        uuid: \"\",\n        breakAfter: []\n      },\n      populateToolbar: function(toolbar) {\n        var buttonRow, buttonset, buttonsets, queuedButtonsets, row, rowcounter, _i, _j, _len, _len1, _ref;\n        buttonsets = jQuery('.ui-buttonset', toolbar);\n        queuedButtonsets = jQuery();\n        rowcounter = 0;\n        _ref = this.options.breakAfter;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          row = _ref[_i];\n          rowcounter++;\n          buttonRow = \"<div          class=\\\"halloButtonrow halloButtonrow-\" + rowcounter + \"\\\" />\";\n          for (_j = 0, _len1 = buttonsets.length; _j < _len1; _j++) {\n            buttonset = buttonsets[_j];\n            queuedButtonsets = jQuery(queuedButtonsets).add(jQuery(buttonset));\n            if (jQuery(buttonset).hasClass(row)) {\n              queuedButtonsets.wrapAll(buttonRow);\n              buttonsets = buttonsets.not(queuedButtonsets);\n              queuedButtonsets = jQuery();\n              break;\n            }\n          }\n        }\n        if (buttonsets.length > 0) {\n          rowcounter++;\n          buttonRow = \"<div          class=\\\"halloButtonrow halloButtonrow-\" + rowcounter + \"\\\" />\";\n          return buttonsets.wrapAll(buttonRow);\n        }\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloToolbarContextual', {\n      toolbar: null,\n      options: {\n        parentElement: 'body',\n        editable: null,\n        toolbar: null,\n        positionAbove: false\n      },\n      _create: function() {\n        var _this = this;\n        this.toolbar = this.options.toolbar;\n        jQuery(this.options.parentElement).append(this.toolbar);\n        this._bindEvents();\n        return jQuery(window).resize(function(event) {\n          return _this._updatePosition(_this._getPosition(event));\n        });\n      },\n      _getPosition: function(event, selection) {\n        var eventType, position;\n        if (!event) {\n          return;\n        }\n        eventType = event.type;\n        switch (eventType) {\n          case 'keydown':\n          case 'keyup':\n          case 'keypress':\n            return this._getCaretPosition(selection);\n          case 'click':\n          case 'mousedown':\n          case 'mouseup':\n            return position = {\n              top: event.pageY,\n              left: event.pageX\n            };\n        }\n      },\n      _getCaretPosition: function(range) {\n        var newRange, position, tmpSpan;\n        tmpSpan = jQuery(\"<span/>\");\n        newRange = rangy.createRange();\n        newRange.setStart(range.endContainer, range.endOffset);\n        newRange.insertNode(tmpSpan.get(0));\n        position = {\n          top: tmpSpan.offset().top,\n          left: tmpSpan.offset().left\n        };\n        tmpSpan.remove();\n        return position;\n      },\n      setPosition: function() {\n        if (this.options.parentElement !== 'body') {\n          this.options.parentElement = 'body';\n          jQuery(this.options.parentElement).append(this.toolbar);\n        }\n        this.toolbar.css('position', 'absolute');\n        this.toolbar.css('top', this.element.offset().top - 20);\n        return this.toolbar.css('left', this.element.offset().left);\n      },\n      _updatePosition: function(position, selection) {\n        var left, selectionRect, toolbar_height_offset, top, top_offset;\n        if (selection == null) {\n          selection = null;\n        }\n        if (!position) {\n          return;\n        }\n        if (!(position.top && position.left)) {\n          return;\n        }\n        toolbar_height_offset = this.toolbar.outerHeight() + 10;\n        if (selection && !selection.collapsed && selection.nativeRange) {\n          selectionRect = selection.nativeRange.getBoundingClientRect();\n          if (this.options.positionAbove) {\n            top_offset = selectionRect.top - toolbar_height_offset;\n          } else {\n            top_offset = selectionRect.bottom + 10;\n          }\n          top = jQuery(window).scrollTop() + top_offset;\n          left = jQuery(window).scrollLeft() + selectionRect.left;\n        } else {\n          if (this.options.positionAbove) {\n            top_offset = -10 - toolbar_height_offset;\n          } else {\n            top_offset = 20;\n          }\n          top = position.top + top_offset;\n          left = position.left - this.toolbar.outerWidth() / 2 + 30;\n        }\n        this.toolbar.css('top', top);\n        return this.toolbar.css('left', left);\n      },\n      _bindEvents: function() {\n        var _this = this;\n        this.element.on('click', function(event, data) {\n          var position, scrollTop;\n          position = {};\n          scrollTop = $('window').scrollTop();\n          position.top = event.clientY + scrollTop;\n          position.left = event.clientX;\n          _this._updatePosition(position, null);\n          if (_this.toolbar.html() !== '') {\n            return _this.toolbar.show();\n          }\n        });\n        this.element.on('halloselected', function(event, data) {\n          var position;\n          position = _this._getPosition(data.originalEvent, data.selection);\n          if (!position) {\n            return;\n          }\n          _this._updatePosition(position, data.selection);\n          if (_this.toolbar.html() !== '') {\n            return _this.toolbar.show();\n          }\n        });\n        this.element.on('hallounselected', function(event, data) {\n          return _this.toolbar.hide();\n        });\n        return this.element.on('hallodeactivated', function(event, data) {\n          return _this.toolbar.hide();\n        });\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloToolbarFixed', {\n      toolbar: null,\n      options: {\n        parentElement: 'body',\n        editable: null,\n        toolbar: null,\n        affix: true,\n        affixTopOffset: 2\n      },\n      _create: function() {\n        var el, widthToAdd,\n          _this = this;\n        this.toolbar = this.options.toolbar;\n        this.toolbar.show();\n        jQuery(this.options.parentElement).append(this.toolbar);\n        this._bindEvents();\n        jQuery(window).resize(function(event) {\n          return _this.setPosition();\n        });\n        jQuery(window).scroll(function(event) {\n          return _this.setPosition();\n        });\n        if (this.options.parentElement === 'body') {\n          el = jQuery(this.element);\n          widthToAdd = parseFloat(el.css('padding-left'));\n          widthToAdd += parseFloat(el.css('padding-right'));\n          widthToAdd += parseFloat(el.css('border-left-width'));\n          widthToAdd += parseFloat(el.css('border-right-width'));\n          widthToAdd += (parseFloat(el.css('outline-width'))) * 2;\n          widthToAdd += (parseFloat(el.css('outline-offset'))) * 2;\n          return jQuery(this.toolbar).css(\"width\", el.width() + widthToAdd);\n        }\n      },\n      _getPosition: function(event, selection) {\n        var offset, position, width;\n        if (!event) {\n          return;\n        }\n        width = parseFloat(this.element.css('outline-width'));\n        offset = width + parseFloat(this.element.css('outline-offset'));\n        return position = {\n          top: this.element.offset().top - this.toolbar.outerHeight() - offset,\n          left: this.element.offset().left - offset\n        };\n      },\n      _getCaretPosition: function(range) {\n        var newRange, position, tmpSpan;\n        tmpSpan = jQuery(\"<span/>\");\n        newRange = rangy.createRange();\n        newRange.setStart(range.endContainer, range.endOffset);\n        newRange.insertNode(tmpSpan.get(0));\n        position = {\n          top: tmpSpan.offset().top,\n          left: tmpSpan.offset().left\n        };\n        tmpSpan.remove();\n        return position;\n      },\n      setPosition: function() {\n        var elementBottom, elementTop, height, offset, scrollTop, topOffset;\n        if (this.options.parentElement !== 'body') {\n          return;\n        }\n        this.toolbar.css('position', 'absolute');\n        this.toolbar.css('top', this.element.offset().top - this.toolbar.outerHeight());\n        if (this.options.affix) {\n          scrollTop = jQuery(window).scrollTop();\n          offset = this.element.offset();\n          height = this.element.height();\n          topOffset = this.options.affixTopOffset;\n          elementTop = offset.top - (this.toolbar.height() + this.options.affixTopOffset);\n          elementBottom = (height - topOffset) + (offset.top - this.toolbar.height());\n          if (scrollTop > elementTop && scrollTop < elementBottom) {\n            this.toolbar.css('position', 'fixed');\n            this.toolbar.css('top', this.options.affixTopOffset);\n          }\n        } else {\n\n        }\n        return this.toolbar.css('left', this.element.offset().left - 2);\n      },\n      _updatePosition: function(position) {},\n      _bindEvents: function() {\n        var _this = this;\n        this.element.on('halloactivated', function(event, data) {\n          _this.setPosition();\n          return _this.toolbar.show();\n        });\n        return this.element.on('hallodeactivated', function(event, data) {\n          return _this.toolbar.hide();\n        });\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.halloToolbarInstant', {\n      toolbar: null,\n      options: {\n        parentElement: 'body',\n        editable: null,\n        toolbar: null,\n        positionAbove: false\n      },\n      _create: function() {\n        var _this = this;\n        this.toolbar = this.options.toolbar;\n        jQuery(this.options.parentElement).append(this.toolbar);\n        this._bindEvents();\n        return jQuery(window).resize(function(event) {\n          return _this._updatePosition(_this._getPosition(event));\n        });\n      },\n      _getPosition: function(event, selection) {\n        var eventType, position;\n        if (!event) {\n          return;\n        }\n        eventType = event.type;\n        switch (eventType) {\n          case 'keydown':\n          case 'keyup':\n          case 'keypress':\n            return this._getCaretPosition(selection);\n          case 'click':\n          case 'mousedown':\n          case 'mouseup':\n            return position = {\n              top: event.pageY,\n              left: event.pageX\n            };\n        }\n      },\n      _getCaretPosition: function(range) {\n        var newRange, position, tmpSpan;\n        tmpSpan = jQuery(\"<span/>\");\n        newRange = rangy.createRange();\n        newRange.setStart(range.endContainer, range.endOffset);\n        newRange.insertNode(tmpSpan.get(0));\n        position = {\n          top: tmpSpan.offset().top,\n          left: tmpSpan.offset().left\n        };\n        tmpSpan.remove();\n        return position;\n      },\n      setPosition: function() {\n        if (this.options.parentElement !== 'body') {\n          this.options.parentElement = 'body';\n          jQuery(this.options.parentElement).append(this.toolbar);\n        }\n        this.toolbar.css('position', 'absolute');\n        this.toolbar.css('top', this.element.offset().top - 20);\n        return this.toolbar.css('left', this.element.offset().left);\n      },\n      _updatePosition: function(position, selection) {\n        var left, selectionRect, toolbar_height_offset, top, top_offset;\n        if (selection == null) {\n          selection = null;\n        }\n        if (!position) {\n          return;\n        }\n        if (!(position.top && position.left)) {\n          return;\n        }\n        toolbar_height_offset = this.toolbar.outerHeight() + 10;\n        if (selection && !selection.collapsed && selection.nativeRange) {\n          selectionRect = selection.nativeRange.getBoundingClientRect();\n          if (this.options.positionAbove) {\n            top_offset = selectionRect.top - toolbar_height_offset;\n          } else {\n            top_offset = selectionRect.bottom + 10;\n          }\n          top = jQuery(window).scrollTop() + top_offset;\n          left = jQuery(window).scrollLeft() + selectionRect.left;\n        } else {\n          if (this.options.positionAbove) {\n            top_offset = -10 - toolbar_height_offset;\n          } else {\n            top_offset = 20;\n          }\n          top = position.top + top_offset;\n          left = position.left - this.toolbar.outerWidth() / 2 + 30;\n        }\n        this.toolbar.css('top', top);\n        return this.toolbar.css('left', left);\n      },\n      _bindEvents: function() {\n        var _this = this;\n        this.element.on('click', function(event, data) {\n          var position, scrollTop;\n          position = {};\n          scrollTop = $('window').scrollTop();\n          position.top = event.clientY + scrollTop;\n          position.left = event.clientX;\n          _this._updatePosition(position, null);\n          if (_this.toolbar.html() !== '') {\n            return _this.toolbar.show();\n          }\n        });\n        this.element.on('halloselected', function(event, data) {\n          var position;\n          position = _this._getPosition(data.originalEvent, data.selection);\n          if (!position) {\n            return;\n          }\n          _this._updatePosition(position, data.selection);\n          if (_this.toolbar.html() !== '') {\n            return _this.toolbar.show();\n          }\n        });\n        this.element.on('hallounselected', function(event, data) {\n          return _this.toolbar.hide();\n        });\n        return this.element.on('hallodeactivated', function(event, data) {\n          return _this.toolbar.hide();\n        });\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    jQuery.widget('IKS.hallobutton', {\n      button: null,\n      isChecked: false,\n      options: {\n        uuid: '',\n        label: null,\n        icon: null,\n        editable: null,\n        command: null,\n        commandValue: null,\n        queryState: true,\n        cssClass: null\n      },\n      _create: function() {\n        var hoverclass, id, opts, _base,\n          _this = this;\n        if ((_base = this.options).icon == null) {\n          _base.icon = \"fa-\" + (this.options.label.toLowerCase());\n        }\n        id = \"\" + this.options.uuid + \"-\" + this.options.label;\n        opts = this.options;\n        this.button = this._createButton(id, opts.command, opts.label, opts.icon);\n        this.element.append(this.button);\n        if (this.options.cssClass) {\n          this.button.addClass(this.options.cssClass);\n        }\n        if (this.options.editable.options.touchScreen) {\n          this.button.addClass('btn-large');\n        }\n        this.button.data('hallo-command', this.options.command);\n        if (this.options.commandValue) {\n          this.button.data('hallo-command-value', this.options.commandValue);\n        }\n        hoverclass = 'ui-state-hover';\n        this.button.on('mouseenter', function(event) {\n          if (_this.isEnabled()) {\n            return _this.button.addClass(hoverclass);\n          }\n        });\n        return this.button.on('mouseleave', function(event) {\n          return _this.button.removeClass(hoverclass);\n        });\n      },\n      _init: function() {\n        var editableElement, events, queryState,\n          _this = this;\n        if (!this.button) {\n          this.button = this._prepareButton();\n        }\n        this.element.append(this.button);\n        if (this.options.queryState === true) {\n          queryState = function(event) {\n            var compared, e, value;\n            if (!_this.options.command) {\n              return;\n            }\n            try {\n              if (_this.options.commandValue) {\n                value = document.queryCommandValue(_this.options.command);\n                compared = value.match(new RegExp(_this.options.commandValue, \"i\"));\n                return _this.checked(compared ? true : false);\n              } else {\n                return _this.checked(document.queryCommandState(_this.options.command));\n              }\n            } catch (_error) {\n              e = _error;\n            }\n          };\n        } else {\n          queryState = this.options.queryState;\n        }\n        if (this.options.command) {\n          this.button.on('click', function(event) {\n            if (_this.options.commandValue) {\n              _this.options.editable.execute(_this.options.command, _this.options.commandValue);\n            } else {\n              _this.options.editable.execute(_this.options.command);\n            }\n            if (typeof queryState === 'function') {\n              queryState();\n            }\n            return false;\n          });\n        }\n        if (!this.options.queryState) {\n          return;\n        }\n        editableElement = this.options.editable.element;\n        events = 'keyup paste change mouseup hallomodified';\n        editableElement.on(events, queryState);\n        editableElement.on('halloenabled', function() {\n          return editableElement.on(events, queryState);\n        });\n        return editableElement.on('hallodisabled', function() {\n          return editableElement.off(events, queryState);\n        });\n      },\n      enable: function() {\n        return this.button.removeAttr('disabled');\n      },\n      disable: function() {\n        return this.button.attr('disabled', 'true');\n      },\n      isEnabled: function() {\n        return this.button.attr('disabled') !== 'true';\n      },\n      refresh: function() {\n        if (this.isChecked) {\n          return this.button.addClass('ui-state-active');\n        } else {\n          return this.button.removeClass('ui-state-active');\n        }\n      },\n      checked: function(checked) {\n        this.isChecked = checked;\n        return this.refresh();\n      },\n      _createButton: function(id, command, label, icon) {\n        var classes;\n        classes = ['ui-button', 'ui-widget', 'ui-state-default', 'ui-corner-all', 'ui-button-text-only', \"\" + command + \"_button\"];\n        return jQuery(\"<button id=\\\"\" + id + \"\\\"        class=\\\"\" + (classes.join(' ')) + \"\\\" title=\\\"\" + label + \"\\\">          <span class=\\\"ui-button-text\\\">            <i class=\\\"fa \" + icon + \"\\\"></i>          </span>        </button>\");\n      }\n    });\n    return jQuery.widget('IKS.hallobuttonset', {\n      buttons: null,\n      _create: function() {\n        return this.element.addClass('ui-buttonset');\n      },\n      _init: function() {\n        return this.refresh();\n      },\n      refresh: function() {\n        var rtl;\n        rtl = this.element.css('direction') === 'rtl';\n        this.buttons = this.element.find('.ui-button');\n        this.buttons.removeClass('ui-corner-all ui-corner-left ui-corner-right');\n        if (rtl) {\n          this.buttons.filter(':first').addClass('ui-corner-right');\n          return this.buttons.filter(':last').addClass('ui-corner-left');\n        } else {\n          this.buttons.filter(':first').addClass('ui-corner-left');\n          return this.buttons.filter(':last').addClass('ui-corner-right');\n        }\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n\n(function() {\n  (function(jQuery) {\n    return jQuery.widget('IKS.hallodropdownbutton', {\n      button: null,\n      options: {\n        uuid: '',\n        label: null,\n        icon: null,\n        editable: null,\n        target: '',\n        cssClass: null\n      },\n      _create: function() {\n        var _base;\n        return (_base = this.options).icon != null ? (_base = this.options).icon : _base.icon = \"fa-\" + (this.options.label.toLowerCase());\n      },\n      _init: function() {\n        var target,\n          _this = this;\n        target = jQuery(this.options.target);\n        target.css('position', 'absolute');\n        target.addClass('dropdown-menu');\n        target.hide();\n        if (!this.button) {\n          this.button = this._prepareButton();\n        }\n        this.button.on('click', function() {\n          if (target.hasClass('open')) {\n            _this._hideTarget();\n            return;\n          }\n          return _this._showTarget();\n        });\n        target.on('click', function() {\n          return _this._hideTarget();\n        });\n        this.options.editable.element.on('hallodeactivated', function() {\n          return _this._hideTarget();\n        });\n        return this.element.append(this.button);\n      },\n      _showTarget: function() {\n        var target;\n        target = jQuery(this.options.target);\n        this._updateTargetPosition();\n        target.addClass('open');\n        return target.show();\n      },\n      _hideTarget: function() {\n        var target;\n        target = jQuery(this.options.target);\n        target.removeClass('open');\n        return target.hide();\n      },\n      _updateTargetPosition: function() {\n        var left, target, top, _ref;\n        target = jQuery(this.options.target);\n        _ref = this.button.position(), top = _ref.top, left = _ref.left;\n        top += this.button.outerHeight();\n        target.css('top', top);\n        return target.css('left', left - 20);\n      },\n      _prepareButton: function() {\n        var buttonEl, classes, id;\n        id = \"\" + this.options.uuid + \"-\" + this.options.label;\n        classes = ['ui-button', 'ui-widget', 'ui-state-default', 'ui-corner-all', 'ui-button-text-only'];\n        buttonEl = jQuery(\"<button id=\\\"\" + id + \"\\\"       class=\\\"\" + (classes.join(' ')) + \"\\\" title=\\\"\" + this.options.label + \"\\\">         <span class=\\\"ui-button-text\\\">           <i class=\\\"fa \" + this.options.icon + \"\\\"></i>         </span>       </button>\");\n        if (this.options.cssClass) {\n          buttonEl.addClass(this.options.cssClass);\n        }\n        return buttonEl;\n      }\n    });\n  })(jQuery);\n\n}).call(this);\n"},186:function(t,n,e){e(1)(e(187))},187:function(t,n){t.exports="/*!\n * jQuery Textarea AutoSize plugin\n * Author: Javier Julio\n * Licensed under the MIT license\n */\n;(function ($, window, document, undefined) {\n\n  var pluginName = \"textareaAutoSize\";\n  var pluginDataName = \"plugin_\" + pluginName;\n\n  var containsText = function (value) {\n    return (value.replace(/\\s/g, '').length > 0);\n  };\n\n  function Plugin(element, options) {\n    this.element = element;\n    this.$element = $(element);\n    this.init();\n  }\n\n  Plugin.prototype = {\n    init: function() {\n      var height = this.$element.outerHeight();\n      var diff = parseInt(this.$element.css('paddingBottom')) +\n                 parseInt(this.$element.css('paddingTop')) || 0;\n\n      if (containsText(this.element.value)) {\n        this.$element.height(this.element.scrollHeight - diff);\n      }\n\n      // keyup is required for IE to properly reset height when deleting text\n      this.$element.on('input keyup', function(event) {\n        var $window = $(window);\n        var currentScrollPosition = $window.scrollTop();\n\n        $(this)\n          .height(0)\n          .height(this.scrollHeight - diff);\n\n        $window.scrollTop(currentScrollPosition);\n      });\n    }\n  };\n\n  $.fn[pluginName] = function (options) {\n    this.each(function() {\n      if (!$.data(this, pluginDataName)) {\n        $.data(this, pluginDataName, new Plugin(this, options));\n      }\n    });\n    return this;\n  };\n\n})(jQuery, window, document);\n"},188:function(t,n,e){e(1)(e(189))},189:function(t,n){t.exports="/*!\n * jQuery UI Touch Punch 0.2.3\n *\n * Copyright 2011–2014, Dave Furfero\n * Dual licensed under the MIT or GPL Version 2 licenses.\n *\n * Depends:\n *  jquery.ui.widget.js\n *  jquery.ui.mouse.js\n */\n(function ($) {\n\n  // Detect touch support\n  $.support.touch = 'ontouchend' in document;\n\n  // Ignore browsers without touch support\n  if (!$.support.touch) {\n    return;\n  }\n\n  var mouseProto = $.ui.mouse.prototype,\n      _mouseInit = mouseProto._mouseInit,\n      _mouseDestroy = mouseProto._mouseDestroy,\n      touchHandled;\n\n  /**\n   * Simulate a mouse event based on a corresponding touch event\n   * @param {Object} event A touch event\n   * @param {String} simulatedType The corresponding mouse event\n   */\n  function simulateMouseEvent (event, simulatedType) {\n\n    // Ignore multi-touch events\n    if (event.originalEvent.touches.length > 1) {\n      return;\n    }\n\n    event.preventDefault();\n\n    var touch = event.originalEvent.changedTouches[0],\n        simulatedEvent = document.createEvent('MouseEvents');\n    \n    // Initialize the simulated mouse event using the touch event's coordinates\n    simulatedEvent.initMouseEvent(\n      simulatedType,    // type\n      true,             // bubbles                    \n      true,             // cancelable                 \n      window,           // view                       \n      1,                // detail                     \n      touch.screenX,    // screenX                    \n      touch.screenY,    // screenY                    \n      touch.clientX,    // clientX                    \n      touch.clientY,    // clientY                    \n      false,            // ctrlKey                    \n      false,            // altKey                     \n      false,            // shiftKey                   \n      false,            // metaKey                    \n      0,                // button                     \n      null              // relatedTarget              \n    );\n\n    // Dispatch the simulated event to the target element\n    event.target.dispatchEvent(simulatedEvent);\n  }\n\n  /**\n   * Handle the jQuery UI widget's touchstart events\n   * @param {Object} event The widget element's touchstart event\n   */\n  mouseProto._touchStart = function (event) {\n\n    var self = this;\n\n    // Ignore the event if another widget is already being handled\n    if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {\n      return;\n    }\n\n    // Set the flag to prevent other widgets from inheriting the touch event\n    touchHandled = true;\n\n    // Track movement to determine if interaction was a click\n    self._touchMoved = false;\n\n    // Simulate the mouseover event\n    simulateMouseEvent(event, 'mouseover');\n\n    // Simulate the mousemove event\n    simulateMouseEvent(event, 'mousemove');\n\n    // Simulate the mousedown event\n    simulateMouseEvent(event, 'mousedown');\n  };\n\n  /**\n   * Handle the jQuery UI widget's touchmove events\n   * @param {Object} event The document's touchmove event\n   */\n  mouseProto._touchMove = function (event) {\n\n    // Ignore event if not handled\n    if (!touchHandled) {\n      return;\n    }\n\n    // Interaction was not a click\n    this._touchMoved = true;\n\n    // Simulate the mousemove event\n    simulateMouseEvent(event, 'mousemove');\n  };\n\n  /**\n   * Handle the jQuery UI widget's touchend events\n   * @param {Object} event The document's touchend event\n   */\n  mouseProto._touchEnd = function (event) {\n\n    // Ignore event if not handled\n    if (!touchHandled) {\n      return;\n    }\n\n    // Simulate the mouseup event\n    simulateMouseEvent(event, 'mouseup');\n\n    // Simulate the mouseout event\n    simulateMouseEvent(event, 'mouseout');\n\n    // If the touch interaction did not move, it should trigger a click\n    if (!this._touchMoved) {\n\n      // Simulate the click event\n      simulateMouseEvent(event, 'click');\n    }\n\n    // Unset the flag to allow other widgets to inherit the touch event\n    touchHandled = false;\n  };\n\n  /**\n   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.\n   * This method extends the widget with bound touch event handlers that\n   * translate touch events to mouse events and pass them to the widget's\n   * original mouse event handling methods.\n   */\n  mouseProto._mouseInit = function () {\n    \n    var self = this;\n\n    // Delegate the touch handlers to the widget's element\n    self.element.bind({\n      touchstart: $.proxy(self, '_touchStart'),\n      touchmove: $.proxy(self, '_touchMove'),\n      touchend: $.proxy(self, '_touchEnd')\n    });\n\n    // Call the original $.ui.mouse init method\n    _mouseInit.call(self);\n  };\n\n  /**\n   * Remove the touch event handlers\n   */\n  mouseProto._mouseDestroy = function () {\n    \n    var self = this;\n\n    // Delegate the touch handlers to the widget's element\n    self.element.unbind({\n      touchstart: $.proxy(self, '_touchStart'),\n      touchmove: $.proxy(self, '_touchMove'),\n      touchend: $.proxy(self, '_touchEnd')\n    });\n\n    // Call the original $.ui.mouse destroy method\n    _mouseDestroy.call(self);\n  };\n\n})(jQuery);"},190:function(t,n,e){e(1)(e(191))},191:function(t,n){t.exports='/**\n   Functionality related to the wysiwyg editor in djaodjin-pages.\n\n   These are based on jquery.\n */\n\n/* global location setTimeout jQuery */\n/* global getMetaCSRFToken showMessages */\n\n(function ($) {\n    "use strict";\n\n    function BaseEditor(element, options){\n        var self = this;\n        self.el = element;\n        self.$el = $(element);\n        self.options = options;\n        self.init();\n        return self;\n    }\n\n    BaseEditor.prototype = {\n        init: function(){\n            var self = this;\n        },\n\n        _getCSRFToken: function() {\n            var self = this;\n            var crsfNode = self.el.find("[name=\'csrfmiddlewaretoken\']");\n            if( crsfNode.length > 0 ) {\n                return crsfNode.val();\n            }\n            return getMetaCSRFToken();\n        },\n\n        getId: function() {\n            var self = this;\n            var slug = self.$el.attr(self.options.uniqueIdentifier);\n            if( !slug ) {\n                slug = self.$el.parents(\n                    "[" + self.options.uniqueIdentifier + "]").attr(\n                        self.options.uniqueIdentifier);\n            }\n            if( !slug ) {\n                slug = "undefined";\n            }\n            return slug;\n        },\n\n        elementUrl: function() {\n            var self = this;\n            var path = self.getId();\n            // We make sure that if either `baseUrl` or `path` ends with,\n            // respectively starts with, a \'/\' or not, concatenation will\n            // not result in a \'//\'.\n            if( path.indexOf(\'/\') != 0 ) path = \'/\' + path\n            return self.options.baseUrl.replace(/\\/+$/, "") + path;\n        },\n\n        addTags: function(tags) {\n            var self = this;\n            $.ajax({\n                method: "PUT",\n                url: self.elementUrl() + "/add-tags/",\n                beforeSend: function(xhr) {\n                    xhr.setRequestHeader("X-CSRFToken", self._getCSRFToken());\n                },\n                data: JSON.stringify({"tag": tags}),\n                datatype: "json",\n                contentType: "application/json; charset=utf-8",\n                success: function(resp) {\n                    self.options.onSuccess(self, resp);\n                },\n                error: self.options.onError\n            });\n        },\n\n        removeTags: function(tags) {\n            var self = this;\n            $.ajax({\n                method: "PUT",\n                url: self.elementUrl() + "/remove-tags/",\n                beforeSend: function(xhr) {\n                    xhr.setRequestHeader("X-CSRFToken", self._getCSRFToken());\n                },\n                data: JSON.stringify({"tag": tags}),\n                datatype: "json",\n                contentType: "application/json; charset=utf-8",\n                success: function(resp) {\n                    self.options.onSuccess(self, resp);\n                },\n                error: self.options.onError\n            });\n        },\n    };\n\n    $.fn.baseEditor = function(options, custom){\n        var opts = $.extend( {}, $.fn.baseEditor.defaults, options );\n        return this.each(function() {\n            $(this).data("editor", new BaseEditor($(this), opts));\n        });\n    };\n\n    $.fn.baseEditor.defaults = {\n        baseUrl: null, // Url to send request to server\n        uniqueIdentifier: "id",\n        hints: null,\n        onSuccess: function(element, resp){\n            return true;\n        },\n        onError: function(resp){\n            showErrorMessages(resp);\n        },\n    };\n\n    /**\n     */\n    function Editor(element, options){\n        var self = this;\n        self.el = element;\n        self.$el = $(element);\n        self.options = options;\n        self.init();\n        return self;\n    }\n\n    Editor.prototype = $.extend({}, BaseEditor.prototype, {\n        init: function(){\n            var self = this;\n            self.$el.on("click", function(){\n                self.toggleEdition();\n            });\n            self.$el.on("blur", function(){\n                self.saveEdition();\n            });\n            self.$el.on("mouseover mouseleave", function(event){\n                self.hoverElement(event);\n            });\n            if( self.options.focus ) {\n                self.toggleEdition();\n            }\n        },\n\n        hoverElement: function(event){\n            var self = this;\n            if (event.type === "mouseover"){\n                self.$el.addClass("hover-editable");\n            }else{\n                self.$el.removeClass("hover-editable");\n            }\n        },\n\n        getOriginText: function(){\n            var self = this;\n            self.originText = $.trim(self.$el[0].outerHTML);\n            return self.originText;\n        },\n\n        toogleStartOptional: function(){\n            return true;\n        },\n\n        toogleEndOptional: function(){\n            return true;\n        },\n\n        initHallo: function(){\n            var self = this;\n            self.$el.hallo().focus();\n        },\n\n        toggleEdition: function(){\n            var self = this;\n            self.initHallo();\n            self.getOriginText();\n            self.$el.attr("placeholder", self.options.emptyInputText);\n        },\n\n        getSavedText: function(){\n            var self = this;\n            return $.trim(self.$el.html());\n        },\n\n        checkInput: function(){\n            var self = this;\n            if (self.getSavedText() === ""){\n                return false;\n            }else{\n                return true;\n            }\n        },\n\n        formatDisplayedValue: function(){\n            return true;\n        },\n\n        saveEdition: function(){\n            var self = this;\n            if( !self.checkInput() ) {\n                return false;\n            }\n\n            var data = {};\n            var method = "PUT";\n            var savedText = self.getSavedText();\n            if (self.$el.attr("data-key")){\n                data[self.$el.attr("data-key")] = savedText;\n            } else {\n                data = {\n                    slug: self.getId(),\n                    text: savedText\n                };\n            }\n            if( self.options.hints ) {\n                data[\'hints\'] = self.options.hints;\n            }\n\n            if( self.options.debug ) {\n                console.log("data-key:", self.$el.attr("data-key"),\n                    "send:", data);\n            }\n            $.ajax({\n                method: method,\n                url: self.elementUrl(),\n                beforeSend: function(xhr) {\n                    xhr.setRequestHeader("X-CSRFToken", self._getCSRFToken());\n                },\n                data: JSON.stringify(data),\n                datatype: "json",\n                contentType: "application/json; charset=utf-8",\n                success: function(resp) {\n                    self.options.onSuccess(self, resp);\n                    self.$el.removeAttr("contenteditable");\n                    self.formatDisplayedValue();\n                },\n                error: self.options.onError\n            });\n        }\n    });\n\n    function CurrencyEditor(element, options){\n        var self = this;\n        self.el = element;\n        self.$el = $(element);\n        self.options = options;\n        self.init();\n        return self;\n    }\n\n    CurrencyEditor.prototype = $.extend({}, Editor.prototype, {\n        getSavedText: function(){\n            var self = this;\n            var enteredValue = self.$el.text();\n            var amount = parseInt(\n                (parseFloat(enteredValue.replace(/[^0-9\\.]+/g, "")) * 100).toFixed(2));\n            return amount;\n        },\n\n        formatDisplayedValue: function(){\n            var self = this;\n            var defaultCurrencyUnit = "$";\n            var defaultCurrencyPosition = "before";\n            if (self.$el.data("currency-unit")){\n                defaultCurrencyUnit = self.$el.data("currency-unit");\n            }\n\n            if (self.$el.data("currency-position")){\n                defaultCurrencyPosition = self.$el.data("currency-position");\n            }\n\n            var amount = String((self.getSavedText() / 100).toFixed(2));\n            if (defaultCurrencyPosition === "before"){\n                amount = defaultCurrencyUnit + amount;\n            }else if(defaultCurrencyPosition === "after"){\n                amount = amount + defaultCurrencyUnit;\n            }\n            self.$el.html(amount);\n        }\n    });\n\n    function FormattedEditor(element, options){\n        var self = this;\n        self.el = element;\n        self.$el = $(element);\n        self.options = options;\n        self.init();\n        return self;\n    }\n\n    FormattedEditor.prototype = $.extend({}, Editor.prototype, {\n        initHallo: function(){\n            var self = this;\n            self.$el.hallo({\n                plugins: {\n                    "halloheadings": {},\n                    "halloformat": {},\n                    "halloblock": {},\n                    "hallojustify": {},\n                    "hallolists": {},\n                    "hallolink": {},\n                    "halloreundo": {}\n                },\n                editable: true,\n                toolbar: "halloToolbarFixed"\n            }).focus();\n            self.initDroppable();\n        },\n\n        // method only applicable\n        initDroppable: function(){\n            // Build our own droppable to avoid useless features\n            var self = this;\n            $.each(self.$el.children(), function(index, element){\n                if (!$(element).hasClass("ui-droppable")){\n                    $(element).droppable({\n                        drop: function(){\n                            var droppable = $(this);\n                            droppable.focus();\n                        },\n                        over: function(event, ui){\n                            var droppable = $(this);\n                            var draggable = ui.draggable;\n                            droppable.append("<img src=\\"" + draggable.attr("src") + "\\" style=\\"max-width:100%;\\">");\n                        },\n                        out: function(event, ui){\n                            var draggable = ui.draggable;\n                            $(this).children("[src=\\"" + draggable.attr("src") + "\\"]").remove();\n                        }\n                    });\n                }\n            });\n        }\n    });\n\n    function MarkdownEditor(element, options){\n        var self = this;\n        self.el = element;\n        self.$el = $(element);\n        self.options = options;\n        self.init();\n        return self;\n    }\n\n    MarkdownEditor.prototype = $.extend({}, Editor.prototype, {\n\n        markdownTools: function(){\n            var self = this;\n            if( !self.$mardownToolHtml ) {\n                self.$mardownToolHtml = $("<div id=\\"markdown_tool_" + self.getId() + "\\" class=\\"" + self.options.container_tool_class + "\\">\\\n                                <button type=\\"button\\" class=\\"" + self.options.btn_tool_class + " markdown-h3\\">H3</button>\\\n                                <button type=\\"button\\" class=\\"" + self.options.btn_tool_class + " markdown-h4\\">H4</button>\\\n                                <button type=\\"button\\" class=\\"" + self.options.btn_tool_class + " markdown-bold\\"><strong>B</strong></button>\\\n                                <button type=\\"button\\" class=\\"" + self.options.btn_tool_class + " markdown-italic\\"><em>I</em></button>\\\n                                <button type=\\"button\\" class=\\"" + self.options.btn_tool_class + " markdown-list-ul\\">List</button>\\\n                                <button type=\\"button\\" class=\\"" + self.options.btn_tool_class + " markdown-link\\">Link</button></div>");\n                self.$mardownToolHtml.on("mousedown", function(event){\n                    event.preventDefault();\n                    var $target = $(event.target);\n                    if ($target.hasClass("markdown-h3")){\n                        self.$textarea.selection("insert", {text: "###", mode: "before"}).selection("insert", {text: "", mode: "after"});\n                    }else if($target.hasClass("markdown-h4")){\n                        self.$textarea.selection("insert", {text: "####", mode: "before"}).selection("insert", {text: "", mode: "after"});\n                    }else if($target.hasClass("markdown-bold")||$target.parent().hasClass("markdown-bold")){\n                        self.$textarea.selection("insert", {text: "**", mode: "before"}).selection("insert", {text: "**", mode: "after"});\n                    }else if($target.hasClass("markdown-list-ul")){\n                        self.$textarea.selection("insert", {text: "* ", mode: "before"}).selection("insert", {text: "", mode: "after"});\n                    }else if($target.hasClass("markdown-link")){\n                        var text = self.$textarea.selection();\n                        if (text.indexOf("http://") >= 0){\n                            self.$textarea.selection("insert", {text: "[" + text + "](", mode: "before"}).selection("insert", {text: ")", mode: "after"});\n                        }else{\n                            self.$textarea.selection("insert", {text: "[http://" + text + "](http://", mode: "before"}).selection("insert", {text: ")", mode: "after"});\n                        }\n                    }else if($target.attr("id") === "italic"){\n                        self.$textarea.selection("insert", {text: "*", mode: "before"}).selection("insert", {text: "*", mode: "after"});\n                    }\n                });\n            }\n            return self.$mardownToolHtml;\n        },\n\n        textArea: function(){\n            var self = this;\n            if( !self.$textarea ) {\n                self.$textarea = $("<textarea placeholder=\\"" + self.options.emptyInputText + "\\" class=\\"djaodjin-editor\\" id=\\"textarea_" + self.getId() + "\\" style=\\"\\"></textarea>");\n            }\n            // adds the handlers back always because `replaceWith` removes them.\n            self.$textarea.on("blur", function(event){\n                event.preventDefault();\n                self.saveEdition();\n            });\n            self.$textarea.droppable({\n                drop: function(event, ui){\n                    var droppable = $(this);\n                    var draggable = ui.draggable;\n                    droppable.focus();\n                    droppable.selection("insert", {\n                        text: "![Alt text](" + draggable.attr("src") + ")",\n                        mode: "before"\n                    });\n                    $(ui.helper).remove();\n                }\n            });\n            return self.$textarea;\n        },\n\n        getElementProperties: function(){\n            var self = this;\n            if (self.$el.prop("tagName") === "DIV"){\n                if (self.$el.children("p").length > 0){\n                    return self.$el.children("p");\n                }else{\n                    return $("p");\n                }\n            }else{\n                return self.$el;\n            }\n        },\n\n        getProperties: function(){\n            var self = this;\n            self.classElement = self.$el.attr("class");\n            var element = self.getElementProperties();\n            self.cssVar = {\n                "font-size": element.css("font-size"),\n                "line-height": element.css("line-height"),\n                "height": parseInt(element.css("height").split("px")) + (parseInt(element.css("line-height").split("px")) - parseInt(element.css("font-size").split("px"))) + "px",\n                "margin-top": element.css("margin-top"),\n                "font-family": element.css("font-family"),\n                "font-weight": element.css("font-weight"),\n                "text-align": element.css("text-align"),\n                "padding-top": -(parseInt(element.css("line-height").split("px")) - parseInt(element.css("font-size").split("px"))) + "px",\n                "color": element.css("color"),\n                "width": element.css("width")\n            };\n        },\n\n        toggleEdition: function(){\n            var self = this;\n            setTimeout(function(){\n                self.getOriginText();\n                self.initEditor();\n            }, self.options.delayMarkdownInit);\n\n        },\n\n        initEditor: function(){\n            var self = this;\n            self.getProperties();\n            $("body").append(self.markdownTools());\n            self.$mardownToolHtml.css({\n                top: (self.$el.offset().top - 45) + "px",\n                left: self.$el.offset().left + "px"\n            });\n            self.$mardownToolHtml.show();\n            self.$el.replaceWith(self.textArea());\n            self.$textarea.css(self.cssVar).val(self.originText).textareaAutoSize().focus();\n        },\n\n        getSavedText: function(){\n            var self = this;\n            return $.trim(self.$textarea.val());\n        },\n\n        formatDisplayedValue: function(){\n            var self = this;\n            var convert = new Markdown.getSanitizingConverter().makeHtml;\n            var newHtml = convert(self.getSavedText()).replace("<img ", "<img style=\\"max-width:100%\\" ");\n            self.$textarea.replaceWith(self.$el.html(newHtml));\n            self.$mardownToolHtml.hide();\n            self.init(); // adds the handlers back to self.$el.\n        },\n\n        getOriginText: function(){\n            var self = this;\n            self.originText = "";\n            if (self.options.baseUrl){\n                $.ajax({\n                    method: "GET",\n                    url: self.elementUrl(),\n                    contentType: "application/json; charset=utf-8",\n                    beforeSend: function(xhr) {\n                        xhr.setRequestHeader("X-CSRFToken", self._getCSRFToken());\n                    },\n                    async: false,\n                    success: function(data){\n                        if (self.$el.attr("data-key")){\n                            self.originText = data[self.$el.attr("data-key")];\n                        }else{\n                            self.originText = data.text;\n                        }\n                    },\n                    error: function(){\n                        self.originText = $.trim(self.$el.text());\n                    }\n                });\n            }\n            return self.originText;\n        }\n\n    });\n\n    function RangeEditor(element, options){\n        var self = this;\n        self.el = element;\n        self.$el = $(element);\n        self.options = options;\n        self.init();\n        return self;\n    }\n\n    RangeEditor.prototype = $.extend({}, Editor.prototype, {\n        valueSelector: function(){\n            var self = this;\n            self.$valueSelector = $("<input class=\\"djaodjin-editor\\" id=\\"value_selector_" + self.getId() + "\\" style=\\"width:auto;\\"/ type=\\"range\\">");\n\n            self.$valueSelector.on("input", function(event){\n                var val = $(this).val();\n                event.stopPropagation();\n                self.options.rangeUpdate(self.$el, val);\n                if (self.$el.data("range-value") !== "undefined"){\n                    self.$el.data("range-value", val);\n                }\n            });\n\n            self.$valueSelector.on("mouseup", function(event){\n                self.$valueSelector.blur();\n            });\n\n            self.$valueSelector.on("blur", function(event){\n                self.saveEdition();\n                self.$valueSelector.remove();\n                self.$valueSelector = null;\n                event.stopPropagation();\n            });\n\n            return self.$valueSelector;\n        },\n\n        getOriginText: function(){\n            var self = this;\n            if (self.$el.data("range-value") !== "undefined"){\n                self.originText = self.$el.data("range-value");\n            }else{\n                self.originText = $.trim(self.$el.text());\n            }\n            return self.originText;\n        },\n\n        getSavedText: function(){\n            var self = this;\n            var newVal = self.$valueSelector.val();\n            var values = self.$el.data("range-values");\n            if (values){\n                if (values[String(newVal)]){\n                    newVal = values[String(newVal)];\n                }\n            }\n            return newVal;\n         },\n\n        toggleEdition: function(){\n            var self = this;\n            if (self.$valueSelector){\n                self.$valueSelector.blur();\n            }else{\n                self.getOriginText();\n                self.$el.append(self.valueSelector());\n                self.$valueSelector.attr("min", self.$el.data("range-min"))\n                    .attr("max", self.$el.data("range-max"))\n                    .attr("step", self.$el.data("range-step"))\n                    .val(self.originText);\n\n                if (self.options.rangePosition === "middle"){\n                    self.$valueSelector.css({top: (self.$el.offset().top + (self.$el.height() / 2)) + "px"});\n                }else if (self.options.rangePosition === "bottom"){\n                    self.$valueSelector.css({top: (self.$el.offset().top + self.$el.height()) + "px"});\n                }else if (self.options.rangePosition === "top"){\n                    self.$valueSelector.css({top: self.$el.offset().top + "px"});\n                }\n                self.$valueSelector.focus();\n            }\n        }\n    });\n\n    $.fn.editor = function(options, custom){\n        var opts = $.extend( {}, $.fn.editor.defaults, options );\n        return this.each(function() {\n            if (!$.data($(this), "editor")) {\n                if ($(this).hasClass("edit-formatted")){\n                    $.data($(this), "editor", new FormattedEditor($(this), opts));\n                }else if ($(this).hasClass("edit-markdown")){\n                    $.data($(this), "editor", new MarkdownEditor($(this), opts));\n                }else if ($(this).hasClass("edit-currency")){\n                    $.data($(this), "editor", new CurrencyEditor($(this), opts));\n                }else if ($(this).hasClass("edit-range")){\n                    $.data($(this), "editor", new RangeEditor($(this), opts));\n                }else{\n                    $.data($(this), "editor", new Editor($(this), opts));\n                }\n            }\n        });\n    };\n\n    $.fn.editor.defaults = {\n        baseUrl: null, // Url to send request to server\n        emptyInputText: "placeholder, type to overwrite...",\n        uniqueIdentifier: "id",\n        onSuccess: function(element, resp){\n            return true;\n        },\n        onError: function(resp){\n            showErrorMessages(resp);\n        },\n        rangeUpdate: function(editable, newVal){\n            editable.text(newVal);\n        },\n        rangePosition: "middle", // position of range input from element "middle", "top" or "bottom"\n        delayMarkdownInit: 0, // Add ability to delay the get request for markdown\n        debug: false,\n        focus: false\n    };\n\n}( jQuery ));\n'},192:function(t,n,e){e(1)(e(193))},193:function(t,n){t.exports='/* jshint multistr: true */\n/* global getMetaCSRFToken Dropzone jQuery :true */\n\n/* relies on:\n    - jquery-ui.js\n    - dropzone.js\n\nMedia request:\n\nGET mediaUrl:\n\n    - request\n\n    - response: 200 OK\n    {\n        ...,\n        "results":[\n            {"location": "/media/item/url1.jpg", "tags" : []},\n            {"location": "/media/item/url2.jpg", "tags" : ["html", "django"]}\n        ],\n        ...\n    }\n\nPOST mediaUrl:\n    - request: {<paramNameUpload>: uploaded_file}\n\n    - response: 201 CREATED\n    {"location":"/media/item/url1.jpg","tags":[]}\n\n\nPUT mediaUrl:\n\n    - request: {items: [{location: "/media/item/url1.jpg"}, {location: "/media/item/url2.jpg"}], tags: ["tag1", "tag2"]}\n\n    - response: 200 OK\n    {\n        ...,\n        "results":[\n            {"location": "/media/item/url1.jpg", "tags" : ["tag1", "tag2"]},\n            {"location": "/media/item/url2.jpg", "tags" : ["tag1", "tag2"]}\n        ],\n        ...\n    }\n\nDELETE mediaUrl?location=/media/item/url1.jpg 200 OK\n    - response: 200 OK\n\nOptions:\n\n    mediaUrl :                          default: null, type: String, url to get, post, put and delete media from backend\n\n    // AWS S3 Direct upload settings\n    S3DirectUploadUrl :                 default: null, type: String, A S3 url\n    mediaPrefix :                       default: null, type: String, S3 folder ex: media/\n    accessKey :                         default: null, type: String, S3 Temporary credentials\n    securityToken :                     default: null, type: String, S3 Temporary credentials\n    policy :                            default: null, type: String, S3 Temporary credentials\n    signature :                         default: null, type: String, S3 Temporary credentials\n    amzCredential :                     default: null, type: String, S3 Temporary credentials\n    amzDate :                           default: null, type: String, S3 Temporary credentials\n\n    // Custom gallery callback and templates\n    paramNameUpload :                   default: "file", type: String, Custom param name for uploaded file\n    maxFilesizeUpload :                 default: 256, type: Integer\n    acceptedImages :                    default: [".jpg", ".png", ".gif"], type: Array\n    acceptedVideos :                    default: [".mp4"], type: Array\n    buttonClass :                       type: String\n    selectedMediaClass :                type: String, class when a media item is selected\n    startLoad :                         type: Boolean, if true load image on document ready\n    itemUploadProgress :                type:function, params:progress, return the progress on upload\n    galleryMessage :                    type:function, params:message, notification of the gallery\n\n    // Custom droppable media item and callback\n    mediaPlaceholder :                  type:string, seclector to init droppable placeholder\n    saveDroppedMediaUrl :               type:string, Url to send request when media is dropped in placeholder\n    droppedMediaCallback :              type:function, params:response, Callback on succeeded dropped media item\n\n*/\n\n(function ($) {\n    "use strict";\n\n    function Djgallery(el, options){\n        this.element = $(el);\n        this.options = options;\n        this.init();\n    }\n\n    Djgallery.prototype = {\n        init: function(){\n            var self = this;\n            self.originalTags = [];\n            self.currentInfo = "";\n            self.selectedMedia = null;\n            self.initGallery();\n            self.initDocument();\n            self.initMediaInfo();\n            if (self.options.startLoad){\n                self.loadImage();\n            }\n            $(document).on("click", "[data-dj-gallery-media-url]" , function(){\n                this.select();\n            });\n        },\n\n        initGallery: function(){\n            var self = this;\n            if ($(".dj-gallery").length === 0){\n                $("body").append(self.options.galleryTemplate);\n            }\n        },\n\n        initDocument: function(){\n            var self = this;\n            self.element.on("click", ".dj-gallery-delete-item",\n                function(event) { self.deleteMedia(event); });\n            self.element.on("click", ".dj-gallery-preview-item",\n                function(event) { self.previewMedia(event); });\n            self.element.on("keyup", ".dj-gallery-filter",\n                function(event) { self.loadImage(); });\n            self.element.on("click", ".dj-gallery-tag-item",\n                function(event) { self.tagMedia(); });\n            self.element.on("click", ".dj-gallery-item-container",\n                function(event) { self.selectMedia($(this)); });\n            self.element.on("djgallery.loadresources",\n                function(event) { self.loadImage(); });\n            $(".dj-gallery-load").on("click",\n                function(event) { self.loadImage(); });\n\n            $("body").on("click", ".closeModal", function(event){\n                event.preventDefault();\n                $("#openModal").remove();\n            });\n\n            $(self.options.mediaPlaceholder).droppable({\n                drop: function( event, ui ) {\n                    var droppable = $(this);\n                    var location = self._mediaLocation(\n                        ui.draggable.attr("src"));\n                    var source = location.toLowerCase();\n                    if (droppable.prop("tagName") === "IMG"){\n                        if (self.options.acceptedImages.some(function(v) {\n                            return source.indexOf(v) >= 0; })) {\n                            droppable.attr("src", location);\n                            $(ui.helper).remove();\n                            self.saveDroppedMedia(droppable);\n                        } else {\n                            self.options.galleryMessage(\n                                self.options.placeholderAcceptsErrorMessage(\n                                    self.options.acceptedImages.join(", ")),\n                                \'error\');\n                        }\n                    }else if (droppable.prop("tagName") === "VIDEO"){\n                        if (self.options.acceptedVideos.some(function(v) {\n                            return source.indexOf(v) >= 0; })){\n                            droppable.attr("src", location);\n                            $(ui.helper).remove();\n                            self.saveDroppedMedia(droppable);\n                        } else {\n                            self.options.galleryMessage(\n                                self.options.placeholderAcceptsErrorMessage(\n                                    self.options.acceptedVideos.join(", ")),\n                                \'error\');\n                        }\n                    }\n                }\n            });\n        },\n\n        _mediaLocation: function(url) {\n            var parser = document.createElement(\'a\');\n            parser.href = url;\n            var result = parser.pathname;\n            if( parser.host != location.hostname ) {\n                result = parser.host + result;\n                if( parser.protocol ) {\n                    result = parser.protocol + "//" + result;\n                }\n            }\n            return result;\n        },\n\n        initMediaInfo: function(){\n            var self = this;\n            $(".dj-gallery-info-item>.dj-gallery-info-item-selected").hide();\n            $(".dj-gallery-info-item>.dj-gallery-info-item-empty").show();\n        },\n\n        initDropzone: function(){\n            var self = this;\n            var uploadUrl = self.options.mediaUrl;\n            if( self.options.S3DirectUploadUrl &&\n                self.options.S3DirectUploadUrl.indexOf("/api/auth/") >= 0 ) {\n                uploadUrl = self.options.S3DirectUploadUrl;\n                if( uploadUrl.indexOf("?public=1") >= 0 ) {\n                    self.options.acl = "public-read";\n                }\n            }\n\n            self.element.djupload({\n                uploadUrl: uploadUrl,\n                uploadZone: "body",\n                uploadClickableZone: self.options.clickableArea,\n                uploadParamName: "file",\n\n                // S3 direct upload\n                accessKey: self.options.accessKey,\n                mediaPrefix: self.options.mediaPrefix,\n                securityToken: self.options.securityToken,\n                acl: self.options.acl,\n                policy: self.options.policy,\n                signature: self.options.signature,\n                amzCredential: self.options.amzCredential,\n                amzDate: self.options.amzDate,\n\n                // callback\n                uploadSuccess: function(file, response){\n                    var status = file.xhr.status;\n                    $(".dz-preview").remove();\n                    var lastIndex = $(".dj-gallery-items").children().last().children().attr("id");\n                    if (lastIndex){\n                        lastIndex = parseInt(lastIndex.split("image_")[1]) + 1;\n                    }else{\n                        lastIndex = 0;\n                    }\n                    var filename = file.name;\n                    var location = response.location;\n                    if( [201, 204].indexOf(status) >= 0 ){\n                        self.addMediaItem(response, lastIndex, false);\n                        self.options.galleryMessage(\n                            self.options.uploadSuccessMessage(\n                                filename, location));\n                    } else if( status === 200 ) {\n                        self.options.galleryMessage(\n                            self.options.uploadPreviousSuccessMessage(\n                                filename, location));\n                    }\n                },\n                uploadError: function(file, resp){\n                    var message = resp;\n                    if( typeof resp.detail !== "undefined" ) {\n                        message = resp.detail;\n                    }\n                    self.options.galleryMessage(message, "error");\n                },\n                uploadProgress: function(file, progress){\n                    self.options.itemUploadProgress(progress);\n                }\n            });\n        },\n\n        _loadMedias: function() {\n            var self = this;\n            var $element = $(self.element);\n            var mediaFilterUrl = self.options.mediaUrl;\n            var $filter = $element.find(".dj-gallery-filter");\n            if( $filter.val() !== "") {\n                mediaFilterUrl = self.options.mediaUrl + "?q=" + $filter.val();\n            }\n            $.ajax({\n                method: "GET",\n                url: mediaFilterUrl,\n                datatype: "json",\n                contentType: "application/json; charset=utf-8",\n                success: function(data){\n                    $(".dj-gallery-items").empty();\n                    $.each(data.results, function(index, file){\n                        self.addMediaItem(file, index, true);\n                    });\n                },\n                error: function(resp) {\n                    self.options.galleryMessage(resp, \'error\');\n                }\n            });\n        },\n\n        loadImage: function(){\n            var self = this;\n            self.initDropzone();\n            self._loadMedias();\n        },\n\n        addMediaItem: function(file, index, init){\n            var self = this;\n            var mediaItem = null;\n            var tags = file.tags;\n            if (typeof tags === "undefined"){\n                tags = "";\n            }\n            var ext = null;\n            var parser = document.createElement(\'a\');\n            parser.href = file.location;\n            var filename = parser.pathname.toLowerCase();\n            var extIdx = filename.lastIndexOf(\'.\');\n            if( extIdx > 0 ) {\n                ext = filename.substr(extIdx);\n            }\n            var location = file.location;\n            if( self.options.acl === "public-read" ) {\n                location = self._mediaLocation(location);\n            }\n            if (self.options.acceptedVideos.some(function(v) { return ext.toLowerCase().indexOf(v) >= 0; })){\n                mediaItem = "<video id=\\"image_" + index + "\\" class=\\"image dj-gallery-item image_media img-thumbnail\\" src=\\"" + location + "\\" tags=\\"" + tags + "\\"></video>";\n            } else if (self.options.acceptedImages.some(function(v) { return ext.toLowerCase().indexOf(v) >= 0; })){\n                mediaItem = "<img id=\\"image_" + index + "\\" class=\\"image dj-gallery-item image_media img-thumbnail\\" src=\\"" + location + "\\" tags=\\"" + tags + "\\">";\n            } else {\n                mediaItem = "<img id=\\"image_" + index + "\\" class=\\"image dj-gallery-item image_media img-thumbnail\\" src=\\"/static/img/generic-document.png\\" data-location=\\"" + location + "\\" tags=\\"" + tags + "\\">";\n            }\n            if( mediaItem ) {\n                var $mediaItem = $("<div class=\\"dj-gallery-item-container "\n                      + self.options.mediaClass + " \\">"\n                      + mediaItem\n                      + "</div>");\n                $(".dj-gallery-items").prepend($mediaItem);\n                $("#image_" + index).draggable({\n                    helper: "clone",\n                    revert: true,\n                    appendTo: "body",\n                    zIndex: 1000000,\n                    start: function(event, ui) {\n                        ui.helper.css({\n                            width: 65\n                        });\n                    }\n                });\n                if( !init ) {\n                    self.selectMedia($mediaItem);\n                }\n            }\n        },\n\n        selectMedia: function(item) {\n            var self = this;\n            var $elem = self.element;\n            // Removes highlights for previously selected media\n            $elem.find(".dj-gallery-item-container").not(item).removeClass(\n                self.options.selectedMediaClass);\n\n            self.selectedMedia = item.children(".dj-gallery-item");\n            var refElem = item.find("[tags]");\n            if( refElem.length > 0 ) {\n                self.orginalTags = refElem.attr("tags").split(",");\n            } else {\n                self.orginalTags = "";\n            }\n            item.addClass(self.options.selectedMediaClass);\n\n            // populates contextual menu\n            var location = null;\n            refElem = item.find("[data-location]");\n            if( refElem.length > 0 ) {\n                location = self._mediaLocation(refElem.data("location"));\n            } else {\n                refElem = item.find("[src]");\n                location = self._mediaLocation(refElem.attr("src"));\n            }\n            var icon = item.find("[src]").attr("src");\n\n            $elem.find("[data-dj-gallery-media-src]").attr("src", icon);\n            $elem.find("[data-dj-gallery-media-location]").attr(\n                "location", location);\n            $elem.find("[data-dj-gallery-media-url]").val(location);\n            $elem.find("[data-dj-gallery-media-tag]").val(item.attr("tags"));\n\n            $(".dj-gallery-info-item>.dj-gallery-info-item-selected").show();\n            $(".dj-gallery-info-item>.dj-gallery-info-item-empty").hide();\n        },\n\n        deleteMedia: function(event){\n            var self = this;\n            event.preventDefault();\n            var location = self._mediaLocation(self.selectedMedia.attr("src"));\n            $.ajax({\n                method: "DELETE",\n                url: self.options.mediaUrl + "?location=" + location,\n                datatype: "json",\n                contentType: "application/json; charset=utf-8",\n                beforeSend: function(xhr, settings) {\n                    xhr.setRequestHeader("X-CSRFToken", getMetaCSRFToken());\n                },\n                success: function(resp){\n                    $("[src=\\"" + self.selectedMedia.attr("src") + "\\"]").parent(".dj-gallery-item-container").remove();\n                    self.initMediaInfo();\n                    self.options.galleryMessage(resp.detail);\n                },\n                error: function(resp) {\n                    self.options.galleryMessage(resp, \'error\');\n                }\n            });\n        },\n\n        tagMedia: function(){\n            var self = this;\n            var tags = $(".dj-gallery-tag-input").val().split(",");\n            for( var idx = 0; idx < tags.length; ++idx ) {\n                tags[idx] = $.trim(tags[idx]);\n            }\n            if (tags !== self.originalTags){\n                $.ajax({\n                    type: "PUT",\n                    url: self.options.mediaUrl,\n                    data: JSON.stringify({\n                        "items": [{\n                            "location": self._mediaLocation(\n                                self.selectedMedia.attr("src"))\n                        }],\n                        "tags": tags}),\n                    datatype: "json",\n                    contentType: "application/json; charset=utf-8",\n                    beforeSend: function(xhr, settings) {\n                        xhr.setRequestHeader("X-CSRFToken", getMetaCSRFToken());\n                    },\n                    success: function(resp){\n                        $.each(resp.results, function(index, element) {\n                            $("[src=\\"" + element.location + "\\"]").attr(\n                                "tags", element.tags);\n                        });\n                        self.options.galleryMessage(resp.detail);\n                    },\n                    error: function(resp) {\n                        self.options.galleryMessage(resp, \'error\');\n                    }\n                });\n            }\n        },\n\n        elementUrl: function(idElement) {\n            var self = this;\n            var path = idElement;\n            // We make sure that if either `baseUrl` or `path` ends with,\n            // respectively starts with, a \'/\' or not, concatenation will\n            // not result in a \'//\'.\n            if( path.indexOf(\'/\') != 0 ) path = \'/\' + path\n            return self.options.saveDroppedMediaUrl.replace(/\\/+$/, "") + path;\n        },\n\n        previewMedia: function(event){\n            var self = this;\n            event.preventDefault();\n            var src = self.selectedMedia.attr("src");\n            var type = "image";\n            if (self.options.acceptedVideos.some(function(v) { return src.toLowerCase().indexOf(v) >= 0; })){\n                type = "video";\n            }\n            self.options.previewMediaItem(self.selectedMedia.attr("src"), type);\n        },\n\n        saveDroppedMedia: function(element){\n            var self = this;\n            var idElement = element.attr("id");\n            var data = {slug: idElement, text: element.attr("src")};\n            if( self.options.hints ) {\n                data[\'hints\'] = self.options.hints;\n            }\n            $.ajax({\n                method: "PUT",\n                async: false,\n                url: self.elementUrl(idElement),\n                data: JSON.stringify(data),\n                datatype: "json",\n                contentType: "application/json; charset=utf-8",\n                beforeSend: function(xhr, settings) {\n                    xhr.setRequestHeader("X-CSRFToken", getMetaCSRFToken());\n                },\n                success: function(response){\n                    self.options.droppedMediaCallback(response);\n                }\n            });\n        }\n    };\n\n    $.fn.djgallery = function(options) {\n        var opts = $.extend( {}, $.fn.djgallery.defaults, options );\n        return new Djgallery($(this), opts);\n    };\n\n    $.fn.djgallery.defaults = {\n\n        // Djaodjin gallery required options\n        mediaUrl: null, // Url to get list of media and upload, update and delete a media item\n\n        // Customize djaodjin gallery.\n        buttonClass: "",\n        galleryTemplate: "<div class=\\"dj-gallery\\"><div class=\\"sidebar-gallery\\"><h1>Media</h1><input placeholder=\\"Search...\\" class=\\"dj-gallery-filter\\" type=\\"text\\"><div class=\\"dj-gallery-items\\"></div><div class=\\"dj-gallery-info-item\\"><div class=\\"dj-gallery-info-item-empty\\">Click on an item to view more options</div><div class=\\"dj-gallery-info-item-selected\\" style=\\"display: none;\\"><textarea rows=\\"4\\" style=\\"width:100%;\\" readonly data-dj-gallery-media-url></textarea><button data-dj-gallery-media-location class=\\"dj-gallery-delete-item\\">Delete</button><button data-dj-gallery-media-location class=\\"dj-gallery-preview-item\\">Preview</button><br /><input data-dj-gallery-media-tag class=\\"dj-gallery-tag-input\\" type=\\"text\\" placeholder=\\"Please enter tag.\\"><button class=\\"dj-gallery-tag-item\\">Update tags</button></div></div></div></div>",\n        mediaClass: "",\n        selectedMediaClass: "dj-gallery-active-item",\n        startLoad: false,\n        itemUploadProgress: function(progress){ return true; },\n        galleryMessage: function(message, type){ return true; },\n        previewMediaItem: function(src){ return true; },\n        acceptedImages: [".jpg", ".png", ".gif"],\n        acceptedVideos: [".mp4"],\n        maxFilesizeUpload: 256,\n        paramNameUpload: "file",\n        clickableArea: false,\n\n        // S3 direct upload\n        S3DirectUploadUrl: null,\n        accessKey: null,\n        mediaPrefix: "",\n        securityToken: null,\n        acl: "private",\n        policy: "",\n        signature: null,\n        amzCredential: null,\n        amzDate: null,\n\n\n        // Custom droppable media item and callback\n        mediaPlaceholder: ".droppable-image",\n        saveDroppedMediaUrl: null,\n        hints: null,\n        droppedMediaCallback: function(reponse) { return true; },\n\n        // messages\n        uploadSuccessMessage: function(filename, location) {\n            return \'"\' + filename + \'" uploaded sucessfully to "\' + location + \'"\';\n        },\n        uploadPreviousSuccessMessage: function(filename, location) {\n            return \'"\' + filename + \'" has previously been uploaded to "\' + location + \'"\';\n        },\n        placeholderAcceptsErrorMessage: function(filetypes) {\n            return \'This placeholder accepts only: \' + filetypes + \' files.\';\n        }\n    };\n\n\n    /** Sliding panel\n\n        HTML requirements:\n\n        <button data-target="#_panel_" data-default-width="300"></button>\n        <div id="#_panel_"></div>\n     */\n    function PanelButton(el, options){\n        this.element = $(el);\n        this.options = options;\n        this.defaultWidth = 300;\n        this.init();\n    }\n\n    PanelButton.prototype = {\n        init: function () {\n            var self = this;\n            var target = $(self.element.attr("data-target"));\n            if( typeof self.options.defaultWidth !== "undefined" ) {\n                self.defaultWidth = self.options.defaultWidth;\n            } else {\n                var defaultWidth = self.element.attr("data-default-width");\n                if( defaultWidth ) {\n                    self.defaultWidth = parseInt(defaultWidth);\n                }\n            }\n\n            target.find(".close").click(function() {\n                if( target.is(":visible")) {\n                    target.hide();\n                    self.element.show();\n                }\n            });\n\n            self.element.click(function(event) {\n                event.preventDefault();\n                self.element.blur();\n                if( self.element.hasClass("dragged") ){\n                    self.element.removeClass("dragged");\n                    return false;\n                }\n                if( target.hasClass("visible-gallery") ) {\n                    target.css({right: -self.defaultWidth, width: self.defaultWidth}).removeClass("visible-gallery");\n                    self.element.removeAttr("style").css({right: 0}).draggable("destroy");\n                } else {\n                    target.css({right: 0, width: self.defaultWidth}).addClass("visible-gallery");\n                    self.element.css("right", self.defaultWidth);\n                    self.element.draggable({\n                        axis: "x",\n                        cursor: "move",\n                        containment: "window",\n                        start: function(event, ui) {\n                            self.element.addClass("dragged");\n                        },\n                        drag: function(event, ui) {\n                            var viewWidth = $(window).width();\n                            if (viewWidth - ui.position.left - $(ui.helper).outerWidth() >= self.defaultWidth){\n                                target.css("right", "0px").css("width", viewWidth - ui.position.left - $(ui.helper).outerWidth());\n                            } else {\n                                self.element.css("left", viewWidth - self.defaultWidth - $(ui.helper).outerWidth());\n                                return false;\n                            }\n                        },\n                        stop: function(event, ui) {\n                            var viewWidth = $(window).width();\n                            if (viewWidth - ui.position.left - $(ui.helper).outerWidth() >= self.defaultWidth){\n                                target.css("right", "0px").css("width", viewWidth - ui.position.left - $(ui.helper).outerWidth());\n                            } else {\n                                target.css("right", "0px").css("width", self.defaultWidth);\n                            }\n                            setTimeout( function(){\n                                if( self.element.hasClass("dragged")){\n                                    self.element.removeClass("dragged");\n                                }\n                            }, self.defaultWidth);\n                        }\n                    });\n                    target.trigger("djgallery.loadresources");\n                    target.find(".content").trigger("pages.loadresources");\n                }\n            });\n        }\n    };\n\n    $.fn.panelButton = function(options) {\n        var opts = $.extend( {}, $.fn.panelButton.defaults, options );\n        return this.each(function() {\n            if (!$.data(this, "panelButton")) {\n                $.data(this, "panelButton", new PanelButton(this, opts));\n            }\n        });\n    };\n\n    $.fn.panelButton.defaults = {\n//        defaultWidth: 300\n    };\n\n})(jQuery);\n'},194:function(t,n,e){e(1)(e(195))},195:function(t,n){t.exports='/* Copyright (c) 2019, Djaodjin Inc.\n   see LICENSE\n*/\n\n/* global jQuery window confirm Plan showErrorMessages:true */\n\n(function ($){\n    "use strict";\n\n    function EditPlan(el, options){\n        var self = this;\n        self.element = $(el);\n        self.options = options;\n        self.init();\n        return self;\n    }\n\n    EditPlan.prototype = {\n        init: function(){\n            var self = this;\n            var editionTool = "<button class=\\"edit-plan close\\" style=\\"position:absolute;top:30px; left:20px;\\"><i class=\\"fa fa-pencil icon_edition\\"></i></button><button class=\\"text-danger trash-plan close\\" style=\\"position:absolute;top:30px; right:20px;\\"><i class=\\"fa fa-trash-o icon_edition\\"></i></button>";\n\n            this.element.append(editionTool);\n            this.element.on("click", ".trash-plan", function(event){\n                self.deletePlan(event);\n            });\n            this.element.on("click", ".edit-plan", function(event){\n                self.editPlanElement(event);\n            });\n            this.element.on("click", self.documentClick);\n        },\n\n        _getCSRFToken: function() {\n            var self = this;\n            var crsfNode = self.element.find("[name=\'csrfmiddlewaretoken\']");\n            if( crsfNode.length > 0 ) {\n                return crsfNode.val();\n            }\n            return getMetaCSRFToken();\n        },\n\n        deletePlan: function(event){\n            var self = this;\n            event.preventDefault();\n            // XXX following is matching statement in djaodjin-saas.js\n            // We do this here because the slug might have been updated.\n            self.id = self.element.attr("data-plan");\n            $.ajax({ type: "DELETE",\n                 url: self.options.baseUrl + "/" + self.id + "/",\n                 beforeSend: function(xhr) {\n                     xhr.setRequestHeader("X-CSRFToken", self._getCSRFToken());\n                 },\n                 async: false,\n                 success: function(data) {\n                     // XXX We cannot just do a `self.element.remove();`\n                     // otherwise the layout is incorrect.\n                     location.reload(true);\n                 },\n                 error: function(resp) {\n                     showErrorMessages(resp);\n                 }\n            });\n        },\n\n        editPlanElement: function(event){\n            var self = this;\n            event.preventDefault();\n            // XXX following is matching statement in djaodjin-saas.js\n            // We do this here because the slug might have been updated.\n            self.id = self.element.attr("data-plan");\n            window.location = self.options.baseEditPlanUrl + self.id + "/";\n        }\n\n    };\n\n    $.fn.editPlan = function(options) {\n        var opts = $.extend( {}, $.fn.editPlan.defaults, options );\n        return this.each(function() {\n            var editplan = new EditPlan($(this), opts);\n        });\n    };\n\n    $.fn.editPlan.defaults = {\n        baseUrl: null,\n        baseEditPlanUrl: null\n    };\n})(jQuery);\n'},196:function(t,n,e){e(1)(e(197))},197:function(t,n){t.exports='/* Copyright (c) 2018, Djaodjin Inc.\n   see LICENSE\n*/\n\n/* jshint multistr: true */\n\nvar snaplinesAPI = {\n    /* XXX merely loading this file will register event handler on the whole\n       document instead of being explicitedy done in a local document.ready\n       handler. */\n    urls: {\n            "api_editable_update": "/api/editables",\n            "api_wizard_next": "",\n            "saas_api_plan": "/api/plans"\n        },\n\n    init: function(organization, urls) {\n        this.urls = {\n            "api_editable_update": "/api/" + organization + "/editables",\n            "api_wizard_next": "",\n            "saas_api_plan": "/" + organization + "/api/plans"\n        };\n        jQuery.extend(this.urls, urls);\n        initWizard(this.urls.api_wizard_next);\n    }\n};\n\n\n/** Add a button to move to the next step of a Wizard.\n */\nfunction initWizard(nextUrl) {\n    "use strict";\n    if( nextUrl ) {\n        var arrowNextStep = "<div class=\\"wizard-menu next-wizard\\" data-intro=\\"Follow the wizard\\" data-position=\\"left\\"><a href=\\"" + nextUrl + "\\"><i class=\\"fa fa-angle-double-right\\"></i></a></div>";\n        $("body").append(arrowNextStep);\n    }\n}\n'},5:function(t,n,e){e(1)(e(6))},6:function(t,n){t.exports="/** Functions used for display of localized dates and numbers.\n */\n\nfunction humanizeDate(at_time) {\n    return moment(at_time).format(DATE_FORMAT);\n}\n\n\nfunction humanizeNumber(cell, unit, scale) {\n    scale = scale || 1;\n    var value = cell * scale;\n\n    if( typeof Intl !== 'undefined' &&\n        typeof Intl.NumberFormat !== 'undefined') {\n        var locale = 'en-US';\n        if( navigator.languages && navigator.languages.length > 0 ) {\n            locale = navigator.languages[0];\n        } else if( navigator.language ) {\n            locale = navigator.language;\n        } else if( navigator.browserLanguage ) {\n            locale = navigator.browserLanguage;\n        }\n        if( unit ) {\n            return (new Intl.NumberFormat(locale, {\n                style: 'currency', currency: unit})).format(value);\n        }\n        return (new Intl.NumberFormat(locale)).format(value);\n    }\n\n    // `Intl` is not present. Let's do what we can.\n    var precision = 0;\n    var thousandsSeparator = ',';\n    var decimalSeparator = '.';\n    var symbol = '';\n    var symbolOnLeft = true;\n\n    if( unit ) {\n        // We have a currency unit\n        if( unit === \"usd\" || unit === \"cad\" ) {\n            symbol = \"$\";\n        } else if( unit === \"eur\" ) {\n            symbol = \"\\u20ac\";\n        }\n        precision = 2;\n    }\n\n    var stringified = Math.abs(value).toFixed(precision);\n    var decimalPart = precision ? stringified.slice(-1 - precision) : '';\n    var integralPart = precision ? stringified.slice(0, -1 - precision)\n        : stringified;\n\n    var rem = integralPart.length % 3;\n    var head = rem > 0 ? (integralPart.slice(0, rem) + (\n        integralPart.length > 3 ? thousandsSeparator : ''))\n        : '';\n    var sign = value < 0 ? '-' : '';\n    var valueFormatted = sign + head + integralPart.slice(rem).replace(\n        /(\\d{3})(?=\\d)/g, '$1' + thousandsSeparator) + decimalPart;\n\n    return symbolOnLeft ?\n        symbol + valueFormatted : valueFormatted + symbol;\n};\n\n\nfunction humanizeTimeDelta(at_time, ends_at) {\n    var self = this;\n    var cutOff = ends_at ? moment(ends_at, DATE_FORMAT) : moment();\n    var dateTime = moment(at_time);\n    if( dateTime <= cutOff ) {\n        var timeAgoTemplate = (self.$labels && self.$labels.timeAgoTemplate) ?\n            self.$labels.timeAgoTemplate : \"%(timedelta)s ago\";\n        return timeAgoTemplate.replace(\"%(timedelta)s\",\n            moment.duration(cutOff.diff(dateTime)).humanize());\n    }\n    var timeLeftTemplate = (self.$labels && self.$labels.timeLeftTemplate) ?\n        self.$labels.timeLeftTemplate : \"%(timedelta)s ago\";\n    return timeLeftTemplate.replace(\"%(timedelta)s\",\n        moment.duration(dateTime.diff(cutOff)).humanize());\n};\n"},8:function(t,n,e){e(1)(e(9))},9:function(t,n){t.exports='/*! jQuery UI - v1.11.4 - 2015-03-11\n* http://jqueryui.com\n* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js\n* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */\n\n(function( factory ) {\n\tif ( typeof define === "function" && define.amd ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([ "jquery" ], factory );\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}(function( $ ) {\n/*!\n * jQuery UI Core 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n\n\n// $.ui might exist from components with no dependencies, e.g., $.ui.position\n$.ui = $.ui || {};\n\n$.extend( $.ui, {\n\tversion: "1.11.4",\n\n\tkeyCode: {\n\t\tBACKSPACE: 8,\n\t\tCOMMA: 188,\n\t\tDELETE: 46,\n\t\tDOWN: 40,\n\t\tEND: 35,\n\t\tENTER: 13,\n\t\tESCAPE: 27,\n\t\tHOME: 36,\n\t\tLEFT: 37,\n\t\tPAGE_DOWN: 34,\n\t\tPAGE_UP: 33,\n\t\tPERIOD: 190,\n\t\tRIGHT: 39,\n\t\tSPACE: 32,\n\t\tTAB: 9,\n\t\tUP: 38\n\t}\n});\n\n// plugins\n$.fn.extend({\n\tscrollParent: function( includeHidden ) {\n\t\tvar position = this.css( "position" ),\n\t\t\texcludeStaticParent = position === "absolute",\n\t\t\toverflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,\n\t\t\tscrollParent = this.parents().filter( function() {\n\t\t\t\tvar parent = $( this );\n\t\t\t\tif ( excludeStaticParent && parent.css( "position" ) === "static" ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );\n\t\t\t}).eq( 0 );\n\n\t\treturn position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;\n\t},\n\n\tuniqueId: (function() {\n\t\tvar uuid = 0;\n\n\t\treturn function() {\n\t\t\treturn this.each(function() {\n\t\t\t\tif ( !this.id ) {\n\t\t\t\t\tthis.id = "ui-id-" + ( ++uuid );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t})(),\n\n\tremoveUniqueId: function() {\n\t\treturn this.each(function() {\n\t\t\tif ( /^ui-id-\\d+$/.test( this.id ) ) {\n\t\t\t\t$( this ).removeAttr( "id" );\n\t\t\t}\n\t\t});\n\t}\n});\n\n// selectors\nfunction focusable( element, isTabIndexNotNaN ) {\n\tvar map, mapName, img,\n\t\tnodeName = element.nodeName.toLowerCase();\n\tif ( "area" === nodeName ) {\n\t\tmap = element.parentNode;\n\t\tmapName = map.name;\n\t\tif ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {\n\t\t\treturn false;\n\t\t}\n\t\timg = $( "img[usemap=\'#" + mapName + "\']" )[ 0 ];\n\t\treturn !!img && visible( img );\n\t}\n\treturn ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?\n\t\t!element.disabled :\n\t\t"a" === nodeName ?\n\t\t\telement.href || isTabIndexNotNaN :\n\t\t\tisTabIndexNotNaN) &&\n\t\t// the element and all of its ancestors must be visible\n\t\tvisible( element );\n}\n\nfunction visible( element ) {\n\treturn $.expr.filters.visible( element ) &&\n\t\t!$( element ).parents().addBack().filter(function() {\n\t\t\treturn $.css( this, "visibility" ) === "hidden";\n\t\t}).length;\n}\n\n$.extend( $.expr[ ":" ], {\n\tdata: $.expr.createPseudo ?\n\t\t$.expr.createPseudo(function( dataName ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn !!$.data( elem, dataName );\n\t\t\t};\n\t\t}) :\n\t\t// support: jQuery <1.8\n\t\tfunction( elem, i, match ) {\n\t\t\treturn !!$.data( elem, match[ 3 ] );\n\t\t},\n\n\tfocusable: function( element ) {\n\t\treturn focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );\n\t},\n\n\ttabbable: function( element ) {\n\t\tvar tabIndex = $.attr( element, "tabindex" ),\n\t\t\tisTabIndexNaN = isNaN( tabIndex );\n\t\treturn ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n\t}\n});\n\n// support: jQuery <1.8\nif ( !$( "<a>" ).outerWidth( 1 ).jquery ) {\n\t$.each( [ "Width", "Height" ], function( i, name ) {\n\t\tvar side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],\n\t\t\ttype = name.toLowerCase(),\n\t\t\torig = {\n\t\t\t\tinnerWidth: $.fn.innerWidth,\n\t\t\t\tinnerHeight: $.fn.innerHeight,\n\t\t\t\touterWidth: $.fn.outerWidth,\n\t\t\t\touterHeight: $.fn.outerHeight\n\t\t\t};\n\n\t\tfunction reduce( elem, size, border, margin ) {\n\t\t\t$.each( side, function() {\n\t\t\t\tsize -= parseFloat( $.css( elem, "padding" + this ) ) || 0;\n\t\t\t\tif ( border ) {\n\t\t\t\t\tsize -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;\n\t\t\t\t}\n\t\t\t\tif ( margin ) {\n\t\t\t\t\tsize -= parseFloat( $.css( elem, "margin" + this ) ) || 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn size;\n\t\t}\n\n\t\t$.fn[ "inner" + name ] = function( size ) {\n\t\t\tif ( size === undefined ) {\n\t\t\t\treturn orig[ "inner" + name ].call( this );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\t$( this ).css( type, reduce( this, size ) + "px" );\n\t\t\t});\n\t\t};\n\n\t\t$.fn[ "outer" + name] = function( size, margin ) {\n\t\t\tif ( typeof size !== "number" ) {\n\t\t\t\treturn orig[ "outer" + name ].call( this, size );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\t$( this).css( type, reduce( this, size, true, margin ) + "px" );\n\t\t\t});\n\t\t};\n\t});\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n\t$.fn.addBack = function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t};\n}\n\n// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\nif ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {\n\t$.fn.removeData = (function( removeData ) {\n\t\treturn function( key ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn removeData.call( this, $.camelCase( key ) );\n\t\t\t} else {\n\t\t\t\treturn removeData.call( this );\n\t\t\t}\n\t\t};\n\t})( $.fn.removeData );\n}\n\n// deprecated\n$.ui.ie = !!/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() );\n\n$.fn.extend({\n\tfocus: (function( orig ) {\n\t\treturn function( delay, fn ) {\n\t\t\treturn typeof delay === "number" ?\n\t\t\t\tthis.each(function() {\n\t\t\t\t\tvar elem = this;\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t$( elem ).focus();\n\t\t\t\t\t\tif ( fn ) {\n\t\t\t\t\t\t\tfn.call( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay );\n\t\t\t\t}) :\n\t\t\t\torig.apply( this, arguments );\n\t\t};\n\t})( $.fn.focus ),\n\n\tdisableSelection: (function() {\n\t\tvar eventType = "onselectstart" in document.createElement( "div" ) ?\n\t\t\t"selectstart" :\n\t\t\t"mousedown";\n\n\t\treturn function() {\n\t\t\treturn this.bind( eventType + ".ui-disableSelection", function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\t\t};\n\t})(),\n\n\tenableSelection: function() {\n\t\treturn this.unbind( ".ui-disableSelection" );\n\t},\n\n\tzIndex: function( zIndex ) {\n\t\tif ( zIndex !== undefined ) {\n\t\t\treturn this.css( "zIndex", zIndex );\n\t\t}\n\n\t\tif ( this.length ) {\n\t\t\tvar elem = $( this[ 0 ] ), position, value;\n\t\t\twhile ( elem.length && elem[ 0 ] !== document ) {\n\t\t\t\t// Ignore z-index if position is set to a value where z-index is ignored by the browser\n\t\t\t\t// This makes behavior of this function consistent across browsers\n\t\t\t\t// WebKit always returns auto if the element is positioned\n\t\t\t\tposition = elem.css( "position" );\n\t\t\t\tif ( position === "absolute" || position === "relative" || position === "fixed" ) {\n\t\t\t\t\t// IE returns 0 when zIndex is not specified\n\t\t\t\t\t// other browsers return a string\n\t\t\t\t\t// we ignore the case of nested elements with an explicit value of 0\n\t\t\t\t\t// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>\n\t\t\t\t\tvalue = parseInt( elem.css( "zIndex" ), 10 );\n\t\t\t\t\tif ( !isNaN( value ) && value !== 0 ) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telem = elem.parent();\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n});\n\n// $.ui.plugin is deprecated. Use $.widget() extensions instead.\n$.ui.plugin = {\n\tadd: function( module, option, set ) {\n\t\tvar i,\n\t\t\tproto = $.ui[ module ].prototype;\n\t\tfor ( i in set ) {\n\t\t\tproto.plugins[ i ] = proto.plugins[ i ] || [];\n\t\t\tproto.plugins[ i ].push( [ option, set[ i ] ] );\n\t\t}\n\t},\n\tcall: function( instance, name, args, allowDisconnected ) {\n\t\tvar i,\n\t\t\tset = instance.plugins[ name ];\n\n\t\tif ( !set ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( i = 0; i < set.length; i++ ) {\n\t\t\tif ( instance.options[ set[ i ][ 0 ] ] ) {\n\t\t\t\tset[ i ][ 1 ].apply( instance.element, args );\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n/*!\n * jQuery UI Widget 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/jQuery.widget/\n */\n\n\nvar widget_uuid = 0,\n\twidget_slice = Array.prototype.slice;\n\n$.cleanData = (function( orig ) {\n\treturn function( elems ) {\n\t\tvar events, elem, i;\n\t\tfor ( i = 0; (elem = elems[i]) != null; i++ ) {\n\t\t\ttry {\n\n\t\t\t\t// Only trigger remove when necessary to save time\n\t\t\t\tevents = $._data( elem, "events" );\n\t\t\t\tif ( events && events.remove ) {\n\t\t\t\t\t$( elem ).triggerHandler( "remove" );\n\t\t\t\t}\n\n\t\t\t// http://bugs.jquery.com/ticket/8235\n\t\t\t} catch ( e ) {}\n\t\t}\n\t\torig( elems );\n\t};\n})( $.cleanData );\n\n$.widget = function( name, base, prototype ) {\n\tvar fullName, existingConstructor, constructor, basePrototype,\n\t\t// proxiedPrototype allows the provided prototype to remain unmodified\n\t\t// so that it can be used as a mixin for multiple widgets (#8876)\n\t\tproxiedPrototype = {},\n\t\tnamespace = name.split( "." )[ 0 ];\n\n\tname = name.split( "." )[ 1 ];\n\tfullName = namespace + "-" + name;\n\n\tif ( !prototype ) {\n\t\tprototype = base;\n\t\tbase = $.Widget;\n\t}\n\n\t// create selector for plugin\n\t$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {\n\t\treturn !!$.data( elem, fullName );\n\t};\n\n\t$[ namespace ] = $[ namespace ] || {};\n\texistingConstructor = $[ namespace ][ name ];\n\tconstructor = $[ namespace ][ name ] = function( options, element ) {\n\t\t// allow instantiation without "new" keyword\n\t\tif ( !this._createWidget ) {\n\t\t\treturn new constructor( options, element );\n\t\t}\n\n\t\t// allow instantiation without initializing for simple inheritance\n\t\t// must use "new" keyword (the code above always passes args)\n\t\tif ( arguments.length ) {\n\t\t\tthis._createWidget( options, element );\n\t\t}\n\t};\n\t// extend with the existing constructor to carry over any static properties\n\t$.extend( constructor, existingConstructor, {\n\t\tversion: prototype.version,\n\t\t// copy the object used to create the prototype in case we need to\n\t\t// redefine the widget later\n\t\t_proto: $.extend( {}, prototype ),\n\t\t// track widgets that inherit from this widget in case this widget is\n\t\t// redefined after a widget inherits from it\n\t\t_childConstructors: []\n\t});\n\n\tbasePrototype = new base();\n\t// we need to make the options hash a property directly on the new instance\n\t// otherwise we\'ll modify the options hash on the prototype that we\'re\n\t// inheriting from\n\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\n\t$.each( prototype, function( prop, value ) {\n\t\tif ( !$.isFunction( value ) ) {\n\t\t\tproxiedPrototype[ prop ] = value;\n\t\t\treturn;\n\t\t}\n\t\tproxiedPrototype[ prop ] = (function() {\n\t\t\tvar _super = function() {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, arguments );\n\t\t\t\t},\n\t\t\t\t_superApply = function( args ) {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, args );\n\t\t\t\t};\n\t\t\treturn function() {\n\t\t\t\tvar __super = this._super,\n\t\t\t\t\t__superApply = this._superApply,\n\t\t\t\t\treturnValue;\n\n\t\t\t\tthis._super = _super;\n\t\t\t\tthis._superApply = _superApply;\n\n\t\t\t\treturnValue = value.apply( this, arguments );\n\n\t\t\t\tthis._super = __super;\n\t\t\t\tthis._superApply = __superApply;\n\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t})();\n\t});\n\tconstructor.prototype = $.widget.extend( basePrototype, {\n\t\t// TODO: remove support for widgetEventPrefix\n\t\t// always use the name + a colon as the prefix, e.g., draggable:start\n\t\t// don\'t prefix for widgets that aren\'t DOM-based\n\t\twidgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\n\t}, proxiedPrototype, {\n\t\tconstructor: constructor,\n\t\tnamespace: namespace,\n\t\twidgetName: name,\n\t\twidgetFullName: fullName\n\t});\n\n\t// If this widget is being redefined then we need to find all widgets that\n\t// are inheriting from it and redefine all of them so that they inherit from\n\t// the new version of this widget. We\'re essentially trying to replace one\n\t// level in the prototype chain.\n\tif ( existingConstructor ) {\n\t\t$.each( existingConstructor._childConstructors, function( i, child ) {\n\t\t\tvar childPrototype = child.prototype;\n\n\t\t\t// redefine the child widget using the same prototype that was\n\t\t\t// originally used, but inherit from the new version of the base\n\t\t\t$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );\n\t\t});\n\t\t// remove the list of existing child constructors from the old constructor\n\t\t// so the old child constructors can be garbage collected\n\t\tdelete existingConstructor._childConstructors;\n\t} else {\n\t\tbase._childConstructors.push( constructor );\n\t}\n\n\t$.widget.bridge( name, constructor );\n\n\treturn constructor;\n};\n\n$.widget.extend = function( target ) {\n\tvar input = widget_slice.call( arguments, 1 ),\n\t\tinputIndex = 0,\n\t\tinputLength = input.length,\n\t\tkey,\n\t\tvalue;\n\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\n\t\tfor ( key in input[ inputIndex ] ) {\n\t\t\tvalue = input[ inputIndex ][ key ];\n\t\t\tif ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\n\t\t\t\t// Clone objects\n\t\t\t\tif ( $.isPlainObject( value ) ) {\n\t\t\t\t\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\n\t\t\t\t\t\t$.widget.extend( {}, target[ key ], value ) :\n\t\t\t\t\t\t// Don\'t extend strings, arrays, etc. with objects\n\t\t\t\t\t\t$.widget.extend( {}, value );\n\t\t\t\t// Copy everything else by reference\n\t\t\t\t} else {\n\t\t\t\t\ttarget[ key ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n};\n\n$.widget.bridge = function( name, object ) {\n\tvar fullName = object.prototype.widgetFullName || name;\n\t$.fn[ name ] = function( options ) {\n\t\tvar isMethodCall = typeof options === "string",\n\t\t\targs = widget_slice.call( arguments, 1 ),\n\t\t\treturnValue = this;\n\n\t\tif ( isMethodCall ) {\n\t\t\tthis.each(function() {\n\t\t\t\tvar methodValue,\n\t\t\t\t\tinstance = $.data( this, fullName );\n\t\t\t\tif ( options === "instance" ) {\n\t\t\t\t\treturnValue = instance;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif ( !instance ) {\n\t\t\t\t\treturn $.error( "cannot call methods on " + name + " prior to initialization; " +\n\t\t\t\t\t\t"attempted to call method \'" + options + "\'" );\n\t\t\t\t}\n\t\t\t\tif ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {\n\t\t\t\t\treturn $.error( "no such method \'" + options + "\' for " + name + " widget instance" );\n\t\t\t\t}\n\t\t\t\tmethodValue = instance[ options ].apply( instance, args );\n\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\n\t\t\t\t\treturnValue = methodValue && methodValue.jquery ?\n\t\t\t\t\t\treturnValue.pushStack( methodValue.get() ) :\n\t\t\t\t\t\tmethodValue;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\n\t\t\t// Allow multiple hashes to be passed on init\n\t\t\tif ( args.length ) {\n\t\t\t\toptions = $.widget.extend.apply( null, [ options ].concat(args) );\n\t\t\t}\n\n\t\t\tthis.each(function() {\n\t\t\t\tvar instance = $.data( this, fullName );\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tinstance.option( options || {} );\n\t\t\t\t\tif ( instance._init ) {\n\t\t\t\t\t\tinstance._init();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$.data( this, fullName, new object( options, this ) );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn returnValue;\n\t};\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n\twidgetName: "widget",\n\twidgetEventPrefix: "",\n\tdefaultElement: "<div>",\n\toptions: {\n\t\tdisabled: false,\n\n\t\t// callbacks\n\t\tcreate: null\n\t},\n\t_createWidget: function( options, element ) {\n\t\telement = $( element || this.defaultElement || this )[ 0 ];\n\t\tthis.element = $( element );\n\t\tthis.uuid = widget_uuid++;\n\t\tthis.eventNamespace = "." + this.widgetName + this.uuid;\n\n\t\tthis.bindings = $();\n\t\tthis.hoverable = $();\n\t\tthis.focusable = $();\n\n\t\tif ( element !== this ) {\n\t\t\t$.data( element, this.widgetFullName, this );\n\t\t\tthis._on( true, this.element, {\n\t\t\t\tremove: function( event ) {\n\t\t\t\t\tif ( event.target === element ) {\n\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.document = $( element.style ?\n\t\t\t\t// element within the document\n\t\t\t\telement.ownerDocument :\n\t\t\t\t// element is window or document\n\t\t\t\telement.document || element );\n\t\t\tthis.window = $( this.document[0].defaultView || this.document[0].parentWindow );\n\t\t}\n\n\t\tthis.options = $.widget.extend( {},\n\t\t\tthis.options,\n\t\t\tthis._getCreateOptions(),\n\t\t\toptions );\n\n\t\tthis._create();\n\t\tthis._trigger( "create", null, this._getCreateEventData() );\n\t\tthis._init();\n\t},\n\t_getCreateOptions: $.noop,\n\t_getCreateEventData: $.noop,\n\t_create: $.noop,\n\t_init: $.noop,\n\n\tdestroy: function() {\n\t\tthis._destroy();\n\t\t// we can probably remove the unbind calls in 2.0\n\t\t// all event bindings should go through this._on()\n\t\tthis.element\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t.removeData( this.widgetFullName )\n\t\t\t// support: jquery <1.6.3\n\t\t\t// http://bugs.jquery.com/ticket/9413\n\t\t\t.removeData( $.camelCase( this.widgetFullName ) );\n\t\tthis.widget()\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t.removeAttr( "aria-disabled" )\n\t\t\t.removeClass(\n\t\t\t\tthis.widgetFullName + "-disabled " +\n\t\t\t\t"ui-state-disabled" );\n\n\t\t// clean up events and states\n\t\tthis.bindings.unbind( this.eventNamespace );\n\t\tthis.hoverable.removeClass( "ui-state-hover" );\n\t\tthis.focusable.removeClass( "ui-state-focus" );\n\t},\n\t_destroy: $.noop,\n\n\twidget: function() {\n\t\treturn this.element;\n\t},\n\n\toption: function( key, value ) {\n\t\tvar options = key,\n\t\t\tparts,\n\t\t\tcurOption,\n\t\t\ti;\n\n\t\tif ( arguments.length === 0 ) {\n\t\t\t// don\'t return a reference to the internal hash\n\t\t\treturn $.widget.extend( {}, this.options );\n\t\t}\n\n\t\tif ( typeof key === "string" ) {\n\t\t\t// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }\n\t\t\toptions = {};\n\t\t\tparts = key.split( "." );\n\t\t\tkey = parts.shift();\n\t\t\tif ( parts.length ) {\n\t\t\t\tcurOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n\t\t\t\tfor ( i = 0; i < parts.length - 1; i++ ) {\n\t\t\t\t\tcurOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n\t\t\t\t\tcurOption = curOption[ parts[ i ] ];\n\t\t\t\t}\n\t\t\t\tkey = parts.pop();\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn curOption[ key ] === undefined ? null : curOption[ key ];\n\t\t\t\t}\n\t\t\t\tcurOption[ key ] = value;\n\t\t\t} else {\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn this.options[ key ] === undefined ? null : this.options[ key ];\n\t\t\t\t}\n\t\t\t\toptions[ key ] = value;\n\t\t\t}\n\t\t}\n\n\t\tthis._setOptions( options );\n\n\t\treturn this;\n\t},\n\t_setOptions: function( options ) {\n\t\tvar key;\n\n\t\tfor ( key in options ) {\n\t\t\tthis._setOption( key, options[ key ] );\n\t\t}\n\n\t\treturn this;\n\t},\n\t_setOption: function( key, value ) {\n\t\tthis.options[ key ] = value;\n\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.widget()\n\t\t\t\t.toggleClass( this.widgetFullName + "-disabled", !!value );\n\n\t\t\t// If the widget is becoming disabled, then nothing is interactive\n\t\t\tif ( value ) {\n\t\t\t\tthis.hoverable.removeClass( "ui-state-hover" );\n\t\t\t\tthis.focusable.removeClass( "ui-state-focus" );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tenable: function() {\n\t\treturn this._setOptions({ disabled: false });\n\t},\n\tdisable: function() {\n\t\treturn this._setOptions({ disabled: true });\n\t},\n\n\t_on: function( suppressDisabledCheck, element, handlers ) {\n\t\tvar delegateElement,\n\t\t\tinstance = this;\n\n\t\t// no suppressDisabledCheck flag, shuffle arguments\n\t\tif ( typeof suppressDisabledCheck !== "boolean" ) {\n\t\t\thandlers = element;\n\t\t\telement = suppressDisabledCheck;\n\t\t\tsuppressDisabledCheck = false;\n\t\t}\n\n\t\t// no element argument, shuffle and use this.element\n\t\tif ( !handlers ) {\n\t\t\thandlers = element;\n\t\t\telement = this.element;\n\t\t\tdelegateElement = this.widget();\n\t\t} else {\n\t\t\telement = delegateElement = $( element );\n\t\t\tthis.bindings = this.bindings.add( element );\n\t\t}\n\n\t\t$.each( handlers, function( event, handler ) {\n\t\t\tfunction handlerProxy() {\n\t\t\t\t// allow widgets to customize the disabled handling\n\t\t\t\t// - disabled as an array instead of boolean\n\t\t\t\t// - disabled class as method for disabling individual parts\n\t\t\t\tif ( !suppressDisabledCheck &&\n\t\t\t\t\t\t( instance.options.disabled === true ||\n\t\t\t\t\t\t\t$( this ).hasClass( "ui-state-disabled" ) ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn ( typeof handler === "string" ? instance[ handler ] : handler )\n\t\t\t\t\t.apply( instance, arguments );\n\t\t\t}\n\n\t\t\t// copy the guid so direct unbinding works\n\t\t\tif ( typeof handler !== "string" ) {\n\t\t\t\thandlerProxy.guid = handler.guid =\n\t\t\t\t\thandler.guid || handlerProxy.guid || $.guid++;\n\t\t\t}\n\n\t\t\tvar match = event.match( /^([\\w:-]*)\\s*(.*)$/ ),\n\t\t\t\teventName = match[1] + instance.eventNamespace,\n\t\t\t\tselector = match[2];\n\t\t\tif ( selector ) {\n\t\t\t\tdelegateElement.delegate( selector, eventName, handlerProxy );\n\t\t\t} else {\n\t\t\t\telement.bind( eventName, handlerProxy );\n\t\t\t}\n\t\t});\n\t},\n\n\t_off: function( element, eventName ) {\n\t\teventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +\n\t\t\tthis.eventNamespace;\n\t\telement.unbind( eventName ).undelegate( eventName );\n\n\t\t// Clear the stack to avoid memory leaks (#10056)\n\t\tthis.bindings = $( this.bindings.not( element ).get() );\n\t\tthis.focusable = $( this.focusable.not( element ).get() );\n\t\tthis.hoverable = $( this.hoverable.not( element ).get() );\n\t},\n\n\t_delay: function( handler, delay ) {\n\t\tfunction handlerProxy() {\n\t\t\treturn ( typeof handler === "string" ? instance[ handler ] : handler )\n\t\t\t\t.apply( instance, arguments );\n\t\t}\n\t\tvar instance = this;\n\t\treturn setTimeout( handlerProxy, delay || 0 );\n\t},\n\n\t_hoverable: function( element ) {\n\t\tthis.hoverable = this.hoverable.add( element );\n\t\tthis._on( element, {\n\t\t\tmouseenter: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( "ui-state-hover" );\n\t\t\t},\n\t\t\tmouseleave: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( "ui-state-hover" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_focusable: function( element ) {\n\t\tthis.focusable = this.focusable.add( element );\n\t\tthis._on( element, {\n\t\t\tfocusin: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( "ui-state-focus" );\n\t\t\t},\n\t\t\tfocusout: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( "ui-state-focus" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_trigger: function( type, event, data ) {\n\t\tvar prop, orig,\n\t\t\tcallback = this.options[ type ];\n\n\t\tdata = data || {};\n\t\tevent = $.Event( event );\n\t\tevent.type = ( type === this.widgetEventPrefix ?\n\t\t\ttype :\n\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\n\t\t// the original event may come from any element\n\t\t// so we need to reset the target on the new event\n\t\tevent.target = this.element[ 0 ];\n\n\t\t// copy original event properties over to the new event\n\t\torig = event.originalEvent;\n\t\tif ( orig ) {\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tif ( !( prop in event ) ) {\n\t\t\t\t\tevent[ prop ] = orig[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element.trigger( event, data );\n\t\treturn !( $.isFunction( callback ) &&\n\t\t\tcallback.apply( this.element[0], [ event ].concat( data ) ) === false ||\n\t\t\tevent.isDefaultPrevented() );\n\t}\n};\n\n$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {\n\t$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {\n\t\tif ( typeof options === "string" ) {\n\t\t\toptions = { effect: options };\n\t\t}\n\t\tvar hasOptions,\n\t\t\teffectName = !options ?\n\t\t\t\tmethod :\n\t\t\t\toptions === true || typeof options === "number" ?\n\t\t\t\t\tdefaultEffect :\n\t\t\t\t\toptions.effect || defaultEffect;\n\t\toptions = options || {};\n\t\tif ( typeof options === "number" ) {\n\t\t\toptions = { duration: options };\n\t\t}\n\t\thasOptions = !$.isEmptyObject( options );\n\t\toptions.complete = callback;\n\t\tif ( options.delay ) {\n\t\t\telement.delay( options.delay );\n\t\t}\n\t\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n\t\t\telement[ method ]( options );\n\t\t} else if ( effectName !== method && element[ effectName ] ) {\n\t\t\telement[ effectName ]( options.duration, options.easing, callback );\n\t\t} else {\n\t\t\telement.queue(function( next ) {\n\t\t\t\t$( this )[ method ]();\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback.call( element[ 0 ] );\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t};\n});\n\nvar widget = $.widget;\n\n\n/*!\n * jQuery UI Mouse 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/mouse/\n */\n\n\nvar mouseHandled = false;\n$( document ).mouseup( function() {\n\tmouseHandled = false;\n});\n\nvar mouse = $.widget("ui.mouse", {\n\tversion: "1.11.4",\n\toptions: {\n\t\tcancel: "input,textarea,button,select,option",\n\t\tdistance: 1,\n\t\tdelay: 0\n\t},\n\t_mouseInit: function() {\n\t\tvar that = this;\n\n\t\tthis.element\n\t\t\t.bind("mousedown." + this.widgetName, function(event) {\n\t\t\t\treturn that._mouseDown(event);\n\t\t\t})\n\t\t\t.bind("click." + this.widgetName, function(event) {\n\t\t\t\tif (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {\n\t\t\t\t\t$.removeData(event.target, that.widgetName + ".preventClickEvent");\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.started = false;\n\t},\n\n\t// TODO: make sure destroying one instance of mouse doesn\'t mess with\n\t// other instances of mouse\n\t_mouseDestroy: function() {\n\t\tthis.element.unbind("." + this.widgetName);\n\t\tif ( this._mouseMoveDelegate ) {\n\t\t\tthis.document\n\t\t\t\t.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)\n\t\t\t\t.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);\n\t\t}\n\t},\n\n\t_mouseDown: function(event) {\n\t\t// don\'t let more than one widget handle mouseStart\n\t\tif ( mouseHandled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._mouseMoved = false;\n\n\t\t// we may have missed mouseup (out of window)\n\t\t(this._mouseStarted && this._mouseUp(event));\n\n\t\tthis._mouseDownEvent = event;\n\n\t\tvar that = this,\n\t\t\tbtnIsLeft = (event.which === 1),\n\t\t\t// event.target.nodeName works around a bug in IE 8 with\n\t\t\t// disabled inputs (#7620)\n\t\t\telIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\n\t\tif (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tthis.mouseDelayMet = !this.options.delay;\n\t\tif (!this.mouseDelayMet) {\n\t\t\tthis._mouseDelayTimer = setTimeout(function() {\n\t\t\t\tthat.mouseDelayMet = true;\n\t\t\t}, this.options.delay);\n\t\t}\n\n\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\tthis._mouseStarted = (this._mouseStart(event) !== false);\n\t\t\tif (!this._mouseStarted) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Click event may never have fired (Gecko & Opera)\n\t\tif (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {\n\t\t\t$.removeData(event.target, this.widgetName + ".preventClickEvent");\n\t\t}\n\n\t\t// these delegates are required to keep context\n\t\tthis._mouseMoveDelegate = function(event) {\n\t\t\treturn that._mouseMove(event);\n\t\t};\n\t\tthis._mouseUpDelegate = function(event) {\n\t\t\treturn that._mouseUp(event);\n\t\t};\n\n\t\tthis.document\n\t\t\t.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )\n\t\t\t.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );\n\n\t\tevent.preventDefault();\n\n\t\tmouseHandled = true;\n\t\treturn true;\n\t},\n\n\t_mouseMove: function(event) {\n\t\t// Only check for mouseups outside the document if you\'ve moved inside the document\n\t\t// at least once. This prevents the firing of mouseup in the case of IE<9, which will\n\t\t// fire a mousemove event if content is placed under the cursor. See #7778\n\t\t// Support: IE <9\n\t\tif ( this._mouseMoved ) {\n\t\t\t// IE mouseup check - mouseup happened when mouse was out of window\n\t\t\tif ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {\n\t\t\t\treturn this._mouseUp(event);\n\n\t\t\t// Iframe mouseup check - mouseup occurred in another document\n\t\t\t} else if ( !event.which ) {\n\t\t\t\treturn this._mouseUp( event );\n\t\t\t}\n\t\t}\n\n\t\tif ( event.which || event.button ) {\n\t\t\tthis._mouseMoved = true;\n\t\t}\n\n\t\tif (this._mouseStarted) {\n\t\t\tthis._mouseDrag(event);\n\t\t\treturn event.preventDefault();\n\t\t}\n\n\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\tthis._mouseStarted =\n\t\t\t\t(this._mouseStart(this._mouseDownEvent, event) !== false);\n\t\t\t(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\n\t\t}\n\n\t\treturn !this._mouseStarted;\n\t},\n\n\t_mouseUp: function(event) {\n\t\tthis.document\n\t\t\t.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )\n\t\t\t.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );\n\n\t\tif (this._mouseStarted) {\n\t\t\tthis._mouseStarted = false;\n\n\t\t\tif (event.target === this._mouseDownEvent.target) {\n\t\t\t\t$.data(event.target, this.widgetName + ".preventClickEvent", true);\n\t\t\t}\n\n\t\t\tthis._mouseStop(event);\n\t\t}\n\n\t\tmouseHandled = false;\n\t\treturn false;\n\t},\n\n\t_mouseDistanceMet: function(event) {\n\t\treturn (Math.max(\n\t\t\t\tMath.abs(this._mouseDownEvent.pageX - event.pageX),\n\t\t\t\tMath.abs(this._mouseDownEvent.pageY - event.pageY)\n\t\t\t) >= this.options.distance\n\t\t);\n\t},\n\n\t_mouseDelayMet: function(/* event */) {\n\t\treturn this.mouseDelayMet;\n\t},\n\n\t// These are placeholder methods, to be overriden by extending plugin\n\t_mouseStart: function(/* event */) {},\n\t_mouseDrag: function(/* event */) {},\n\t_mouseStop: function(/* event */) {},\n\t_mouseCapture: function(/* event */) { return true; }\n});\n\n\n/*!\n * jQuery UI Position 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n\n(function() {\n\n$.ui = $.ui || {};\n\nvar cachedScrollbarWidth, supportsOffsetFractions,\n\tmax = Math.max,\n\tabs = Math.abs,\n\tround = Math.round,\n\trhorizontal = /left|center|right/,\n\trvertical = /top|center|bottom/,\n\troffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n\trposition = /^\\w+/,\n\trpercent = /%$/,\n\t_position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n\treturn [\n\t\tparseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n\t\tparseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n\t];\n}\n\nfunction parseCss( element, property ) {\n\treturn parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction getDimensions( elem ) {\n\tvar raw = elem[0];\n\tif ( raw.nodeType === 9 ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: 0, left: 0 }\n\t\t};\n\t}\n\tif ( $.isWindow( raw ) ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n\t\t};\n\t}\n\tif ( raw.preventDefault ) {\n\t\treturn {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\toffset: { top: raw.pageY, left: raw.pageX }\n\t\t};\n\t}\n\treturn {\n\t\twidth: elem.outerWidth(),\n\t\theight: elem.outerHeight(),\n\t\toffset: elem.offset()\n\t};\n}\n\n$.position = {\n\tscrollbarWidth: function() {\n\t\tif ( cachedScrollbarWidth !== undefined ) {\n\t\t\treturn cachedScrollbarWidth;\n\t\t}\n\t\tvar w1, w2,\n\t\t\tdiv = $( "<div style=\'display:block;position:absolute;width:50px;height:50px;overflow:hidden;\'><div style=\'height:100px;width:auto;\'></div></div>" ),\n\t\t\tinnerDiv = div.children()[0];\n\n\t\t$( "body" ).append( div );\n\t\tw1 = innerDiv.offsetWidth;\n\t\tdiv.css( "overflow", "scroll" );\n\n\t\tw2 = innerDiv.offsetWidth;\n\n\t\tif ( w1 === w2 ) {\n\t\t\tw2 = div[0].clientWidth;\n\t\t}\n\n\t\tdiv.remove();\n\n\t\treturn (cachedScrollbarWidth = w1 - w2);\n\t},\n\tgetScrollInfo: function( within ) {\n\t\tvar overflowX = within.isWindow || within.isDocument ? "" :\n\t\t\t\twithin.element.css( "overflow-x" ),\n\t\t\toverflowY = within.isWindow || within.isDocument ? "" :\n\t\t\t\twithin.element.css( "overflow-y" ),\n\t\t\thasOverflowX = overflowX === "scroll" ||\n\t\t\t\t( overflowX === "auto" && within.width < within.element[0].scrollWidth ),\n\t\t\thasOverflowY = overflowY === "scroll" ||\n\t\t\t\t( overflowY === "auto" && within.height < within.element[0].scrollHeight );\n\t\treturn {\n\t\t\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\n\t\t\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\n\t\t};\n\t},\n\tgetWithinInfo: function( element ) {\n\t\tvar withinElement = $( element || window ),\n\t\t\tisWindow = $.isWindow( withinElement[0] ),\n\t\t\tisDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;\n\t\treturn {\n\t\t\telement: withinElement,\n\t\t\tisWindow: isWindow,\n\t\t\tisDocument: isDocument,\n\t\t\toffset: withinElement.offset() || { left: 0, top: 0 },\n\t\t\tscrollLeft: withinElement.scrollLeft(),\n\t\t\tscrollTop: withinElement.scrollTop(),\n\n\t\t\t// support: jQuery 1.6.x\n\t\t\t// jQuery 1.6 doesn\'t support .outerWidth/Height() on documents or windows\n\t\t\twidth: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),\n\t\t\theight: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()\n\t\t};\n\t}\n};\n\n$.fn.position = function( options ) {\n\tif ( !options || !options.of ) {\n\t\treturn _position.apply( this, arguments );\n\t}\n\n\t// make a copy, we don\'t want to modify arguments\n\toptions = $.extend( {}, options );\n\n\tvar atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n\t\ttarget = $( options.of ),\n\t\twithin = $.position.getWithinInfo( options.within ),\n\t\tscrollInfo = $.position.getScrollInfo( within ),\n\t\tcollision = ( options.collision || "flip" ).split( " " ),\n\t\toffsets = {};\n\n\tdimensions = getDimensions( target );\n\tif ( target[0].preventDefault ) {\n\t\t// force left top to allow flipping\n\t\toptions.at = "left top";\n\t}\n\ttargetWidth = dimensions.width;\n\ttargetHeight = dimensions.height;\n\ttargetOffset = dimensions.offset;\n\t// clone to reuse original targetOffset later\n\tbasePosition = $.extend( {}, targetOffset );\n\n\t// force my and at to have valid horizontal and vertical positions\n\t// if a value is missing or invalid, it will be converted to center\n\t$.each( [ "my", "at" ], function() {\n\t\tvar pos = ( options[ this ] || "" ).split( " " ),\n\t\t\thorizontalOffset,\n\t\t\tverticalOffset;\n\n\t\tif ( pos.length === 1) {\n\t\t\tpos = rhorizontal.test( pos[ 0 ] ) ?\n\t\t\t\tpos.concat( [ "center" ] ) :\n\t\t\t\trvertical.test( pos[ 0 ] ) ?\n\t\t\t\t\t[ "center" ].concat( pos ) :\n\t\t\t\t\t[ "center", "center" ];\n\t\t}\n\t\tpos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";\n\t\tpos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";\n\n\t\t// calculate offsets\n\t\thorizontalOffset = roffset.exec( pos[ 0 ] );\n\t\tverticalOffset = roffset.exec( pos[ 1 ] );\n\t\toffsets[ this ] = [\n\t\t\thorizontalOffset ? horizontalOffset[ 0 ] : 0,\n\t\t\tverticalOffset ? verticalOffset[ 0 ] : 0\n\t\t];\n\n\t\t// reduce to just the positions without the offsets\n\t\toptions[ this ] = [\n\t\t\trposition.exec( pos[ 0 ] )[ 0 ],\n\t\t\trposition.exec( pos[ 1 ] )[ 0 ]\n\t\t];\n\t});\n\n\t// normalize collision option\n\tif ( collision.length === 1 ) {\n\t\tcollision[ 1 ] = collision[ 0 ];\n\t}\n\n\tif ( options.at[ 0 ] === "right" ) {\n\t\tbasePosition.left += targetWidth;\n\t} else if ( options.at[ 0 ] === "center" ) {\n\t\tbasePosition.left += targetWidth / 2;\n\t}\n\n\tif ( options.at[ 1 ] === "bottom" ) {\n\t\tbasePosition.top += targetHeight;\n\t} else if ( options.at[ 1 ] === "center" ) {\n\t\tbasePosition.top += targetHeight / 2;\n\t}\n\n\tatOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n\tbasePosition.left += atOffset[ 0 ];\n\tbasePosition.top += atOffset[ 1 ];\n\n\treturn this.each(function() {\n\t\tvar collisionPosition, using,\n\t\t\telem = $( this ),\n\t\t\telemWidth = elem.outerWidth(),\n\t\t\telemHeight = elem.outerHeight(),\n\t\t\tmarginLeft = parseCss( this, "marginLeft" ),\n\t\t\tmarginTop = parseCss( this, "marginTop" ),\n\t\t\tcollisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,\n\t\t\tcollisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,\n\t\t\tposition = $.extend( {}, basePosition ),\n\t\t\tmyOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n\t\tif ( options.my[ 0 ] === "right" ) {\n\t\t\tposition.left -= elemWidth;\n\t\t} else if ( options.my[ 0 ] === "center" ) {\n\t\t\tposition.left -= elemWidth / 2;\n\t\t}\n\n\t\tif ( options.my[ 1 ] === "bottom" ) {\n\t\t\tposition.top -= elemHeight;\n\t\t} else if ( options.my[ 1 ] === "center" ) {\n\t\t\tposition.top -= elemHeight / 2;\n\t\t}\n\n\t\tposition.left += myOffset[ 0 ];\n\t\tposition.top += myOffset[ 1 ];\n\n\t\t// if the browser doesn\'t support fractions, then round for consistent results\n\t\tif ( !supportsOffsetFractions ) {\n\t\t\tposition.left = round( position.left );\n\t\t\tposition.top = round( position.top );\n\t\t}\n\n\t\tcollisionPosition = {\n\t\t\tmarginLeft: marginLeft,\n\t\t\tmarginTop: marginTop\n\t\t};\n\n\t\t$.each( [ "left", "top" ], function( i, dir ) {\n\t\t\tif ( $.ui.position[ collision[ i ] ] ) {\n\t\t\t\t$.ui.position[ collision[ i ] ][ dir ]( position, {\n\t\t\t\t\ttargetWidth: targetWidth,\n\t\t\t\t\ttargetHeight: targetHeight,\n\t\t\t\t\telemWidth: elemWidth,\n\t\t\t\t\telemHeight: elemHeight,\n\t\t\t\t\tcollisionPosition: collisionPosition,\n\t\t\t\t\tcollisionWidth: collisionWidth,\n\t\t\t\t\tcollisionHeight: collisionHeight,\n\t\t\t\t\toffset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n\t\t\t\t\tmy: options.my,\n\t\t\t\t\tat: options.at,\n\t\t\t\t\twithin: within,\n\t\t\t\t\telem: elem\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tif ( options.using ) {\n\t\t\t// adds feedback as second argument to using callback, if present\n\t\t\tusing = function( props ) {\n\t\t\t\tvar left = targetOffset.left - position.left,\n\t\t\t\t\tright = left + targetWidth - elemWidth,\n\t\t\t\t\ttop = targetOffset.top - position.top,\n\t\t\t\t\tbottom = top + targetHeight - elemHeight,\n\t\t\t\t\tfeedback = {\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\telement: target,\n\t\t\t\t\t\t\tleft: targetOffset.left,\n\t\t\t\t\t\t\ttop: targetOffset.top,\n\t\t\t\t\t\t\twidth: targetWidth,\n\t\t\t\t\t\t\theight: targetHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\telement: {\n\t\t\t\t\t\t\telement: elem,\n\t\t\t\t\t\t\tleft: position.left,\n\t\t\t\t\t\t\ttop: position.top,\n\t\t\t\t\t\t\twidth: elemWidth,\n\t\t\t\t\t\t\theight: elemHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\thorizontal: right < 0 ? "left" : left > 0 ? "right" : "center",\n\t\t\t\t\t\tvertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"\n\t\t\t\t\t};\n\t\t\t\tif ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n\t\t\t\t\tfeedback.horizontal = "center";\n\t\t\t\t}\n\t\t\t\tif ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n\t\t\t\t\tfeedback.vertical = "middle";\n\t\t\t\t}\n\t\t\t\tif ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n\t\t\t\t\tfeedback.important = "horizontal";\n\t\t\t\t} else {\n\t\t\t\t\tfeedback.important = "vertical";\n\t\t\t\t}\n\t\t\t\toptions.using.call( this, props, feedback );\n\t\t\t};\n\t\t}\n\n\t\telem.offset( $.extend( position, { using: using } ) );\n\t});\n};\n\n$.ui.position = {\n\tfit: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\touterWidth = within.width,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = withinOffset - collisionPosLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n\t\t\t\tnewOverRight;\n\n\t\t\t// element is wider than within\n\t\t\tif ( data.collisionWidth > outerWidth ) {\n\t\t\t\t// element is initially over the left side of within\n\t\t\t\tif ( overLeft > 0 && overRight <= 0 ) {\n\t\t\t\t\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n\t\t\t\t\tposition.left += overLeft - newOverRight;\n\t\t\t\t// element is initially over right side of within\n\t\t\t\t} else if ( overRight > 0 && overLeft <= 0 ) {\n\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t// element is initially over both left and right sides of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overLeft > overRight ) {\n\t\t\t\t\t\tposition.left = withinOffset + outerWidth - data.collisionWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// too far left -> align with left edge\n\t\t\t} else if ( overLeft > 0 ) {\n\t\t\t\tposition.left += overLeft;\n\t\t\t// too far right -> align with right edge\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tposition.left -= overRight;\n\t\t\t// adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.left = max( position.left - collisionPosLeft, position.left );\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\touterHeight = data.within.height,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = withinOffset - collisionPosTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n\t\t\t\tnewOverBottom;\n\n\t\t\t// element is taller than within\n\t\t\tif ( data.collisionHeight > outerHeight ) {\n\t\t\t\t// element is initially over the top of within\n\t\t\t\tif ( overTop > 0 && overBottom <= 0 ) {\n\t\t\t\t\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n\t\t\t\t\tposition.top += overTop - newOverBottom;\n\t\t\t\t// element is initially over bottom of within\n\t\t\t\t} else if ( overBottom > 0 && overTop <= 0 ) {\n\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t// element is initially over both top and bottom of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overTop > overBottom ) {\n\t\t\t\t\t\tposition.top = withinOffset + outerHeight - data.collisionHeight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// too far up -> align with top\n\t\t\t} else if ( overTop > 0 ) {\n\t\t\t\tposition.top += overTop;\n\t\t\t// too far down -> align with bottom edge\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tposition.top -= overBottom;\n\t\t\t// adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.top = max( position.top - collisionPosTop, position.top );\n\t\t\t}\n\t\t}\n\t},\n\tflip: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.left + within.scrollLeft,\n\t\t\t\touterWidth = within.width,\n\t\t\t\toffsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = collisionPosLeft - offsetLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n\t\t\t\tmyOffset = data.my[ 0 ] === "left" ?\n\t\t\t\t\t-data.elemWidth :\n\t\t\t\t\tdata.my[ 0 ] === "right" ?\n\t\t\t\t\t\tdata.elemWidth :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 0 ] === "left" ?\n\t\t\t\t\tdata.targetWidth :\n\t\t\t\t\tdata.at[ 0 ] === "right" ?\n\t\t\t\t\t\t-data.targetWidth :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 0 ],\n\t\t\t\tnewOverRight,\n\t\t\t\tnewOverLeft;\n\n\t\t\tif ( overLeft < 0 ) {\n\t\t\t\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n\t\t\t\tif ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n\t\t\t\tif ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.top + within.scrollTop,\n\t\t\t\touterHeight = within.height,\n\t\t\t\toffsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = collisionPosTop - offsetTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n\t\t\t\ttop = data.my[ 1 ] === "top",\n\t\t\t\tmyOffset = top ?\n\t\t\t\t\t-data.elemHeight :\n\t\t\t\t\tdata.my[ 1 ] === "bottom" ?\n\t\t\t\t\t\tdata.elemHeight :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 1 ] === "top" ?\n\t\t\t\t\tdata.targetHeight :\n\t\t\t\t\tdata.at[ 1 ] === "bottom" ?\n\t\t\t\t\t\t-data.targetHeight :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 1 ],\n\t\t\t\tnewOverTop,\n\t\t\t\tnewOverBottom;\n\t\t\tif ( overTop < 0 ) {\n\t\t\t\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n\t\t\t\tif ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tnewOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n\t\t\t\tif ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tflipfit: {\n\t\tleft: function() {\n\t\t\t$.ui.position.flip.left.apply( this, arguments );\n\t\t\t$.ui.position.fit.left.apply( this, arguments );\n\t\t},\n\t\ttop: function() {\n\t\t\t$.ui.position.flip.top.apply( this, arguments );\n\t\t\t$.ui.position.fit.top.apply( this, arguments );\n\t\t}\n\t}\n};\n\n// fraction support test\n(function() {\n\tvar testElement, testElementParent, testElementStyle, offsetLeft, i,\n\t\tbody = document.getElementsByTagName( "body" )[ 0 ],\n\t\tdiv = document.createElement( "div" );\n\n\t//Create a "fake body" for testing based on method used in jQuery.support\n\ttestElement = document.createElement( body ? "div" : "body" );\n\ttestElementStyle = {\n\t\tvisibility: "hidden",\n\t\twidth: 0,\n\t\theight: 0,\n\t\tborder: 0,\n\t\tmargin: 0,\n\t\tbackground: "none"\n\t};\n\tif ( body ) {\n\t\t$.extend( testElementStyle, {\n\t\t\tposition: "absolute",\n\t\t\tleft: "-1000px",\n\t\t\ttop: "-1000px"\n\t\t});\n\t}\n\tfor ( i in testElementStyle ) {\n\t\ttestElement.style[ i ] = testElementStyle[ i ];\n\t}\n\ttestElement.appendChild( div );\n\ttestElementParent = body || document.documentElement;\n\ttestElementParent.insertBefore( testElement, testElementParent.firstChild );\n\n\tdiv.style.cssText = "position: absolute; left: 10.7432222px;";\n\n\toffsetLeft = $( div ).offset().left;\n\tsupportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;\n\n\ttestElement.innerHTML = "";\n\ttestElementParent.removeChild( testElement );\n})();\n\n})();\n\nvar position = $.ui.position;\n\n\n/*!\n * jQuery UI Accordion 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/accordion/\n */\n\n\nvar accordion = $.widget( "ui.accordion", {\n\tversion: "1.11.4",\n\toptions: {\n\t\tactive: 0,\n\t\tanimate: {},\n\t\tcollapsible: false,\n\t\tevent: "click",\n\t\theader: "> li > :first-child,> :not(li):even",\n\t\theightStyle: "auto",\n\t\ticons: {\n\t\t\tactiveHeader: "ui-icon-triangle-1-s",\n\t\t\theader: "ui-icon-triangle-1-e"\n\t\t},\n\n\t\t// callbacks\n\t\tactivate: null,\n\t\tbeforeActivate: null\n\t},\n\n\thideProps: {\n\t\tborderTopWidth: "hide",\n\t\tborderBottomWidth: "hide",\n\t\tpaddingTop: "hide",\n\t\tpaddingBottom: "hide",\n\t\theight: "hide"\n\t},\n\n\tshowProps: {\n\t\tborderTopWidth: "show",\n\t\tborderBottomWidth: "show",\n\t\tpaddingTop: "show",\n\t\tpaddingBottom: "show",\n\t\theight: "show"\n\t},\n\n\t_create: function() {\n\t\tvar options = this.options;\n\t\tthis.prevShow = this.prevHide = $();\n\t\tthis.element.addClass( "ui-accordion ui-widget ui-helper-reset" )\n\t\t\t// ARIA\n\t\t\t.attr( "role", "tablist" );\n\n\t\t// don\'t allow collapsible: false and active: false / null\n\t\tif ( !options.collapsible && (options.active === false || options.active == null) ) {\n\t\t\toptions.active = 0;\n\t\t}\n\n\t\tthis._processPanels();\n\t\t// handle negative values\n\t\tif ( options.active < 0 ) {\n\t\t\toptions.active += this.headers.length;\n\t\t}\n\t\tthis._refresh();\n\t},\n\n\t_getCreateEventData: function() {\n\t\treturn {\n\t\t\theader: this.active,\n\t\t\tpanel: !this.active.length ? $() : this.active.next()\n\t\t};\n\t},\n\n\t_createIcons: function() {\n\t\tvar icons = this.options.icons;\n\t\tif ( icons ) {\n\t\t\t$( "<span>" )\n\t\t\t\t.addClass( "ui-accordion-header-icon ui-icon " + icons.header )\n\t\t\t\t.prependTo( this.headers );\n\t\t\tthis.active.children( ".ui-accordion-header-icon" )\n\t\t\t\t.removeClass( icons.header )\n\t\t\t\t.addClass( icons.activeHeader );\n\t\t\tthis.headers.addClass( "ui-accordion-icons" );\n\t\t}\n\t},\n\n\t_destroyIcons: function() {\n\t\tthis.headers\n\t\t\t.removeClass( "ui-accordion-icons" )\n\t\t\t.children( ".ui-accordion-header-icon" )\n\t\t\t\t.remove();\n\t},\n\n\t_destroy: function() {\n\t\tvar contents;\n\n\t\t// clean up main element\n\t\tthis.element\n\t\t\t.removeClass( "ui-accordion ui-widget ui-helper-reset" )\n\t\t\t.removeAttr( "role" );\n\n\t\t// clean up headers\n\t\tthis.headers\n\t\t\t.removeClass( "ui-accordion-header ui-accordion-header-active ui-state-default " +\n\t\t\t\t"ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )\n\t\t\t.removeAttr( "role" )\n\t\t\t.removeAttr( "aria-expanded" )\n\t\t\t.removeAttr( "aria-selected" )\n\t\t\t.removeAttr( "aria-controls" )\n\t\t\t.removeAttr( "tabIndex" )\n\t\t\t.removeUniqueId();\n\n\t\tthis._destroyIcons();\n\n\t\t// clean up content panels\n\t\tcontents = this.headers.next()\n\t\t\t.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom " +\n\t\t\t\t"ui-accordion-content ui-accordion-content-active ui-state-disabled" )\n\t\t\t.css( "display", "" )\n\t\t\t.removeAttr( "role" )\n\t\t\t.removeAttr( "aria-hidden" )\n\t\t\t.removeAttr( "aria-labelledby" )\n\t\t\t.removeUniqueId();\n\n\t\tif ( this.options.heightStyle !== "content" ) {\n\t\t\tcontents.css( "height", "" );\n\t\t}\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "active" ) {\n\t\t\t// _activate() will handle invalid values and update this.options\n\t\t\tthis._activate( value );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === "event" ) {\n\t\t\tif ( this.options.event ) {\n\t\t\t\tthis._off( this.headers, this.options.event );\n\t\t\t}\n\t\t\tthis._setupEvents( value );\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\t// setting collapsible: false while collapsed; open first panel\n\t\tif ( key === "collapsible" && !value && this.options.active === false ) {\n\t\t\tthis._activate( 0 );\n\t\t}\n\n\t\tif ( key === "icons" ) {\n\t\t\tthis._destroyIcons();\n\t\t\tif ( value ) {\n\t\t\t\tthis._createIcons();\n\t\t\t}\n\t\t}\n\n\t\t// #5332 - opacity doesn\'t cascade to positioned elements in IE\n\t\t// so we need to add the disabled class to the headers and panels\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.element\n\t\t\t\t.toggleClass( "ui-state-disabled", !!value )\n\t\t\t\t.attr( "aria-disabled", value );\n\t\t\tthis.headers.add( this.headers.next() )\n\t\t\t\t.toggleClass( "ui-state-disabled", !!value );\n\t\t}\n\t},\n\n\t_keydown: function( event ) {\n\t\tif ( event.altKey || event.ctrlKey ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar keyCode = $.ui.keyCode,\n\t\t\tlength = this.headers.length,\n\t\t\tcurrentIndex = this.headers.index( event.target ),\n\t\t\ttoFocus = false;\n\n\t\tswitch ( event.keyCode ) {\n\t\t\tcase keyCode.RIGHT:\n\t\t\tcase keyCode.DOWN:\n\t\t\t\ttoFocus = this.headers[ ( currentIndex + 1 ) % length ];\n\t\t\t\tbreak;\n\t\t\tcase keyCode.LEFT:\n\t\t\tcase keyCode.UP:\n\t\t\t\ttoFocus = this.headers[ ( currentIndex - 1 + length ) % length ];\n\t\t\t\tbreak;\n\t\t\tcase keyCode.SPACE:\n\t\t\tcase keyCode.ENTER:\n\t\t\t\tthis._eventHandler( event );\n\t\t\t\tbreak;\n\t\t\tcase keyCode.HOME:\n\t\t\t\ttoFocus = this.headers[ 0 ];\n\t\t\t\tbreak;\n\t\t\tcase keyCode.END:\n\t\t\t\ttoFocus = this.headers[ length - 1 ];\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ( toFocus ) {\n\t\t\t$( event.target ).attr( "tabIndex", -1 );\n\t\t\t$( toFocus ).attr( "tabIndex", 0 );\n\t\t\ttoFocus.focus();\n\t\t\tevent.preventDefault();\n\t\t}\n\t},\n\n\t_panelKeyDown: function( event ) {\n\t\tif ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {\n\t\t\t$( event.currentTarget ).prev().focus();\n\t\t}\n\t},\n\n\trefresh: function() {\n\t\tvar options = this.options;\n\t\tthis._processPanels();\n\n\t\t// was collapsed or no panel\n\t\tif ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {\n\t\t\toptions.active = false;\n\t\t\tthis.active = $();\n\t\t// active false only when collapsible is true\n\t\t} else if ( options.active === false ) {\n\t\t\tthis._activate( 0 );\n\t\t// was active, but active panel is gone\n\t\t} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {\n\t\t\t// all remaining panel are disabled\n\t\t\tif ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {\n\t\t\t\toptions.active = false;\n\t\t\t\tthis.active = $();\n\t\t\t// activate previous panel\n\t\t\t} else {\n\t\t\t\tthis._activate( Math.max( 0, options.active - 1 ) );\n\t\t\t}\n\t\t// was active, active panel still exists\n\t\t} else {\n\t\t\t// make sure active index is correct\n\t\t\toptions.active = this.headers.index( this.active );\n\t\t}\n\n\t\tthis._destroyIcons();\n\n\t\tthis._refresh();\n\t},\n\n\t_processPanels: function() {\n\t\tvar prevHeaders = this.headers,\n\t\t\tprevPanels = this.panels;\n\n\t\tthis.headers = this.element.find( this.options.header )\n\t\t\t.addClass( "ui-accordion-header ui-state-default ui-corner-all" );\n\n\t\tthis.panels = this.headers.next()\n\t\t\t.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )\n\t\t\t.filter( ":not(.ui-accordion-content-active)" )\n\t\t\t.hide();\n\n\t\t// Avoid memory leaks (#10056)\n\t\tif ( prevPanels ) {\n\t\t\tthis._off( prevHeaders.not( this.headers ) );\n\t\t\tthis._off( prevPanels.not( this.panels ) );\n\t\t}\n\t},\n\n\t_refresh: function() {\n\t\tvar maxHeight,\n\t\t\toptions = this.options,\n\t\t\theightStyle = options.heightStyle,\n\t\t\tparent = this.element.parent();\n\n\t\tthis.active = this._findActive( options.active )\n\t\t\t.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )\n\t\t\t.removeClass( "ui-corner-all" );\n\t\tthis.active.next()\n\t\t\t.addClass( "ui-accordion-content-active" )\n\t\t\t.show();\n\n\t\tthis.headers\n\t\t\t.attr( "role", "tab" )\n\t\t\t.each(function() {\n\t\t\t\tvar header = $( this ),\n\t\t\t\t\theaderId = header.uniqueId().attr( "id" ),\n\t\t\t\t\tpanel = header.next(),\n\t\t\t\t\tpanelId = panel.uniqueId().attr( "id" );\n\t\t\t\theader.attr( "aria-controls", panelId );\n\t\t\t\tpanel.attr( "aria-labelledby", headerId );\n\t\t\t})\n\t\t\t.next()\n\t\t\t\t.attr( "role", "tabpanel" );\n\n\t\tthis.headers\n\t\t\t.not( this.active )\n\t\t\t.attr({\n\t\t\t\t"aria-selected": "false",\n\t\t\t\t"aria-expanded": "false",\n\t\t\t\ttabIndex: -1\n\t\t\t})\n\t\t\t.next()\n\t\t\t\t.attr({\n\t\t\t\t\t"aria-hidden": "true"\n\t\t\t\t})\n\t\t\t\t.hide();\n\n\t\t// make sure at least one header is in the tab order\n\t\tif ( !this.active.length ) {\n\t\t\tthis.headers.eq( 0 ).attr( "tabIndex", 0 );\n\t\t} else {\n\t\t\tthis.active.attr({\n\t\t\t\t"aria-selected": "true",\n\t\t\t\t"aria-expanded": "true",\n\t\t\t\ttabIndex: 0\n\t\t\t})\n\t\t\t.next()\n\t\t\t\t.attr({\n\t\t\t\t\t"aria-hidden": "false"\n\t\t\t\t});\n\t\t}\n\n\t\tthis._createIcons();\n\n\t\tthis._setupEvents( options.event );\n\n\t\tif ( heightStyle === "fill" ) {\n\t\t\tmaxHeight = parent.height();\n\t\t\tthis.element.siblings( ":visible" ).each(function() {\n\t\t\t\tvar elem = $( this ),\n\t\t\t\t\tposition = elem.css( "position" );\n\n\t\t\t\tif ( position === "absolute" || position === "fixed" ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmaxHeight -= elem.outerHeight( true );\n\t\t\t});\n\n\t\t\tthis.headers.each(function() {\n\t\t\t\tmaxHeight -= $( this ).outerHeight( true );\n\t\t\t});\n\n\t\t\tthis.headers.next()\n\t\t\t\t.each(function() {\n\t\t\t\t\t$( this ).height( Math.max( 0, maxHeight -\n\t\t\t\t\t\t$( this ).innerHeight() + $( this ).height() ) );\n\t\t\t\t})\n\t\t\t\t.css( "overflow", "auto" );\n\t\t} else if ( heightStyle === "auto" ) {\n\t\t\tmaxHeight = 0;\n\t\t\tthis.headers.next()\n\t\t\t\t.each(function() {\n\t\t\t\t\tmaxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );\n\t\t\t\t})\n\t\t\t\t.height( maxHeight );\n\t\t}\n\t},\n\n\t_activate: function( index ) {\n\t\tvar active = this._findActive( index )[ 0 ];\n\n\t\t// trying to activate the already active panel\n\t\tif ( active === this.active[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// trying to collapse, simulate a click on the currently active header\n\t\tactive = active || this.active[ 0 ];\n\n\t\tthis._eventHandler({\n\t\t\ttarget: active,\n\t\t\tcurrentTarget: active,\n\t\t\tpreventDefault: $.noop\n\t\t});\n\t},\n\n\t_findActive: function( selector ) {\n\t\treturn typeof selector === "number" ? this.headers.eq( selector ) : $();\n\t},\n\n\t_setupEvents: function( event ) {\n\t\tvar events = {\n\t\t\tkeydown: "_keydown"\n\t\t};\n\t\tif ( event ) {\n\t\t\t$.each( event.split( " " ), function( index, eventName ) {\n\t\t\t\tevents[ eventName ] = "_eventHandler";\n\t\t\t});\n\t\t}\n\n\t\tthis._off( this.headers.add( this.headers.next() ) );\n\t\tthis._on( this.headers, events );\n\t\tthis._on( this.headers.next(), { keydown: "_panelKeyDown" });\n\t\tthis._hoverable( this.headers );\n\t\tthis._focusable( this.headers );\n\t},\n\n\t_eventHandler: function( event ) {\n\t\tvar options = this.options,\n\t\t\tactive = this.active,\n\t\t\tclicked = $( event.currentTarget ),\n\t\t\tclickedIsActive = clicked[ 0 ] === active[ 0 ],\n\t\t\tcollapsing = clickedIsActive && options.collapsible,\n\t\t\ttoShow = collapsing ? $() : clicked.next(),\n\t\t\ttoHide = active.next(),\n\t\t\teventData = {\n\t\t\t\toldHeader: active,\n\t\t\t\toldPanel: toHide,\n\t\t\t\tnewHeader: collapsing ? $() : clicked,\n\t\t\t\tnewPanel: toShow\n\t\t\t};\n\n\t\tevent.preventDefault();\n\n\t\tif (\n\t\t\t\t// click on active header, but not collapsible\n\t\t\t\t( clickedIsActive && !options.collapsible ) ||\n\t\t\t\t// allow canceling activation\n\t\t\t\t( this._trigger( "beforeActivate", event, eventData ) === false ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\toptions.active = collapsing ? false : this.headers.index( clicked );\n\n\t\t// when the call to ._toggle() comes after the class changes\n\t\t// it causes a very odd bug in IE 8 (see #6720)\n\t\tthis.active = clickedIsActive ? $() : clicked;\n\t\tthis._toggle( eventData );\n\n\t\t// switch classes\n\t\t// corner classes on the previously active header stay after the animation\n\t\tactive.removeClass( "ui-accordion-header-active ui-state-active" );\n\t\tif ( options.icons ) {\n\t\t\tactive.children( ".ui-accordion-header-icon" )\n\t\t\t\t.removeClass( options.icons.activeHeader )\n\t\t\t\t.addClass( options.icons.header );\n\t\t}\n\n\t\tif ( !clickedIsActive ) {\n\t\t\tclicked\n\t\t\t\t.removeClass( "ui-corner-all" )\n\t\t\t\t.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );\n\t\t\tif ( options.icons ) {\n\t\t\t\tclicked.children( ".ui-accordion-header-icon" )\n\t\t\t\t\t.removeClass( options.icons.header )\n\t\t\t\t\t.addClass( options.icons.activeHeader );\n\t\t\t}\n\n\t\t\tclicked\n\t\t\t\t.next()\n\t\t\t\t.addClass( "ui-accordion-content-active" );\n\t\t}\n\t},\n\n\t_toggle: function( data ) {\n\t\tvar toShow = data.newPanel,\n\t\t\ttoHide = this.prevShow.length ? this.prevShow : data.oldPanel;\n\n\t\t// handle activating a panel during the animation for another activation\n\t\tthis.prevShow.add( this.prevHide ).stop( true, true );\n\t\tthis.prevShow = toShow;\n\t\tthis.prevHide = toHide;\n\n\t\tif ( this.options.animate ) {\n\t\t\tthis._animate( toShow, toHide, data );\n\t\t} else {\n\t\t\ttoHide.hide();\n\t\t\ttoShow.show();\n\t\t\tthis._toggleComplete( data );\n\t\t}\n\n\t\ttoHide.attr({\n\t\t\t"aria-hidden": "true"\n\t\t});\n\t\ttoHide.prev().attr({\n\t\t\t"aria-selected": "false",\n\t\t\t"aria-expanded": "false"\n\t\t});\n\t\t// if we\'re switching panels, remove the old header from the tab order\n\t\t// if we\'re opening from collapsed state, remove the previous header from the tab order\n\t\t// if we\'re collapsing, then keep the collapsing header in the tab order\n\t\tif ( toShow.length && toHide.length ) {\n\t\t\ttoHide.prev().attr({\n\t\t\t\t"tabIndex": -1,\n\t\t\t\t"aria-expanded": "false"\n\t\t\t});\n\t\t} else if ( toShow.length ) {\n\t\t\tthis.headers.filter(function() {\n\t\t\t\treturn parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;\n\t\t\t})\n\t\t\t.attr( "tabIndex", -1 );\n\t\t}\n\n\t\ttoShow\n\t\t\t.attr( "aria-hidden", "false" )\n\t\t\t.prev()\n\t\t\t\t.attr({\n\t\t\t\t\t"aria-selected": "true",\n\t\t\t\t\t"aria-expanded": "true",\n\t\t\t\t\ttabIndex: 0\n\t\t\t\t});\n\t},\n\n\t_animate: function( toShow, toHide, data ) {\n\t\tvar total, easing, duration,\n\t\t\tthat = this,\n\t\t\tadjust = 0,\n\t\t\tboxSizing = toShow.css( "box-sizing" ),\n\t\t\tdown = toShow.length &&\n\t\t\t\t( !toHide.length || ( toShow.index() < toHide.index() ) ),\n\t\t\tanimate = this.options.animate || {},\n\t\t\toptions = down && animate.down || animate,\n\t\t\tcomplete = function() {\n\t\t\t\tthat._toggleComplete( data );\n\t\t\t};\n\n\t\tif ( typeof options === "number" ) {\n\t\t\tduration = options;\n\t\t}\n\t\tif ( typeof options === "string" ) {\n\t\t\teasing = options;\n\t\t}\n\t\t// fall back from options to animation in case of partial down settings\n\t\teasing = easing || options.easing || animate.easing;\n\t\tduration = duration || options.duration || animate.duration;\n\n\t\tif ( !toHide.length ) {\n\t\t\treturn toShow.animate( this.showProps, duration, easing, complete );\n\t\t}\n\t\tif ( !toShow.length ) {\n\t\t\treturn toHide.animate( this.hideProps, duration, easing, complete );\n\t\t}\n\n\t\ttotal = toShow.show().outerHeight();\n\t\ttoHide.animate( this.hideProps, {\n\t\t\tduration: duration,\n\t\t\teasing: easing,\n\t\t\tstep: function( now, fx ) {\n\t\t\t\tfx.now = Math.round( now );\n\t\t\t}\n\t\t});\n\t\ttoShow\n\t\t\t.hide()\n\t\t\t.animate( this.showProps, {\n\t\t\t\tduration: duration,\n\t\t\t\teasing: easing,\n\t\t\t\tcomplete: complete,\n\t\t\t\tstep: function( now, fx ) {\n\t\t\t\t\tfx.now = Math.round( now );\n\t\t\t\t\tif ( fx.prop !== "height" ) {\n\t\t\t\t\t\tif ( boxSizing === "content-box" ) {\n\t\t\t\t\t\t\tadjust += fx.now;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( that.options.heightStyle !== "content" ) {\n\t\t\t\t\t\tfx.now = Math.round( total - toHide.outerHeight() - adjust );\n\t\t\t\t\t\tadjust = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t},\n\n\t_toggleComplete: function( data ) {\n\t\tvar toHide = data.oldPanel;\n\n\t\ttoHide\n\t\t\t.removeClass( "ui-accordion-content-active" )\n\t\t\t.prev()\n\t\t\t\t.removeClass( "ui-corner-top" )\n\t\t\t\t.addClass( "ui-corner-all" );\n\n\t\t// Work around for rendering bug in IE (#5421)\n\t\tif ( toHide.length ) {\n\t\t\ttoHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;\n\t\t}\n\t\tthis._trigger( "activate", null, data );\n\t}\n});\n\n\n/*!\n * jQuery UI Menu 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/menu/\n */\n\n\nvar menu = $.widget( "ui.menu", {\n\tversion: "1.11.4",\n\tdefaultElement: "<ul>",\n\tdelay: 300,\n\toptions: {\n\t\ticons: {\n\t\t\tsubmenu: "ui-icon-carat-1-e"\n\t\t},\n\t\titems: "> *",\n\t\tmenus: "ul",\n\t\tposition: {\n\t\t\tmy: "left-1 top",\n\t\t\tat: "right top"\n\t\t},\n\t\trole: "menu",\n\n\t\t// callbacks\n\t\tblur: null,\n\t\tfocus: null,\n\t\tselect: null\n\t},\n\n\t_create: function() {\n\t\tthis.activeMenu = this.element;\n\n\t\t// Flag used to prevent firing of the click handler\n\t\t// as the event bubbles up through nested menus\n\t\tthis.mouseHandled = false;\n\t\tthis.element\n\t\t\t.uniqueId()\n\t\t\t.addClass( "ui-menu ui-widget ui-widget-content" )\n\t\t\t.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )\n\t\t\t.attr({\n\t\t\t\trole: this.options.role,\n\t\t\t\ttabIndex: 0\n\t\t\t});\n\n\t\tif ( this.options.disabled ) {\n\t\t\tthis.element\n\t\t\t\t.addClass( "ui-state-disabled" )\n\t\t\t\t.attr( "aria-disabled", "true" );\n\t\t}\n\n\t\tthis._on({\n\t\t\t// Prevent focus from sticking to links inside menu after clicking\n\t\t\t// them (focus should always stay on UL during navigation).\n\t\t\t"mousedown .ui-menu-item": function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t},\n\t\t\t"click .ui-menu-item": function( event ) {\n\t\t\t\tvar target = $( event.target );\n\t\t\t\tif ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {\n\t\t\t\t\tthis.select( event );\n\n\t\t\t\t\t// Only set the mouseHandled flag if the event will bubble, see #9469.\n\t\t\t\t\tif ( !event.isPropagationStopped() ) {\n\t\t\t\t\t\tthis.mouseHandled = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Open submenu on click\n\t\t\t\t\tif ( target.has( ".ui-menu" ).length ) {\n\t\t\t\t\t\tthis.expand( event );\n\t\t\t\t\t} else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {\n\n\t\t\t\t\t\t// Redirect focus to the menu\n\t\t\t\t\t\tthis.element.trigger( "focus", [ true ] );\n\n\t\t\t\t\t\t// If the active item is on the top level, let it stay active.\n\t\t\t\t\t\t// Otherwise, blur the active item since it is no longer visible.\n\t\t\t\t\t\tif ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {\n\t\t\t\t\t\t\tclearTimeout( this.timer );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t"mouseenter .ui-menu-item": function( event ) {\n\t\t\t\t// Ignore mouse events while typeahead is active, see #10458.\n\t\t\t\t// Prevents focusing the wrong item when typeahead causes a scroll while the mouse\n\t\t\t\t// is over an item in the menu\n\t\t\t\tif ( this.previousFilter ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar target = $( event.currentTarget );\n\t\t\t\t// Remove ui-state-active class from siblings of the newly focused menu item\n\t\t\t\t// to avoid a jump caused by adjacent elements both having a class with a border\n\t\t\t\ttarget.siblings( ".ui-state-active" ).removeClass( "ui-state-active" );\n\t\t\t\tthis.focus( event, target );\n\t\t\t},\n\t\t\tmouseleave: "collapseAll",\n\t\t\t"mouseleave .ui-menu": "collapseAll",\n\t\t\tfocus: function( event, keepActiveItem ) {\n\t\t\t\t// If there\'s already an active item, keep it active\n\t\t\t\t// If not, activate the first item\n\t\t\t\tvar item = this.active || this.element.find( this.options.items ).eq( 0 );\n\n\t\t\t\tif ( !keepActiveItem ) {\n\t\t\t\t\tthis.focus( event, item );\n\t\t\t\t}\n\t\t\t},\n\t\t\tblur: function( event ) {\n\t\t\t\tthis._delay(function() {\n\t\t\t\t\tif ( !$.contains( this.element[0], this.document[0].activeElement ) ) {\n\t\t\t\t\t\tthis.collapseAll( event );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tkeydown: "_keydown"\n\t\t});\n\n\t\tthis.refresh();\n\n\t\t// Clicks outside of a menu collapse any open menus\n\t\tthis._on( this.document, {\n\t\t\tclick: function( event ) {\n\t\t\t\tif ( this._closeOnDocumentClick( event ) ) {\n\t\t\t\t\tthis.collapseAll( event );\n\t\t\t\t}\n\n\t\t\t\t// Reset the mouseHandled flag\n\t\t\t\tthis.mouseHandled = false;\n\t\t\t}\n\t\t});\n\t},\n\n\t_destroy: function() {\n\t\t// Destroy (sub)menus\n\t\tthis.element\n\t\t\t.removeAttr( "aria-activedescendant" )\n\t\t\t.find( ".ui-menu" ).addBack()\n\t\t\t\t.removeClass( "ui-menu ui-widget ui-widget-content ui-menu-icons ui-front" )\n\t\t\t\t.removeAttr( "role" )\n\t\t\t\t.removeAttr( "tabIndex" )\n\t\t\t\t.removeAttr( "aria-labelledby" )\n\t\t\t\t.removeAttr( "aria-expanded" )\n\t\t\t\t.removeAttr( "aria-hidden" )\n\t\t\t\t.removeAttr( "aria-disabled" )\n\t\t\t\t.removeUniqueId()\n\t\t\t\t.show();\n\n\t\t// Destroy menu items\n\t\tthis.element.find( ".ui-menu-item" )\n\t\t\t.removeClass( "ui-menu-item" )\n\t\t\t.removeAttr( "role" )\n\t\t\t.removeAttr( "aria-disabled" )\n\t\t\t.removeUniqueId()\n\t\t\t.removeClass( "ui-state-hover" )\n\t\t\t.removeAttr( "tabIndex" )\n\t\t\t.removeAttr( "role" )\n\t\t\t.removeAttr( "aria-haspopup" )\n\t\t\t.children().each( function() {\n\t\t\t\tvar elem = $( this );\n\t\t\t\tif ( elem.data( "ui-menu-submenu-carat" ) ) {\n\t\t\t\t\telem.remove();\n\t\t\t\t}\n\t\t\t});\n\n\t\t// Destroy menu dividers\n\t\tthis.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );\n\t},\n\n\t_keydown: function( event ) {\n\t\tvar match, prev, character, skip,\n\t\t\tpreventDefault = true;\n\n\t\tswitch ( event.keyCode ) {\n\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\tthis.previousPage( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\tthis.nextPage( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.HOME:\n\t\t\tthis._move( "first", "first", event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.END:\n\t\t\tthis._move( "last", "last", event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.UP:\n\t\t\tthis.previous( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.DOWN:\n\t\t\tthis.next( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.LEFT:\n\t\t\tthis.collapse( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.RIGHT:\n\t\t\tif ( this.active && !this.active.is( ".ui-state-disabled" ) ) {\n\t\t\t\tthis.expand( event );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.ENTER:\n\t\tcase $.ui.keyCode.SPACE:\n\t\t\tthis._activate( event );\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.ESCAPE:\n\t\t\tthis.collapse( event );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpreventDefault = false;\n\t\t\tprev = this.previousFilter || "";\n\t\t\tcharacter = String.fromCharCode( event.keyCode );\n\t\t\tskip = false;\n\n\t\t\tclearTimeout( this.filterTimer );\n\n\t\t\tif ( character === prev ) {\n\t\t\t\tskip = true;\n\t\t\t} else {\n\t\t\t\tcharacter = prev + character;\n\t\t\t}\n\n\t\t\tmatch = this._filterMenuItems( character );\n\t\t\tmatch = skip && match.index( this.active.next() ) !== -1 ?\n\t\t\t\tthis.active.nextAll( ".ui-menu-item" ) :\n\t\t\t\tmatch;\n\n\t\t\t// If no matches on the current filter, reset to the last character pressed\n\t\t\t// to move down the menu to the first item that starts with that character\n\t\t\tif ( !match.length ) {\n\t\t\t\tcharacter = String.fromCharCode( event.keyCode );\n\t\t\t\tmatch = this._filterMenuItems( character );\n\t\t\t}\n\n\t\t\tif ( match.length ) {\n\t\t\t\tthis.focus( event, match );\n\t\t\t\tthis.previousFilter = character;\n\t\t\t\tthis.filterTimer = this._delay(function() {\n\t\t\t\t\tdelete this.previousFilter;\n\t\t\t\t}, 1000 );\n\t\t\t} else {\n\t\t\t\tdelete this.previousFilter;\n\t\t\t}\n\t\t}\n\n\t\tif ( preventDefault ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t},\n\n\t_activate: function( event ) {\n\t\tif ( !this.active.is( ".ui-state-disabled" ) ) {\n\t\t\tif ( this.active.is( "[aria-haspopup=\'true\']" ) ) {\n\t\t\t\tthis.expand( event );\n\t\t\t} else {\n\t\t\t\tthis.select( event );\n\t\t\t}\n\t\t}\n\t},\n\n\trefresh: function() {\n\t\tvar menus, items,\n\t\t\tthat = this,\n\t\t\ticon = this.options.icons.submenu,\n\t\t\tsubmenus = this.element.find( this.options.menus );\n\n\t\tthis.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );\n\n\t\t// Initialize nested menus\n\t\tsubmenus.filter( ":not(.ui-menu)" )\n\t\t\t.addClass( "ui-menu ui-widget ui-widget-content ui-front" )\n\t\t\t.hide()\n\t\t\t.attr({\n\t\t\t\trole: this.options.role,\n\t\t\t\t"aria-hidden": "true",\n\t\t\t\t"aria-expanded": "false"\n\t\t\t})\n\t\t\t.each(function() {\n\t\t\t\tvar menu = $( this ),\n\t\t\t\t\titem = menu.parent(),\n\t\t\t\t\tsubmenuCarat = $( "<span>" )\n\t\t\t\t\t\t.addClass( "ui-menu-icon ui-icon " + icon )\n\t\t\t\t\t\t.data( "ui-menu-submenu-carat", true );\n\n\t\t\t\titem\n\t\t\t\t\t.attr( "aria-haspopup", "true" )\n\t\t\t\t\t.prepend( submenuCarat );\n\t\t\t\tmenu.attr( "aria-labelledby", item.attr( "id" ) );\n\t\t\t});\n\n\t\tmenus = submenus.add( this.element );\n\t\titems = menus.find( this.options.items );\n\n\t\t// Initialize menu-items containing spaces and/or dashes only as dividers\n\t\titems.not( ".ui-menu-item" ).each(function() {\n\t\t\tvar item = $( this );\n\t\t\tif ( that._isDivider( item ) ) {\n\t\t\t\titem.addClass( "ui-widget-content ui-menu-divider" );\n\t\t\t}\n\t\t});\n\n\t\t// Don\'t refresh list items that are already adapted\n\t\titems.not( ".ui-menu-item, .ui-menu-divider" )\n\t\t\t.addClass( "ui-menu-item" )\n\t\t\t.uniqueId()\n\t\t\t.attr({\n\t\t\t\ttabIndex: -1,\n\t\t\t\trole: this._itemRole()\n\t\t\t});\n\n\t\t// Add aria-disabled attribute to any disabled menu item\n\t\titems.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );\n\n\t\t// If the active item has been removed, blur the menu\n\t\tif ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {\n\t\t\tthis.blur();\n\t\t}\n\t},\n\n\t_itemRole: function() {\n\t\treturn {\n\t\t\tmenu: "menuitem",\n\t\t\tlistbox: "option"\n\t\t}[ this.options.role ];\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "icons" ) {\n\t\t\tthis.element.find( ".ui-menu-icon" )\n\t\t\t\t.removeClass( this.options.icons.submenu )\n\t\t\t\t.addClass( value.submenu );\n\t\t}\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.element\n\t\t\t\t.toggleClass( "ui-state-disabled", !!value )\n\t\t\t\t.attr( "aria-disabled", value );\n\t\t}\n\t\tthis._super( key, value );\n\t},\n\n\tfocus: function( event, item ) {\n\t\tvar nested, focused;\n\t\tthis.blur( event, event && event.type === "focus" );\n\n\t\tthis._scrollIntoView( item );\n\n\t\tthis.active = item.first();\n\t\tfocused = this.active.addClass( "ui-state-focus" ).removeClass( "ui-state-active" );\n\t\t// Only update aria-activedescendant if there\'s a role\n\t\t// otherwise we assume focus is managed elsewhere\n\t\tif ( this.options.role ) {\n\t\t\tthis.element.attr( "aria-activedescendant", focused.attr( "id" ) );\n\t\t}\n\n\t\t// Highlight active parent menu item, if any\n\t\tthis.active\n\t\t\t.parent()\n\t\t\t.closest( ".ui-menu-item" )\n\t\t\t.addClass( "ui-state-active" );\n\n\t\tif ( event && event.type === "keydown" ) {\n\t\t\tthis._close();\n\t\t} else {\n\t\t\tthis.timer = this._delay(function() {\n\t\t\t\tthis._close();\n\t\t\t}, this.delay );\n\t\t}\n\n\t\tnested = item.children( ".ui-menu" );\n\t\tif ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {\n\t\t\tthis._startOpening(nested);\n\t\t}\n\t\tthis.activeMenu = item.parent();\n\n\t\tthis._trigger( "focus", event, { item: item } );\n\t},\n\n\t_scrollIntoView: function( item ) {\n\t\tvar borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;\n\t\tif ( this._hasScroll() ) {\n\t\t\tborderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;\n\t\t\tpaddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;\n\t\t\toffset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;\n\t\t\tscroll = this.activeMenu.scrollTop();\n\t\t\telementHeight = this.activeMenu.height();\n\t\t\titemHeight = item.outerHeight();\n\n\t\t\tif ( offset < 0 ) {\n\t\t\t\tthis.activeMenu.scrollTop( scroll + offset );\n\t\t\t} else if ( offset + itemHeight > elementHeight ) {\n\t\t\t\tthis.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );\n\t\t\t}\n\t\t}\n\t},\n\n\tblur: function( event, fromFocus ) {\n\t\tif ( !fromFocus ) {\n\t\t\tclearTimeout( this.timer );\n\t\t}\n\n\t\tif ( !this.active ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.active.removeClass( "ui-state-focus" );\n\t\tthis.active = null;\n\n\t\tthis._trigger( "blur", event, { item: this.active } );\n\t},\n\n\t_startOpening: function( submenu ) {\n\t\tclearTimeout( this.timer );\n\n\t\t// Don\'t open if already open fixes a Firefox bug that caused a .5 pixel\n\t\t// shift in the submenu position when mousing over the carat icon\n\t\tif ( submenu.attr( "aria-hidden" ) !== "true" ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.timer = this._delay(function() {\n\t\t\tthis._close();\n\t\t\tthis._open( submenu );\n\t\t}, this.delay );\n\t},\n\n\t_open: function( submenu ) {\n\t\tvar position = $.extend({\n\t\t\tof: this.active\n\t\t}, this.options.position );\n\n\t\tclearTimeout( this.timer );\n\t\tthis.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )\n\t\t\t.hide()\n\t\t\t.attr( "aria-hidden", "true" );\n\n\t\tsubmenu\n\t\t\t.show()\n\t\t\t.removeAttr( "aria-hidden" )\n\t\t\t.attr( "aria-expanded", "true" )\n\t\t\t.position( position );\n\t},\n\n\tcollapseAll: function( event, all ) {\n\t\tclearTimeout( this.timer );\n\t\tthis.timer = this._delay(function() {\n\t\t\t// If we were passed an event, look for the submenu that contains the event\n\t\t\tvar currentMenu = all ? this.element :\n\t\t\t\t$( event && event.target ).closest( this.element.find( ".ui-menu" ) );\n\n\t\t\t// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway\n\t\t\tif ( !currentMenu.length ) {\n\t\t\t\tcurrentMenu = this.element;\n\t\t\t}\n\n\t\t\tthis._close( currentMenu );\n\n\t\t\tthis.blur( event );\n\t\t\tthis.activeMenu = currentMenu;\n\t\t}, this.delay );\n\t},\n\n\t// With no arguments, closes the currently active menu - if nothing is active\n\t// it closes all menus.  If passed an argument, it will search for menus BELOW\n\t_close: function( startMenu ) {\n\t\tif ( !startMenu ) {\n\t\t\tstartMenu = this.active ? this.active.parent() : this.element;\n\t\t}\n\n\t\tstartMenu\n\t\t\t.find( ".ui-menu" )\n\t\t\t\t.hide()\n\t\t\t\t.attr( "aria-hidden", "true" )\n\t\t\t\t.attr( "aria-expanded", "false" )\n\t\t\t.end()\n\t\t\t.find( ".ui-state-active" ).not( ".ui-state-focus" )\n\t\t\t\t.removeClass( "ui-state-active" );\n\t},\n\n\t_closeOnDocumentClick: function( event ) {\n\t\treturn !$( event.target ).closest( ".ui-menu" ).length;\n\t},\n\n\t_isDivider: function( item ) {\n\n\t\t// Match hyphen, em dash, en dash\n\t\treturn !/[^\\-\\u2014\\u2013\\s]/.test( item.text() );\n\t},\n\n\tcollapse: function( event ) {\n\t\tvar newItem = this.active &&\n\t\t\tthis.active.parent().closest( ".ui-menu-item", this.element );\n\t\tif ( newItem && newItem.length ) {\n\t\t\tthis._close();\n\t\t\tthis.focus( event, newItem );\n\t\t}\n\t},\n\n\texpand: function( event ) {\n\t\tvar newItem = this.active &&\n\t\t\tthis.active\n\t\t\t\t.children( ".ui-menu " )\n\t\t\t\t.find( this.options.items )\n\t\t\t\t.first();\n\n\t\tif ( newItem && newItem.length ) {\n\t\t\tthis._open( newItem.parent() );\n\n\t\t\t// Delay so Firefox will not hide activedescendant change in expanding submenu from AT\n\t\t\tthis._delay(function() {\n\t\t\t\tthis.focus( event, newItem );\n\t\t\t});\n\t\t}\n\t},\n\n\tnext: function( event ) {\n\t\tthis._move( "next", "first", event );\n\t},\n\n\tprevious: function( event ) {\n\t\tthis._move( "prev", "last", event );\n\t},\n\n\tisFirstItem: function() {\n\t\treturn this.active && !this.active.prevAll( ".ui-menu-item" ).length;\n\t},\n\n\tisLastItem: function() {\n\t\treturn this.active && !this.active.nextAll( ".ui-menu-item" ).length;\n\t},\n\n\t_move: function( direction, filter, event ) {\n\t\tvar next;\n\t\tif ( this.active ) {\n\t\t\tif ( direction === "first" || direction === "last" ) {\n\t\t\t\tnext = this.active\n\t\t\t\t\t[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )\n\t\t\t\t\t.eq( -1 );\n\t\t\t} else {\n\t\t\t\tnext = this.active\n\t\t\t\t\t[ direction + "All" ]( ".ui-menu-item" )\n\t\t\t\t\t.eq( 0 );\n\t\t\t}\n\t\t}\n\t\tif ( !next || !next.length || !this.active ) {\n\t\t\tnext = this.activeMenu.find( this.options.items )[ filter ]();\n\t\t}\n\n\t\tthis.focus( event, next );\n\t},\n\n\tnextPage: function( event ) {\n\t\tvar item, base, height;\n\n\t\tif ( !this.active ) {\n\t\t\tthis.next( event );\n\t\t\treturn;\n\t\t}\n\t\tif ( this.isLastItem() ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( this._hasScroll() ) {\n\t\t\tbase = this.active.offset().top;\n\t\t\theight = this.element.height();\n\t\t\tthis.active.nextAll( ".ui-menu-item" ).each(function() {\n\t\t\t\titem = $( this );\n\t\t\t\treturn item.offset().top - base - height < 0;\n\t\t\t});\n\n\t\t\tthis.focus( event, item );\n\t\t} else {\n\t\t\tthis.focus( event, this.activeMenu.find( this.options.items )\n\t\t\t\t[ !this.active ? "first" : "last" ]() );\n\t\t}\n\t},\n\n\tpreviousPage: function( event ) {\n\t\tvar item, base, height;\n\t\tif ( !this.active ) {\n\t\t\tthis.next( event );\n\t\t\treturn;\n\t\t}\n\t\tif ( this.isFirstItem() ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( this._hasScroll() ) {\n\t\t\tbase = this.active.offset().top;\n\t\t\theight = this.element.height();\n\t\t\tthis.active.prevAll( ".ui-menu-item" ).each(function() {\n\t\t\t\titem = $( this );\n\t\t\t\treturn item.offset().top - base + height > 0;\n\t\t\t});\n\n\t\t\tthis.focus( event, item );\n\t\t} else {\n\t\t\tthis.focus( event, this.activeMenu.find( this.options.items ).first() );\n\t\t}\n\t},\n\n\t_hasScroll: function() {\n\t\treturn this.element.outerHeight() < this.element.prop( "scrollHeight" );\n\t},\n\n\tselect: function( event ) {\n\t\t// TODO: It should never be possible to not have an active item at this\n\t\t// point, but the tests don\'t trigger mouseenter before click.\n\t\tthis.active = this.active || $( event.target ).closest( ".ui-menu-item" );\n\t\tvar ui = { item: this.active };\n\t\tif ( !this.active.has( ".ui-menu" ).length ) {\n\t\t\tthis.collapseAll( event, true );\n\t\t}\n\t\tthis._trigger( "select", event, ui );\n\t},\n\n\t_filterMenuItems: function(character) {\n\t\tvar escapedCharacter = character.replace( /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, "\\\\$&" ),\n\t\t\tregex = new RegExp( "^" + escapedCharacter, "i" );\n\n\t\treturn this.activeMenu\n\t\t\t.find( this.options.items )\n\n\t\t\t// Only match on items, not dividers or other content (#10571)\n\t\t\t.filter( ".ui-menu-item" )\n\t\t\t.filter(function() {\n\t\t\t\treturn regex.test( $.trim( $( this ).text() ) );\n\t\t\t});\n\t}\n});\n\n\n/*!\n * jQuery UI Autocomplete 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/autocomplete/\n */\n\n\n$.widget( "ui.autocomplete", {\n\tversion: "1.11.4",\n\tdefaultElement: "<input>",\n\toptions: {\n\t\tappendTo: null,\n\t\tautoFocus: false,\n\t\tdelay: 300,\n\t\tminLength: 1,\n\t\tposition: {\n\t\t\tmy: "left top",\n\t\t\tat: "left bottom",\n\t\t\tcollision: "none"\n\t\t},\n\t\tsource: null,\n\n\t\t// callbacks\n\t\tchange: null,\n\t\tclose: null,\n\t\tfocus: null,\n\t\topen: null,\n\t\tresponse: null,\n\t\tsearch: null,\n\t\tselect: null\n\t},\n\n\trequestIndex: 0,\n\tpending: 0,\n\n\t_create: function() {\n\t\t// Some browsers only repeat keydown events, not keypress events,\n\t\t// so we use the suppressKeyPress flag to determine if we\'ve already\n\t\t// handled the keydown event. #7269\n\t\t// Unfortunately the code for & in keypress is the same as the up arrow,\n\t\t// so we use the suppressKeyPressRepeat flag to avoid handling keypress\n\t\t// events when we know the keydown event was used to modify the\n\t\t// search term. #7799\n\t\tvar suppressKeyPress, suppressKeyPressRepeat, suppressInput,\n\t\t\tnodeName = this.element[ 0 ].nodeName.toLowerCase(),\n\t\t\tisTextarea = nodeName === "textarea",\n\t\t\tisInput = nodeName === "input";\n\n\t\tthis.isMultiLine =\n\t\t\t// Textareas are always multi-line\n\t\t\tisTextarea ? true :\n\t\t\t// Inputs are always single-line, even if inside a contentEditable element\n\t\t\t// IE also treats inputs as contentEditable\n\t\t\tisInput ? false :\n\t\t\t// All other element types are determined by whether or not they\'re contentEditable\n\t\t\tthis.element.prop( "isContentEditable" );\n\n\t\tthis.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];\n\t\tthis.isNewMenu = true;\n\n\t\tthis.element\n\t\t\t.addClass( "ui-autocomplete-input" )\n\t\t\t.attr( "autocomplete", "off" );\n\n\t\tthis._on( this.element, {\n\t\t\tkeydown: function( event ) {\n\t\t\t\tif ( this.element.prop( "readOnly" ) ) {\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tsuppressInput = true;\n\t\t\t\t\tsuppressKeyPressRepeat = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsuppressKeyPress = false;\n\t\t\t\tsuppressInput = false;\n\t\t\t\tsuppressKeyPressRepeat = false;\n\t\t\t\tvar keyCode = $.ui.keyCode;\n\t\t\t\tswitch ( event.keyCode ) {\n\t\t\t\tcase keyCode.PAGE_UP:\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tthis._move( "previousPage", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.PAGE_DOWN:\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tthis._move( "nextPage", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.UP:\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tthis._keyEvent( "previous", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.DOWN:\n\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\tthis._keyEvent( "next", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.ENTER:\n\t\t\t\t\t// when menu is open and has focus\n\t\t\t\t\tif ( this.menu.active ) {\n\t\t\t\t\t\t// #6055 - Opera still allows the keypress to occur\n\t\t\t\t\t\t// which causes forms to submit\n\t\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tthis.menu.select( event );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.TAB:\n\t\t\t\t\tif ( this.menu.active ) {\n\t\t\t\t\t\tthis.menu.select( event );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.ESCAPE:\n\t\t\t\t\tif ( this.menu.element.is( ":visible" ) ) {\n\t\t\t\t\t\tif ( !this.isMultiLine ) {\n\t\t\t\t\t\t\tthis._value( this.term );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.close( event );\n\t\t\t\t\t\t// Different browsers have different default behavior for escape\n\t\t\t\t\t\t// Single press can mean undo or clear\n\t\t\t\t\t\t// Double press in IE means clear the whole form\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsuppressKeyPressRepeat = true;\n\t\t\t\t\t// search timeout should be triggered before the input value is changed\n\t\t\t\t\tthis._searchTimeout( event );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeypress: function( event ) {\n\t\t\t\tif ( suppressKeyPress ) {\n\t\t\t\t\tsuppressKeyPress = false;\n\t\t\t\t\tif ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( suppressKeyPressRepeat ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// replicate some key handlers to allow them to repeat in Firefox and Opera\n\t\t\t\tvar keyCode = $.ui.keyCode;\n\t\t\t\tswitch ( event.keyCode ) {\n\t\t\t\tcase keyCode.PAGE_UP:\n\t\t\t\t\tthis._move( "previousPage", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.PAGE_DOWN:\n\t\t\t\t\tthis._move( "nextPage", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.UP:\n\t\t\t\t\tthis._keyEvent( "previous", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.DOWN:\n\t\t\t\t\tthis._keyEvent( "next", event );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\t\t\tinput: function( event ) {\n\t\t\t\tif ( suppressInput ) {\n\t\t\t\t\tsuppressInput = false;\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._searchTimeout( event );\n\t\t\t},\n\t\t\tfocus: function() {\n\t\t\t\tthis.selectedItem = null;\n\t\t\t\tthis.previous = this._value();\n\t\t\t},\n\t\t\tblur: function( event ) {\n\t\t\t\tif ( this.cancelBlur ) {\n\t\t\t\t\tdelete this.cancelBlur;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tclearTimeout( this.searching );\n\t\t\t\tthis.close( event );\n\t\t\t\tthis._change( event );\n\t\t\t}\n\t\t});\n\n\t\tthis._initSource();\n\t\tthis.menu = $( "<ul>" )\n\t\t\t.addClass( "ui-autocomplete ui-front" )\n\t\t\t.appendTo( this._appendTo() )\n\t\t\t.menu({\n\t\t\t\t// disable ARIA support, the live region takes care of that\n\t\t\t\trole: null\n\t\t\t})\n\t\t\t.hide()\n\t\t\t.menu( "instance" );\n\n\t\tthis._on( this.menu.element, {\n\t\t\tmousedown: function( event ) {\n\t\t\t\t// prevent moving focus out of the text field\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\t// IE doesn\'t prevent moving focus even with event.preventDefault()\n\t\t\t\t// so we set a flag to know when we should ignore the blur event\n\t\t\t\tthis.cancelBlur = true;\n\t\t\t\tthis._delay(function() {\n\t\t\t\t\tdelete this.cancelBlur;\n\t\t\t\t});\n\n\t\t\t\t// clicking on the scrollbar causes focus to shift to the body\n\t\t\t\t// but we can\'t detect a mouseup or a click immediately afterward\n\t\t\t\t// so we have to track the next mousedown and close the menu if\n\t\t\t\t// the user clicks somewhere outside of the autocomplete\n\t\t\t\tvar menuElement = this.menu.element[ 0 ];\n\t\t\t\tif ( !$( event.target ).closest( ".ui-menu-item" ).length ) {\n\t\t\t\t\tthis._delay(function() {\n\t\t\t\t\t\tvar that = this;\n\t\t\t\t\t\tthis.document.one( "mousedown", function( event ) {\n\t\t\t\t\t\t\tif ( event.target !== that.element[ 0 ] &&\n\t\t\t\t\t\t\t\t\tevent.target !== menuElement &&\n\t\t\t\t\t\t\t\t\t!$.contains( menuElement, event.target ) ) {\n\t\t\t\t\t\t\t\tthat.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tmenufocus: function( event, ui ) {\n\t\t\t\tvar label, item;\n\t\t\t\t// support: Firefox\n\t\t\t\t// Prevent accidental activation of menu items in Firefox (#7024 #9118)\n\t\t\t\tif ( this.isNewMenu ) {\n\t\t\t\t\tthis.isNewMenu = false;\n\t\t\t\t\tif ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {\n\t\t\t\t\t\tthis.menu.blur();\n\n\t\t\t\t\t\tthis.document.one( "mousemove", function() {\n\t\t\t\t\t\t\t$( event.target ).trigger( event.originalEvent );\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titem = ui.item.data( "ui-autocomplete-item" );\n\t\t\t\tif ( false !== this._trigger( "focus", event, { item: item } ) ) {\n\t\t\t\t\t// use value to match what will end up in the input, if it was a key event\n\t\t\t\t\tif ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {\n\t\t\t\t\t\tthis._value( item.value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Announce the value in the liveRegion\n\t\t\t\tlabel = ui.item.attr( "aria-label" ) || item.value;\n\t\t\t\tif ( label && $.trim( label ).length ) {\n\t\t\t\t\tthis.liveRegion.children().hide();\n\t\t\t\t\t$( "<div>" ).text( label ).appendTo( this.liveRegion );\n\t\t\t\t}\n\t\t\t},\n\t\t\tmenuselect: function( event, ui ) {\n\t\t\t\tvar item = ui.item.data( "ui-autocomplete-item" ),\n\t\t\t\t\tprevious = this.previous;\n\n\t\t\t\t// only trigger when focus was lost (click on menu)\n\t\t\t\tif ( this.element[ 0 ] !== this.document[ 0 ].activeElement ) {\n\t\t\t\t\tthis.element.focus();\n\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t// #6109 - IE triggers two focus events and the second\n\t\t\t\t\t// is asynchronous, so we need to reset the previous\n\t\t\t\t\t// term synchronously and asynchronously :-(\n\t\t\t\t\tthis._delay(function() {\n\t\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t\tthis.selectedItem = item;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif ( false !== this._trigger( "select", event, { item: item } ) ) {\n\t\t\t\t\tthis._value( item.value );\n\t\t\t\t}\n\t\t\t\t// reset the term after the select event\n\t\t\t\t// this allows custom select handling to work properly\n\t\t\t\tthis.term = this._value();\n\n\t\t\t\tthis.close( event );\n\t\t\t\tthis.selectedItem = item;\n\t\t\t}\n\t\t});\n\n\t\tthis.liveRegion = $( "<span>", {\n\t\t\t\trole: "status",\n\t\t\t\t"aria-live": "assertive",\n\t\t\t\t"aria-relevant": "additions"\n\t\t\t})\n\t\t\t.addClass( "ui-helper-hidden-accessible" )\n\t\t\t.appendTo( this.document[ 0 ].body );\n\n\t\t// turning off autocomplete prevents the browser from remembering the\n\t\t// value when navigating through history, so we re-enable autocomplete\n\t\t// if the page is unloaded before the widget is destroyed. #7790\n\t\tthis._on( this.window, {\n\t\t\tbeforeunload: function() {\n\t\t\t\tthis.element.removeAttr( "autocomplete" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_destroy: function() {\n\t\tclearTimeout( this.searching );\n\t\tthis.element\n\t\t\t.removeClass( "ui-autocomplete-input" )\n\t\t\t.removeAttr( "autocomplete" );\n\t\tthis.menu.element.remove();\n\t\tthis.liveRegion.remove();\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tthis._super( key, value );\n\t\tif ( key === "source" ) {\n\t\t\tthis._initSource();\n\t\t}\n\t\tif ( key === "appendTo" ) {\n\t\t\tthis.menu.element.appendTo( this._appendTo() );\n\t\t}\n\t\tif ( key === "disabled" && value && this.xhr ) {\n\t\t\tthis.xhr.abort();\n\t\t}\n\t},\n\n\t_appendTo: function() {\n\t\tvar element = this.options.appendTo;\n\n\t\tif ( element ) {\n\t\t\telement = element.jquery || element.nodeType ?\n\t\t\t\t$( element ) :\n\t\t\t\tthis.document.find( element ).eq( 0 );\n\t\t}\n\n\t\tif ( !element || !element[ 0 ] ) {\n\t\t\telement = this.element.closest( ".ui-front" );\n\t\t}\n\n\t\tif ( !element.length ) {\n\t\t\telement = this.document[ 0 ].body;\n\t\t}\n\n\t\treturn element;\n\t},\n\n\t_initSource: function() {\n\t\tvar array, url,\n\t\t\tthat = this;\n\t\tif ( $.isArray( this.options.source ) ) {\n\t\t\tarray = this.options.source;\n\t\t\tthis.source = function( request, response ) {\n\t\t\t\tresponse( $.ui.autocomplete.filter( array, request.term ) );\n\t\t\t};\n\t\t} else if ( typeof this.options.source === "string" ) {\n\t\t\turl = this.options.source;\n\t\t\tthis.source = function( request, response ) {\n\t\t\t\tif ( that.xhr ) {\n\t\t\t\t\tthat.xhr.abort();\n\t\t\t\t}\n\t\t\t\tthat.xhr = $.ajax({\n\t\t\t\t\turl: url,\n\t\t\t\t\tdata: request,\n\t\t\t\t\tdataType: "json",\n\t\t\t\t\tsuccess: function( data ) {\n\t\t\t\t\t\tresponse( data );\n\t\t\t\t\t},\n\t\t\t\t\terror: function() {\n\t\t\t\t\t\tresponse([]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t} else {\n\t\t\tthis.source = this.options.source;\n\t\t}\n\t},\n\n\t_searchTimeout: function( event ) {\n\t\tclearTimeout( this.searching );\n\t\tthis.searching = this._delay(function() {\n\n\t\t\t// Search if the value has changed, or if the user retypes the same value (see #7434)\n\t\t\tvar equalValues = this.term === this._value(),\n\t\t\t\tmenuVisible = this.menu.element.is( ":visible" ),\n\t\t\t\tmodifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n\n\t\t\tif ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {\n\t\t\t\tthis.selectedItem = null;\n\t\t\t\tthis.search( null, event );\n\t\t\t}\n\t\t}, this.options.delay );\n\t},\n\n\tsearch: function( value, event ) {\n\t\tvalue = value != null ? value : this._value();\n\n\t\t// always save the actual value, not the one passed as an argument\n\t\tthis.term = this._value();\n\n\t\tif ( value.length < this.options.minLength ) {\n\t\t\treturn this.close( event );\n\t\t}\n\n\t\tif ( this._trigger( "search", event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._search( value );\n\t},\n\n\t_search: function( value ) {\n\t\tthis.pending++;\n\t\tthis.element.addClass( "ui-autocomplete-loading" );\n\t\tthis.cancelSearch = false;\n\n\t\tthis.source( { term: value }, this._response() );\n\t},\n\n\t_response: function() {\n\t\tvar index = ++this.requestIndex;\n\n\t\treturn $.proxy(function( content ) {\n\t\t\tif ( index === this.requestIndex ) {\n\t\t\t\tthis.__response( content );\n\t\t\t}\n\n\t\t\tthis.pending--;\n\t\t\tif ( !this.pending ) {\n\t\t\t\tthis.element.removeClass( "ui-autocomplete-loading" );\n\t\t\t}\n\t\t}, this );\n\t},\n\n\t__response: function( content ) {\n\t\tif ( content ) {\n\t\t\tcontent = this._normalize( content );\n\t\t}\n\t\tthis._trigger( "response", null, { content: content } );\n\t\tif ( !this.options.disabled && content && content.length && !this.cancelSearch ) {\n\t\t\tthis._suggest( content );\n\t\t\tthis._trigger( "open" );\n\t\t} else {\n\t\t\t// use ._close() instead of .close() so we don\'t cancel future searches\n\t\t\tthis._close();\n\t\t}\n\t},\n\n\tclose: function( event ) {\n\t\tthis.cancelSearch = true;\n\t\tthis._close( event );\n\t},\n\n\t_close: function( event ) {\n\t\tif ( this.menu.element.is( ":visible" ) ) {\n\t\t\tthis.menu.element.hide();\n\t\t\tthis.menu.blur();\n\t\t\tthis.isNewMenu = true;\n\t\t\tthis._trigger( "close", event );\n\t\t}\n\t},\n\n\t_change: function( event ) {\n\t\tif ( this.previous !== this._value() ) {\n\t\t\tthis._trigger( "change", event, { item: this.selectedItem } );\n\t\t}\n\t},\n\n\t_normalize: function( items ) {\n\t\t// assume all items have the right format when the first item is complete\n\t\tif ( items.length && items[ 0 ].label && items[ 0 ].value ) {\n\t\t\treturn items;\n\t\t}\n\t\treturn $.map( items, function( item ) {\n\t\t\tif ( typeof item === "string" ) {\n\t\t\t\treturn {\n\t\t\t\t\tlabel: item,\n\t\t\t\t\tvalue: item\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn $.extend( {}, item, {\n\t\t\t\tlabel: item.label || item.value,\n\t\t\t\tvalue: item.value || item.label\n\t\t\t});\n\t\t});\n\t},\n\n\t_suggest: function( items ) {\n\t\tvar ul = this.menu.element.empty();\n\t\tthis._renderMenu( ul, items );\n\t\tthis.isNewMenu = true;\n\t\tthis.menu.refresh();\n\n\t\t// size and position menu\n\t\tul.show();\n\t\tthis._resizeMenu();\n\t\tul.position( $.extend({\n\t\t\tof: this.element\n\t\t}, this.options.position ) );\n\n\t\tif ( this.options.autoFocus ) {\n\t\t\tthis.menu.next();\n\t\t}\n\t},\n\n\t_resizeMenu: function() {\n\t\tvar ul = this.menu.element;\n\t\tul.outerWidth( Math.max(\n\t\t\t// Firefox wraps long text (possibly a rounding bug)\n\t\t\t// so we add 1px to avoid the wrapping (#7513)\n\t\t\tul.width( "" ).outerWidth() + 1,\n\t\t\tthis.element.outerWidth()\n\t\t) );\n\t},\n\n\t_renderMenu: function( ul, items ) {\n\t\tvar that = this;\n\t\t$.each( items, function( index, item ) {\n\t\t\tthat._renderItemData( ul, item );\n\t\t});\n\t},\n\n\t_renderItemData: function( ul, item ) {\n\t\treturn this._renderItem( ul, item ).data( "ui-autocomplete-item", item );\n\t},\n\n\t_renderItem: function( ul, item ) {\n\t\treturn $( "<li>" ).text( item.label ).appendTo( ul );\n\t},\n\n\t_move: function( direction, event ) {\n\t\tif ( !this.menu.element.is( ":visible" ) ) {\n\t\t\tthis.search( null, event );\n\t\t\treturn;\n\t\t}\n\t\tif ( this.menu.isFirstItem() && /^previous/.test( direction ) ||\n\t\t\t\tthis.menu.isLastItem() && /^next/.test( direction ) ) {\n\n\t\t\tif ( !this.isMultiLine ) {\n\t\t\t\tthis._value( this.term );\n\t\t\t}\n\n\t\t\tthis.menu.blur();\n\t\t\treturn;\n\t\t}\n\t\tthis.menu[ direction ]( event );\n\t},\n\n\twidget: function() {\n\t\treturn this.menu.element;\n\t},\n\n\t_value: function() {\n\t\treturn this.valueMethod.apply( this.element, arguments );\n\t},\n\n\t_keyEvent: function( keyEvent, event ) {\n\t\tif ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {\n\t\t\tthis._move( keyEvent, event );\n\n\t\t\t// prevents moving cursor to beginning/end of the text field in some browsers\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n});\n\n$.extend( $.ui.autocomplete, {\n\tescapeRegex: function( value ) {\n\t\treturn value.replace( /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, "\\\\$&" );\n\t},\n\tfilter: function( array, term ) {\n\t\tvar matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );\n\t\treturn $.grep( array, function( value ) {\n\t\t\treturn matcher.test( value.label || value.value || value );\n\t\t});\n\t}\n});\n\n// live region extension, adding a `messages` option\n// NOTE: This is an experimental API. We are still investigating\n// a full solution for string manipulation and internationalization.\n$.widget( "ui.autocomplete", $.ui.autocomplete, {\n\toptions: {\n\t\tmessages: {\n\t\t\tnoResults: "No search results.",\n\t\t\tresults: function( amount ) {\n\t\t\t\treturn amount + ( amount > 1 ? " results are" : " result is" ) +\n\t\t\t\t\t" available, use up and down arrow keys to navigate.";\n\t\t\t}\n\t\t}\n\t},\n\n\t__response: function( content ) {\n\t\tvar message;\n\t\tthis._superApply( arguments );\n\t\tif ( this.options.disabled || this.cancelSearch ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( content && content.length ) {\n\t\t\tmessage = this.options.messages.results( content.length );\n\t\t} else {\n\t\t\tmessage = this.options.messages.noResults;\n\t\t}\n\t\tthis.liveRegion.children().hide();\n\t\t$( "<div>" ).text( message ).appendTo( this.liveRegion );\n\t}\n});\n\nvar autocomplete = $.ui.autocomplete;\n\n\n/*!\n * jQuery UI Button 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/button/\n */\n\n\nvar lastActive,\n\tbaseClasses = "ui-button ui-widget ui-state-default ui-corner-all",\n\ttypeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",\n\tformResetHandler = function() {\n\t\tvar form = $( this );\n\t\tsetTimeout(function() {\n\t\t\tform.find( ":ui-button" ).button( "refresh" );\n\t\t}, 1 );\n\t},\n\tradioGroup = function( radio ) {\n\t\tvar name = radio.name,\n\t\t\tform = radio.form,\n\t\t\tradios = $( [] );\n\t\tif ( name ) {\n\t\t\tname = name.replace( /\'/g, "\\\\\'" );\n\t\t\tif ( form ) {\n\t\t\t\tradios = $( form ).find( "[name=\'" + name + "\'][type=radio]" );\n\t\t\t} else {\n\t\t\t\tradios = $( "[name=\'" + name + "\'][type=radio]", radio.ownerDocument )\n\t\t\t\t\t.filter(function() {\n\t\t\t\t\t\treturn !this.form;\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn radios;\n\t};\n\n$.widget( "ui.button", {\n\tversion: "1.11.4",\n\tdefaultElement: "<button>",\n\toptions: {\n\t\tdisabled: null,\n\t\ttext: true,\n\t\tlabel: null,\n\t\ticons: {\n\t\t\tprimary: null,\n\t\t\tsecondary: null\n\t\t}\n\t},\n\t_create: function() {\n\t\tthis.element.closest( "form" )\n\t\t\t.unbind( "reset" + this.eventNamespace )\n\t\t\t.bind( "reset" + this.eventNamespace, formResetHandler );\n\n\t\tif ( typeof this.options.disabled !== "boolean" ) {\n\t\t\tthis.options.disabled = !!this.element.prop( "disabled" );\n\t\t} else {\n\t\t\tthis.element.prop( "disabled", this.options.disabled );\n\t\t}\n\n\t\tthis._determineButtonType();\n\t\tthis.hasTitle = !!this.buttonElement.attr( "title" );\n\n\t\tvar that = this,\n\t\t\toptions = this.options,\n\t\t\ttoggleButton = this.type === "checkbox" || this.type === "radio",\n\t\t\tactiveClass = !toggleButton ? "ui-state-active" : "";\n\n\t\tif ( options.label === null ) {\n\t\t\toptions.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());\n\t\t}\n\n\t\tthis._hoverable( this.buttonElement );\n\n\t\tthis.buttonElement\n\t\t\t.addClass( baseClasses )\n\t\t\t.attr( "role", "button" )\n\t\t\t.bind( "mouseenter" + this.eventNamespace, function() {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( this === lastActive ) {\n\t\t\t\t\t$( this ).addClass( "ui-state-active" );\n\t\t\t\t}\n\t\t\t})\n\t\t\t.bind( "mouseleave" + this.eventNamespace, function() {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$( this ).removeClass( activeClass );\n\t\t\t})\n\t\t\t.bind( "click" + this.eventNamespace, function( event ) {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t}\n\t\t\t});\n\n\t\t// Can\'t use _focusable() because the element that receives focus\n\t\t// and the element that gets the ui-state-focus class are different\n\t\tthis._on({\n\t\t\tfocus: function() {\n\t\t\t\tthis.buttonElement.addClass( "ui-state-focus" );\n\t\t\t},\n\t\t\tblur: function() {\n\t\t\t\tthis.buttonElement.removeClass( "ui-state-focus" );\n\t\t\t}\n\t\t});\n\n\t\tif ( toggleButton ) {\n\t\t\tthis.element.bind( "change" + this.eventNamespace, function() {\n\t\t\t\tthat.refresh();\n\t\t\t});\n\t\t}\n\n\t\tif ( this.type === "checkbox" ) {\n\t\t\tthis.buttonElement.bind( "click" + this.eventNamespace, function() {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t} else if ( this.type === "radio" ) {\n\t\t\tthis.buttonElement.bind( "click" + this.eventNamespace, function() {\n\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t$( this ).addClass( "ui-state-active" );\n\t\t\t\tthat.buttonElement.attr( "aria-pressed", "true" );\n\n\t\t\t\tvar radio = that.element[ 0 ];\n\t\t\t\tradioGroup( radio )\n\t\t\t\t\t.not( radio )\n\t\t\t\t\t.map(function() {\n\t\t\t\t\t\treturn $( this ).button( "widget" )[ 0 ];\n\t\t\t\t\t})\n\t\t\t\t\t.removeClass( "ui-state-active" )\n\t\t\t\t\t.attr( "aria-pressed", "false" );\n\t\t\t});\n\t\t} else {\n\t\t\tthis.buttonElement\n\t\t\t\t.bind( "mousedown" + this.eventNamespace, function() {\n\t\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$( this ).addClass( "ui-state-active" );\n\t\t\t\t\tlastActive = this;\n\t\t\t\t\tthat.document.one( "mouseup", function() {\n\t\t\t\t\t\tlastActive = null;\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.bind( "mouseup" + this.eventNamespace, function() {\n\t\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$( this ).removeClass( "ui-state-active" );\n\t\t\t\t})\n\t\t\t\t.bind( "keydown" + this.eventNamespace, function(event) {\n\t\t\t\t\tif ( options.disabled ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {\n\t\t\t\t\t\t$( this ).addClass( "ui-state-active" );\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t// see #8559, we bind to blur here in case the button element loses\n\t\t\t\t// focus between keydown and keyup, it would be left in an "active" state\n\t\t\t\t.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {\n\t\t\t\t\t$( this ).removeClass( "ui-state-active" );\n\t\t\t\t});\n\n\t\t\tif ( this.buttonElement.is("a") ) {\n\t\t\t\tthis.buttonElement.keyup(function(event) {\n\t\t\t\t\tif ( event.keyCode === $.ui.keyCode.SPACE ) {\n\t\t\t\t\t\t// TODO pass through original event correctly (just as 2nd argument doesn\'t work)\n\t\t\t\t\t\t$( this ).click();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis._setOption( "disabled", options.disabled );\n\t\tthis._resetButton();\n\t},\n\n\t_determineButtonType: function() {\n\t\tvar ancestor, labelSelector, checked;\n\n\t\tif ( this.element.is("[type=checkbox]") ) {\n\t\t\tthis.type = "checkbox";\n\t\t} else if ( this.element.is("[type=radio]") ) {\n\t\t\tthis.type = "radio";\n\t\t} else if ( this.element.is("input") ) {\n\t\t\tthis.type = "input";\n\t\t} else {\n\t\t\tthis.type = "button";\n\t\t}\n\n\t\tif ( this.type === "checkbox" || this.type === "radio" ) {\n\t\t\t// we don\'t search against the document in case the element\n\t\t\t// is disconnected from the DOM\n\t\t\tancestor = this.element.parents().last();\n\t\t\tlabelSelector = "label[for=\'" + this.element.attr("id") + "\']";\n\t\t\tthis.buttonElement = ancestor.find( labelSelector );\n\t\t\tif ( !this.buttonElement.length ) {\n\t\t\t\tancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();\n\t\t\t\tthis.buttonElement = ancestor.filter( labelSelector );\n\t\t\t\tif ( !this.buttonElement.length ) {\n\t\t\t\t\tthis.buttonElement = ancestor.find( labelSelector );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.element.addClass( "ui-helper-hidden-accessible" );\n\n\t\t\tchecked = this.element.is( ":checked" );\n\t\t\tif ( checked ) {\n\t\t\t\tthis.buttonElement.addClass( "ui-state-active" );\n\t\t\t}\n\t\t\tthis.buttonElement.prop( "aria-pressed", checked );\n\t\t} else {\n\t\t\tthis.buttonElement = this.element;\n\t\t}\n\t},\n\n\twidget: function() {\n\t\treturn this.buttonElement;\n\t},\n\n\t_destroy: function() {\n\t\tthis.element\n\t\t\t.removeClass( "ui-helper-hidden-accessible" );\n\t\tthis.buttonElement\n\t\t\t.removeClass( baseClasses + " ui-state-active " + typeClasses )\n\t\t\t.removeAttr( "role" )\n\t\t\t.removeAttr( "aria-pressed" )\n\t\t\t.html( this.buttonElement.find(".ui-button-text").html() );\n\n\t\tif ( !this.hasTitle ) {\n\t\t\tthis.buttonElement.removeAttr( "title" );\n\t\t}\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tthis._super( key, value );\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.widget().toggleClass( "ui-state-disabled", !!value );\n\t\t\tthis.element.prop( "disabled", !!value );\n\t\t\tif ( value ) {\n\t\t\t\tif ( this.type === "checkbox" || this.type === "radio" ) {\n\t\t\t\t\tthis.buttonElement.removeClass( "ui-state-focus" );\n\t\t\t\t} else {\n\t\t\t\t\tthis.buttonElement.removeClass( "ui-state-focus ui-state-active" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._resetButton();\n\t},\n\n\trefresh: function() {\n\t\t//See #8237 & #8828\n\t\tvar isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );\n\n\t\tif ( isDisabled !== this.options.disabled ) {\n\t\t\tthis._setOption( "disabled", isDisabled );\n\t\t}\n\t\tif ( this.type === "radio" ) {\n\t\t\tradioGroup( this.element[0] ).each(function() {\n\t\t\t\tif ( $( this ).is( ":checked" ) ) {\n\t\t\t\t\t$( this ).button( "widget" )\n\t\t\t\t\t\t.addClass( "ui-state-active" )\n\t\t\t\t\t\t.attr( "aria-pressed", "true" );\n\t\t\t\t} else {\n\t\t\t\t\t$( this ).button( "widget" )\n\t\t\t\t\t\t.removeClass( "ui-state-active" )\n\t\t\t\t\t\t.attr( "aria-pressed", "false" );\n\t\t\t\t}\n\t\t\t});\n\t\t} else if ( this.type === "checkbox" ) {\n\t\t\tif ( this.element.is( ":checked" ) ) {\n\t\t\t\tthis.buttonElement\n\t\t\t\t\t.addClass( "ui-state-active" )\n\t\t\t\t\t.attr( "aria-pressed", "true" );\n\t\t\t} else {\n\t\t\t\tthis.buttonElement\n\t\t\t\t\t.removeClass( "ui-state-active" )\n\t\t\t\t\t.attr( "aria-pressed", "false" );\n\t\t\t}\n\t\t}\n\t},\n\n\t_resetButton: function() {\n\t\tif ( this.type === "input" ) {\n\t\t\tif ( this.options.label ) {\n\t\t\t\tthis.element.val( this.options.label );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tvar buttonElement = this.buttonElement.removeClass( typeClasses ),\n\t\t\tbuttonText = $( "<span></span>", this.document[0] )\n\t\t\t\t.addClass( "ui-button-text" )\n\t\t\t\t.html( this.options.label )\n\t\t\t\t.appendTo( buttonElement.empty() )\n\t\t\t\t.text(),\n\t\t\ticons = this.options.icons,\n\t\t\tmultipleIcons = icons.primary && icons.secondary,\n\t\t\tbuttonClasses = [];\n\n\t\tif ( icons.primary || icons.secondary ) {\n\t\t\tif ( this.options.text ) {\n\t\t\t\tbuttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );\n\t\t\t}\n\n\t\t\tif ( icons.primary ) {\n\t\t\t\tbuttonElement.prepend( "<span class=\'ui-button-icon-primary ui-icon " + icons.primary + "\'></span>" );\n\t\t\t}\n\n\t\t\tif ( icons.secondary ) {\n\t\t\t\tbuttonElement.append( "<span class=\'ui-button-icon-secondary ui-icon " + icons.secondary + "\'></span>" );\n\t\t\t}\n\n\t\t\tif ( !this.options.text ) {\n\t\t\t\tbuttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );\n\n\t\t\t\tif ( !this.hasTitle ) {\n\t\t\t\t\tbuttonElement.attr( "title", $.trim( buttonText ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbuttonClasses.push( "ui-button-text-only" );\n\t\t}\n\t\tbuttonElement.addClass( buttonClasses.join( " " ) );\n\t}\n});\n\n$.widget( "ui.buttonset", {\n\tversion: "1.11.4",\n\toptions: {\n\t\titems: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"\n\t},\n\n\t_create: function() {\n\t\tthis.element.addClass( "ui-buttonset" );\n\t},\n\n\t_init: function() {\n\t\tthis.refresh();\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.buttons.button( "option", key, value );\n\t\t}\n\n\t\tthis._super( key, value );\n\t},\n\n\trefresh: function() {\n\t\tvar rtl = this.element.css( "direction" ) === "rtl",\n\t\t\tallButtons = this.element.find( this.options.items ),\n\t\t\texistingButtons = allButtons.filter( ":ui-button" );\n\n\t\t// Initialize new buttons\n\t\tallButtons.not( ":ui-button" ).button();\n\n\t\t// Refresh existing buttons\n\t\texistingButtons.button( "refresh" );\n\n\t\tthis.buttons = allButtons\n\t\t\t.map(function() {\n\t\t\t\treturn $( this ).button( "widget" )[ 0 ];\n\t\t\t})\n\t\t\t\t.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )\n\t\t\t\t.filter( ":first" )\n\t\t\t\t\t.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )\n\t\t\t\t.end()\n\t\t\t\t.filter( ":last" )\n\t\t\t\t\t.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )\n\t\t\t\t.end()\n\t\t\t.end();\n\t},\n\n\t_destroy: function() {\n\t\tthis.element.removeClass( "ui-buttonset" );\n\t\tthis.buttons\n\t\t\t.map(function() {\n\t\t\t\treturn $( this ).button( "widget" )[ 0 ];\n\t\t\t})\n\t\t\t\t.removeClass( "ui-corner-left ui-corner-right" )\n\t\t\t.end()\n\t\t\t.button( "destroy" );\n\t}\n});\n\nvar button = $.ui.button;\n\n\n/*!\n * jQuery UI Datepicker 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/datepicker/\n */\n\n\n$.extend($.ui, { datepicker: { version: "1.11.4" } });\n\nvar datepicker_instActive;\n\nfunction datepicker_getZindex( elem ) {\n\tvar position, value;\n\twhile ( elem.length && elem[ 0 ] !== document ) {\n\t\t// Ignore z-index if position is set to a value where z-index is ignored by the browser\n\t\t// This makes behavior of this function consistent across browsers\n\t\t// WebKit always returns auto if the element is positioned\n\t\tposition = elem.css( "position" );\n\t\tif ( position === "absolute" || position === "relative" || position === "fixed" ) {\n\t\t\t// IE returns 0 when zIndex is not specified\n\t\t\t// other browsers return a string\n\t\t\t// we ignore the case of nested elements with an explicit value of 0\n\t\t\t// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>\n\t\t\tvalue = parseInt( elem.css( "zIndex" ), 10 );\n\t\t\tif ( !isNaN( value ) && value !== 0 ) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\telem = elem.parent();\n\t}\n\n\treturn 0;\n}\n/* Date picker manager.\n   Use the singleton instance of this class, $.datepicker, to interact with the date picker.\n   Settings for (groups of) date pickers are maintained in an instance object,\n   allowing multiple different settings on the same page. */\n\nfunction Datepicker() {\n\tthis._curInst = null; // The current instance in use\n\tthis._keyEvent = false; // If the last event was a key event\n\tthis._disabledInputs = []; // List of date picker inputs that have been disabled\n\tthis._datepickerShowing = false; // True if the popup picker is showing , false if not\n\tthis._inDialog = false; // True if showing within a "dialog", false if not\n\tthis._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division\n\tthis._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class\n\tthis._appendClass = "ui-datepicker-append"; // The name of the append marker class\n\tthis._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class\n\tthis._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class\n\tthis._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class\n\tthis._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class\n\tthis._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class\n\tthis._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class\n\tthis.regional = []; // Available regional settings, indexed by language code\n\tthis.regional[""] = { // Default regional settings\n\t\tcloseText: "Done", // Display text for close link\n\t\tprevText: "Prev", // Display text for previous month link\n\t\tnextText: "Next", // Display text for next month link\n\t\tcurrentText: "Today", // Display text for current month link\n\t\tmonthNames: ["January","February","March","April","May","June",\n\t\t\t"July","August","September","October","November","December"], // Names of months for drop-down and formatting\n\t\tmonthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting\n\t\tdayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting\n\t\tdayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting\n\t\tdayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday\n\t\tweekHeader: "Wk", // Column header for week of the year\n\t\tdateFormat: "mm/dd/yy", // See format options on parseDate\n\t\tfirstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...\n\t\tisRTL: false, // True if right-to-left language, false if left-to-right\n\t\tshowMonthAfterYear: false, // True if the year select precedes month, false for month then year\n\t\tyearSuffix: "" // Additional text to append to the year in the month headers\n\t};\n\tthis._defaults = { // Global defaults for all the date picker instances\n\t\tshowOn: "focus", // "focus" for popup on focus,\n\t\t\t// "button" for trigger button, or "both" for either\n\t\tshowAnim: "fadeIn", // Name of jQuery animation for popup\n\t\tshowOptions: {}, // Options for enhanced animations\n\t\tdefaultDate: null, // Used when field is blank: actual date,\n\t\t\t// +/-number for offset from today, null for today\n\t\tappendText: "", // Display text following the input box, e.g. showing the format\n\t\tbuttonText: "...", // Text for trigger button\n\t\tbuttonImage: "", // URL for trigger button image\n\t\tbuttonImageOnly: false, // True if the image appears alone, false if it appears on a button\n\t\thideIfNoPrevNext: false, // True to hide next/previous month links\n\t\t\t// if not applicable, false to just disable them\n\t\tnavigationAsDateFormat: false, // True if date formatting applied to prev/today/next links\n\t\tgotoCurrent: false, // True if today link goes back to current selection instead\n\t\tchangeMonth: false, // True if month can be selected directly, false if only prev/next\n\t\tchangeYear: false, // True if year can be selected directly, false if only prev/next\n\t\tyearRange: "c-10:c+10", // Range of years to display in drop-down,\n\t\t\t// either relative to today\'s year (-nn:+nn), relative to currently displayed year\n\t\t\t// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)\n\t\tshowOtherMonths: false, // True to show dates in other months, false to leave blank\n\t\tselectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable\n\t\tshowWeek: false, // True to show week of the year, false to not show it\n\t\tcalculateWeek: this.iso8601Week, // How to calculate the week of the year,\n\t\t\t// takes a Date and returns the number of the week for it\n\t\tshortYearCutoff: "+10", // Short year values < this are in the current century,\n\t\t\t// > this are in the previous century,\n\t\t\t// string value starting with "+" for current year + value\n\t\tminDate: null, // The earliest selectable date, or null for no limit\n\t\tmaxDate: null, // The latest selectable date, or null for no limit\n\t\tduration: "fast", // Duration of display/closure\n\t\tbeforeShowDay: null, // Function that takes a date and returns an array with\n\t\t\t// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",\n\t\t\t// [2] = cell title (optional), e.g. $.datepicker.noWeekends\n\t\tbeforeShow: null, // Function that takes an input field and\n\t\t\t// returns a set of custom settings for the date picker\n\t\tonSelect: null, // Define a callback function when a date is selected\n\t\tonChangeMonthYear: null, // Define a callback function when the month or year is changed\n\t\tonClose: null, // Define a callback function when the datepicker is closed\n\t\tnumberOfMonths: 1, // Number of months to show at a time\n\t\tshowCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)\n\t\tstepMonths: 1, // Number of months to step back/forward\n\t\tstepBigMonths: 12, // Number of months to step back/forward for the big links\n\t\taltField: "", // Selector for an alternate field to store selected dates into\n\t\taltFormat: "", // The date format to use for the alternate field\n\t\tconstrainInput: true, // The input is constrained by the current date format\n\t\tshowButtonPanel: false, // True to show button panel, false to not show it\n\t\tautoSize: false, // True to size the input for the date format, false to leave as is\n\t\tdisabled: false // The initial disabled state\n\t};\n\t$.extend(this._defaults, this.regional[""]);\n\tthis.regional.en = $.extend( true, {}, this.regional[ "" ]);\n\tthis.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );\n\tthis.dpDiv = datepicker_bindHover($("<div id=\'" + this._mainDivId + "\' class=\'ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>"));\n}\n\n$.extend(Datepicker.prototype, {\n\t/* Class name added to elements to indicate already configured with a date picker. */\n\tmarkerClassName: "hasDatepicker",\n\n\t//Keep track of the maximum number of rows displayed (see #7043)\n\tmaxRows: 4,\n\n\t// TODO rename to "widget" when switching to widget factory\n\t_widgetDatepicker: function() {\n\t\treturn this.dpDiv;\n\t},\n\n\t/* Override the default settings for all instances of the date picker.\n\t * @param  settings  object - the new settings to use as defaults (anonymous object)\n\t * @return the manager object\n\t */\n\tsetDefaults: function(settings) {\n\t\tdatepicker_extendRemove(this._defaults, settings || {});\n\t\treturn this;\n\t},\n\n\t/* Attach the date picker to a jQuery selection.\n\t * @param  target\telement - the target input field or division or span\n\t * @param  settings  object - the new settings to use for this date picker instance (anonymous)\n\t */\n\t_attachDatepicker: function(target, settings) {\n\t\tvar nodeName, inline, inst;\n\t\tnodeName = target.nodeName.toLowerCase();\n\t\tinline = (nodeName === "div" || nodeName === "span");\n\t\tif (!target.id) {\n\t\t\tthis.uuid += 1;\n\t\t\ttarget.id = "dp" + this.uuid;\n\t\t}\n\t\tinst = this._newInst($(target), inline);\n\t\tinst.settings = $.extend({}, settings || {});\n\t\tif (nodeName === "input") {\n\t\t\tthis._connectDatepicker(target, inst);\n\t\t} else if (inline) {\n\t\t\tthis._inlineDatepicker(target, inst);\n\t\t}\n\t},\n\n\t/* Create a new instance object. */\n\t_newInst: function(target, inline) {\n\t\tvar id = target[0].id.replace(/([^A-Za-z0-9_\\-])/g, "\\\\\\\\$1"); // escape jQuery meta chars\n\t\treturn {id: id, input: target, // associated target\n\t\t\tselectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection\n\t\t\tdrawMonth: 0, drawYear: 0, // month being drawn\n\t\t\tinline: inline, // is datepicker inline or not\n\t\t\tdpDiv: (!inline ? this.dpDiv : // presentation div\n\t\t\tdatepicker_bindHover($("<div class=\'" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>")))};\n\t},\n\n\t/* Attach the date picker to an input field. */\n\t_connectDatepicker: function(target, inst) {\n\t\tvar input = $(target);\n\t\tinst.append = $([]);\n\t\tinst.trigger = $([]);\n\t\tif (input.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._attachments(input, inst);\n\t\tinput.addClass(this.markerClassName).keydown(this._doKeyDown).\n\t\t\tkeypress(this._doKeyPress).keyup(this._doKeyUp);\n\t\tthis._autoSize(inst);\n\t\t$.data(target, "datepicker", inst);\n\t\t//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)\n\t\tif( inst.settings.disabled ) {\n\t\t\tthis._disableDatepicker( target );\n\t\t}\n\t},\n\n\t/* Make attachments based on settings. */\n\t_attachments: function(input, inst) {\n\t\tvar showOn, buttonText, buttonImage,\n\t\t\tappendText = this._get(inst, "appendText"),\n\t\t\tisRTL = this._get(inst, "isRTL");\n\n\t\tif (inst.append) {\n\t\t\tinst.append.remove();\n\t\t}\n\t\tif (appendText) {\n\t\t\tinst.append = $("<span class=\'" + this._appendClass + "\'>" + appendText + "</span>");\n\t\t\tinput[isRTL ? "before" : "after"](inst.append);\n\t\t}\n\n\t\tinput.unbind("focus", this._showDatepicker);\n\n\t\tif (inst.trigger) {\n\t\t\tinst.trigger.remove();\n\t\t}\n\n\t\tshowOn = this._get(inst, "showOn");\n\t\tif (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field\n\t\t\tinput.focus(this._showDatepicker);\n\t\t}\n\t\tif (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked\n\t\t\tbuttonText = this._get(inst, "buttonText");\n\t\t\tbuttonImage = this._get(inst, "buttonImage");\n\t\t\tinst.trigger = $(this._get(inst, "buttonImageOnly") ?\n\t\t\t\t$("<img/>").addClass(this._triggerClass).\n\t\t\t\t\tattr({ src: buttonImage, alt: buttonText, title: buttonText }) :\n\t\t\t\t$("<button type=\'button\'></button>").addClass(this._triggerClass).\n\t\t\t\t\thtml(!buttonImage ? buttonText : $("<img/>").attr(\n\t\t\t\t\t{ src:buttonImage, alt:buttonText, title:buttonText })));\n\t\t\tinput[isRTL ? "before" : "after"](inst.trigger);\n\t\t\tinst.trigger.click(function() {\n\t\t\t\tif ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {\n\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {\n\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t$.datepicker._showDatepicker(input[0]);\n\t\t\t\t} else {\n\t\t\t\t\t$.datepicker._showDatepicker(input[0]);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\t},\n\n\t/* Apply the maximum length for the date format. */\n\t_autoSize: function(inst) {\n\t\tif (this._get(inst, "autoSize") && !inst.inline) {\n\t\t\tvar findMax, max, maxI, i,\n\t\t\t\tdate = new Date(2009, 12 - 1, 20), // Ensure double digits\n\t\t\t\tdateFormat = this._get(inst, "dateFormat");\n\n\t\t\tif (dateFormat.match(/[DM]/)) {\n\t\t\t\tfindMax = function(names) {\n\t\t\t\t\tmax = 0;\n\t\t\t\t\tmaxI = 0;\n\t\t\t\t\tfor (i = 0; i < names.length; i++) {\n\t\t\t\t\t\tif (names[i].length > max) {\n\t\t\t\t\t\t\tmax = names[i].length;\n\t\t\t\t\t\t\tmaxI = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn maxI;\n\t\t\t\t};\n\t\t\t\tdate.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?\n\t\t\t\t\t"monthNames" : "monthNamesShort"))));\n\t\t\t\tdate.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?\n\t\t\t\t\t"dayNames" : "dayNamesShort"))) + 20 - date.getDay());\n\t\t\t}\n\t\t\tinst.input.attr("size", this._formatDate(inst, date).length);\n\t\t}\n\t},\n\n\t/* Attach an inline date picker to a div. */\n\t_inlineDatepicker: function(target, inst) {\n\t\tvar divSpan = $(target);\n\t\tif (divSpan.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\t\tdivSpan.addClass(this.markerClassName).append(inst.dpDiv);\n\t\t$.data(target, "datepicker", inst);\n\t\tthis._setDate(inst, this._getDefaultDate(inst), true);\n\t\tthis._updateDatepicker(inst);\n\t\tthis._updateAlternate(inst);\n\t\t//If disabled option is true, disable the datepicker before showing it (see ticket #5665)\n\t\tif( inst.settings.disabled ) {\n\t\t\tthis._disableDatepicker( target );\n\t\t}\n\t\t// Set display:block in place of inst.dpDiv.show() which won\'t work on disconnected elements\n\t\t// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height\n\t\tinst.dpDiv.css( "display", "block" );\n\t},\n\n\t/* Pop-up the date picker in a "dialog" box.\n\t * @param  input element - ignored\n\t * @param  date\tstring or Date - the initial date to display\n\t * @param  onSelect  function - the function to call when a date is selected\n\t * @param  settings  object - update the dialog date picker instance\'s settings (anonymous object)\n\t * @param  pos int[2] - coordinates for the dialog\'s position within the screen or\n\t *\t\t\t\t\tevent - with x/y coordinates or\n\t *\t\t\t\t\tleave empty for default (screen centre)\n\t * @return the manager object\n\t */\n\t_dialogDatepicker: function(input, date, onSelect, settings, pos) {\n\t\tvar id, browserWidth, browserHeight, scrollX, scrollY,\n\t\t\tinst = this._dialogInst; // internal instance\n\n\t\tif (!inst) {\n\t\t\tthis.uuid += 1;\n\t\t\tid = "dp" + this.uuid;\n\t\t\tthis._dialogInput = $("<input type=\'text\' id=\'" + id +\n\t\t\t\t"\' style=\'position: absolute; top: -100px; width: 0px;\'/>");\n\t\t\tthis._dialogInput.keydown(this._doKeyDown);\n\t\t\t$("body").append(this._dialogInput);\n\t\t\tinst = this._dialogInst = this._newInst(this._dialogInput, false);\n\t\t\tinst.settings = {};\n\t\t\t$.data(this._dialogInput[0], "datepicker", inst);\n\t\t}\n\t\tdatepicker_extendRemove(inst.settings, settings || {});\n\t\tdate = (date && date.constructor === Date ? this._formatDate(inst, date) : date);\n\t\tthis._dialogInput.val(date);\n\n\t\tthis._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);\n\t\tif (!this._pos) {\n\t\t\tbrowserWidth = document.documentElement.clientWidth;\n\t\t\tbrowserHeight = document.documentElement.clientHeight;\n\t\t\tscrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n\t\t\tscrollY = document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\tthis._pos = // should use actual width/height below\n\t\t\t\t[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];\n\t\t}\n\n\t\t// move input on screen for focus, but hidden behind dialog\n\t\tthis._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");\n\t\tinst.settings.onSelect = onSelect;\n\t\tthis._inDialog = true;\n\t\tthis.dpDiv.addClass(this._dialogClass);\n\t\tthis._showDatepicker(this._dialogInput[0]);\n\t\tif ($.blockUI) {\n\t\t\t$.blockUI(this.dpDiv);\n\t\t}\n\t\t$.data(this._dialogInput[0], "datepicker", inst);\n\t\treturn this;\n\t},\n\n\t/* Detach a datepicker from its control.\n\t * @param  target\telement - the target input field or division or span\n\t */\n\t_destroyDatepicker: function(target) {\n\t\tvar nodeName,\n\t\t\t$target = $(target),\n\t\t\tinst = $.data(target, "datepicker");\n\n\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tnodeName = target.nodeName.toLowerCase();\n\t\t$.removeData(target, "datepicker");\n\t\tif (nodeName === "input") {\n\t\t\tinst.append.remove();\n\t\t\tinst.trigger.remove();\n\t\t\t$target.removeClass(this.markerClassName).\n\t\t\t\tunbind("focus", this._showDatepicker).\n\t\t\t\tunbind("keydown", this._doKeyDown).\n\t\t\t\tunbind("keypress", this._doKeyPress).\n\t\t\t\tunbind("keyup", this._doKeyUp);\n\t\t} else if (nodeName === "div" || nodeName === "span") {\n\t\t\t$target.removeClass(this.markerClassName).empty();\n\t\t}\n\n\t\tif ( datepicker_instActive === inst ) {\n\t\t\tdatepicker_instActive = null;\n\t\t}\n\t},\n\n\t/* Enable the date picker to a jQuery selection.\n\t * @param  target\telement - the target input field or division or span\n\t */\n\t_enableDatepicker: function(target) {\n\t\tvar nodeName, inline,\n\t\t\t$target = $(target),\n\t\t\tinst = $.data(target, "datepicker");\n\n\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tnodeName = target.nodeName.toLowerCase();\n\t\tif (nodeName === "input") {\n\t\t\ttarget.disabled = false;\n\t\t\tinst.trigger.filter("button").\n\t\t\t\teach(function() { this.disabled = false; }).end().\n\t\t\t\tfilter("img").css({opacity: "1.0", cursor: ""});\n\t\t} else if (nodeName === "div" || nodeName === "span") {\n\t\t\tinline = $target.children("." + this._inlineClass);\n\t\t\tinline.children().removeClass("ui-state-disabled");\n\t\t\tinline.find("select.ui-datepicker-month, select.ui-datepicker-year").\n\t\t\t\tprop("disabled", false);\n\t\t}\n\t\tthis._disabledInputs = $.map(this._disabledInputs,\n\t\t\tfunction(value) { return (value === target ? null : value); }); // delete entry\n\t},\n\n\t/* Disable the date picker to a jQuery selection.\n\t * @param  target\telement - the target input field or division or span\n\t */\n\t_disableDatepicker: function(target) {\n\t\tvar nodeName, inline,\n\t\t\t$target = $(target),\n\t\t\tinst = $.data(target, "datepicker");\n\n\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tnodeName = target.nodeName.toLowerCase();\n\t\tif (nodeName === "input") {\n\t\t\ttarget.disabled = true;\n\t\t\tinst.trigger.filter("button").\n\t\t\t\teach(function() { this.disabled = true; }).end().\n\t\t\t\tfilter("img").css({opacity: "0.5", cursor: "default"});\n\t\t} else if (nodeName === "div" || nodeName === "span") {\n\t\t\tinline = $target.children("." + this._inlineClass);\n\t\t\tinline.children().addClass("ui-state-disabled");\n\t\t\tinline.find("select.ui-datepicker-month, select.ui-datepicker-year").\n\t\t\t\tprop("disabled", true);\n\t\t}\n\t\tthis._disabledInputs = $.map(this._disabledInputs,\n\t\t\tfunction(value) { return (value === target ? null : value); }); // delete entry\n\t\tthis._disabledInputs[this._disabledInputs.length] = target;\n\t},\n\n\t/* Is the first field in a jQuery collection disabled as a datepicker?\n\t * @param  target\telement - the target input field or division or span\n\t * @return boolean - true if disabled, false if enabled\n\t */\n\t_isDisabledDatepicker: function(target) {\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this._disabledInputs.length; i++) {\n\t\t\tif (this._disabledInputs[i] === target) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t/* Retrieve the instance data for the target control.\n\t * @param  target  element - the target input field or division or span\n\t * @return  object - the associated instance data\n\t * @throws  error if a jQuery problem getting data\n\t */\n\t_getInst: function(target) {\n\t\ttry {\n\t\t\treturn $.data(target, "datepicker");\n\t\t}\n\t\tcatch (err) {\n\t\t\tthrow "Missing instance data for this datepicker";\n\t\t}\n\t},\n\n\t/* Update or retrieve the settings for a date picker attached to an input field or division.\n\t * @param  target  element - the target input field or division or span\n\t * @param  name\tobject - the new settings to update or\n\t *\t\t\t\tstring - the name of the setting to change or retrieve,\n\t *\t\t\t\twhen retrieving also "all" for all instance settings or\n\t *\t\t\t\t"defaults" for all global defaults\n\t * @param  value   any - the new value for the setting\n\t *\t\t\t\t(omit if above is an object or to retrieve a value)\n\t */\n\t_optionDatepicker: function(target, name, value) {\n\t\tvar settings, date, minDate, maxDate,\n\t\t\tinst = this._getInst(target);\n\n\t\tif (arguments.length === 2 && typeof name === "string") {\n\t\t\treturn (name === "defaults" ? $.extend({}, $.datepicker._defaults) :\n\t\t\t\t(inst ? (name === "all" ? $.extend({}, inst.settings) :\n\t\t\t\tthis._get(inst, name)) : null));\n\t\t}\n\n\t\tsettings = name || {};\n\t\tif (typeof name === "string") {\n\t\t\tsettings = {};\n\t\t\tsettings[name] = value;\n\t\t}\n\n\t\tif (inst) {\n\t\t\tif (this._curInst === inst) {\n\t\t\t\tthis._hideDatepicker();\n\t\t\t}\n\n\t\t\tdate = this._getDateDatepicker(target, true);\n\t\t\tminDate = this._getMinMaxDate(inst, "min");\n\t\t\tmaxDate = this._getMinMaxDate(inst, "max");\n\t\t\tdatepicker_extendRemove(inst.settings, settings);\n\t\t\t// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn\'t provided\n\t\t\tif (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {\n\t\t\t\tinst.settings.minDate = this._formatDate(inst, minDate);\n\t\t\t}\n\t\t\tif (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {\n\t\t\t\tinst.settings.maxDate = this._formatDate(inst, maxDate);\n\t\t\t}\n\t\t\tif ( "disabled" in settings ) {\n\t\t\t\tif ( settings.disabled ) {\n\t\t\t\t\tthis._disableDatepicker(target);\n\t\t\t\t} else {\n\t\t\t\t\tthis._enableDatepicker(target);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._attachments($(target), inst);\n\t\t\tthis._autoSize(inst);\n\t\t\tthis._setDate(inst, date);\n\t\t\tthis._updateAlternate(inst);\n\t\t\tthis._updateDatepicker(inst);\n\t\t}\n\t},\n\n\t// change method deprecated\n\t_changeDatepicker: function(target, name, value) {\n\t\tthis._optionDatepicker(target, name, value);\n\t},\n\n\t/* Redraw the date picker attached to an input field or division.\n\t * @param  target  element - the target input field or division or span\n\t */\n\t_refreshDatepicker: function(target) {\n\t\tvar inst = this._getInst(target);\n\t\tif (inst) {\n\t\t\tthis._updateDatepicker(inst);\n\t\t}\n\t},\n\n\t/* Set the dates for a jQuery selection.\n\t * @param  target element - the target input field or division or span\n\t * @param  date\tDate - the new date\n\t */\n\t_setDateDatepicker: function(target, date) {\n\t\tvar inst = this._getInst(target);\n\t\tif (inst) {\n\t\t\tthis._setDate(inst, date);\n\t\t\tthis._updateDatepicker(inst);\n\t\t\tthis._updateAlternate(inst);\n\t\t}\n\t},\n\n\t/* Get the date(s) for the first entry in a jQuery selection.\n\t * @param  target element - the target input field or division or span\n\t * @param  noDefault boolean - true if no default date is to be used\n\t * @return Date - the current date\n\t */\n\t_getDateDatepicker: function(target, noDefault) {\n\t\tvar inst = this._getInst(target);\n\t\tif (inst && !inst.inline) {\n\t\t\tthis._setDateFromField(inst, noDefault);\n\t\t}\n\t\treturn (inst ? this._getDate(inst) : null);\n\t},\n\n\t/* Handle keystrokes. */\n\t_doKeyDown: function(event) {\n\t\tvar onSelect, dateStr, sel,\n\t\t\tinst = $.datepicker._getInst(event.target),\n\t\t\thandled = true,\n\t\t\tisRTL = inst.dpDiv.is(".ui-datepicker-rtl");\n\n\t\tinst._keyEvent = true;\n\t\tif ($.datepicker._datepickerShowing) {\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase 9: $.datepicker._hideDatepicker();\n\t\t\t\t\t\thandled = false;\n\t\t\t\t\t\tbreak; // hide on tab out\n\t\t\t\tcase 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +\n\t\t\t\t\t\t\t\t\t$.datepicker._currentClass + ")", inst.dpDiv);\n\t\t\t\t\t\tif (sel[0]) {\n\t\t\t\t\t\t\t$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tonSelect = $.datepicker._get(inst, "onSelect");\n\t\t\t\t\t\tif (onSelect) {\n\t\t\t\t\t\t\tdateStr = $.datepicker._formatDate(inst);\n\n\t\t\t\t\t\t\t// trigger custom callback\n\t\t\t\t\t\t\tonSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false; // don\'t submit the form\n\t\t\t\tcase 27: $.datepicker._hideDatepicker();\n\t\t\t\t\t\tbreak; // hide on escape\n\t\t\t\tcase 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n\t\t\t\t\t\t\t-$.datepicker._get(inst, "stepBigMonths") :\n\t\t\t\t\t\t\t-$.datepicker._get(inst, "stepMonths")), "M");\n\t\t\t\t\t\tbreak; // previous month/year on page up/+ ctrl\n\t\t\t\tcase 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n\t\t\t\t\t\t\t+$.datepicker._get(inst, "stepBigMonths") :\n\t\t\t\t\t\t\t+$.datepicker._get(inst, "stepMonths")), "M");\n\t\t\t\t\t\tbreak; // next month/year on page down/+ ctrl\n\t\t\t\tcase 35: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._clearDate(event.target);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // clear on ctrl or command +end\n\t\t\t\tcase 36: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._gotoToday(event.target);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // current on ctrl or command +home\n\t\t\t\tcase 37: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\t// -1 day on ctrl or command +left\n\t\t\t\t\t\tif (event.originalEvent.altKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, (event.ctrlKey ?\n\t\t\t\t\t\t\t\t-$.datepicker._get(inst, "stepBigMonths") :\n\t\t\t\t\t\t\t\t-$.datepicker._get(inst, "stepMonths")), "M");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// next month/year on alt +left on Mac\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase 38: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, -7, "D");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // -1 week on ctrl or command +up\n\t\t\t\tcase 39: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\t// +1 day on ctrl or command +right\n\t\t\t\t\t\tif (event.originalEvent.altKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, (event.ctrlKey ?\n\t\t\t\t\t\t\t\t+$.datepicker._get(inst, "stepBigMonths") :\n\t\t\t\t\t\t\t\t+$.datepicker._get(inst, "stepMonths")), "M");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// next month/year on alt +right\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase 40: if (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, +7, "D");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // +1 week on ctrl or command +down\n\t\t\t\tdefault: handled = false;\n\t\t\t}\n\t\t} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home\n\t\t\t$.datepicker._showDatepicker(this);\n\t\t} else {\n\t\t\thandled = false;\n\t\t}\n\n\t\tif (handled) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t}\n\t},\n\n\t/* Filter entered characters - based on date format. */\n\t_doKeyPress: function(event) {\n\t\tvar chars, chr,\n\t\t\tinst = $.datepicker._getInst(event.target);\n\n\t\tif ($.datepicker._get(inst, "constrainInput")) {\n\t\t\tchars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));\n\t\t\tchr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);\n\t\t\treturn event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);\n\t\t}\n\t},\n\n\t/* Synchronise manual entry and field/alternate field. */\n\t_doKeyUp: function(event) {\n\t\tvar date,\n\t\t\tinst = $.datepicker._getInst(event.target);\n\n\t\tif (inst.input.val() !== inst.lastVal) {\n\t\t\ttry {\n\t\t\t\tdate = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),\n\t\t\t\t\t(inst.input ? inst.input.val() : null),\n\t\t\t\t\t$.datepicker._getFormatConfig(inst));\n\n\t\t\t\tif (date) { // only if valid\n\t\t\t\t\t$.datepicker._setDateFromField(inst);\n\t\t\t\t\t$.datepicker._updateAlternate(inst);\n\t\t\t\t\t$.datepicker._updateDatepicker(inst);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t/* Pop-up the date picker for a given input field.\n\t * If false returned from beforeShow event handler do not show.\n\t * @param  input  element - the input field attached to the date picker or\n\t *\t\t\t\t\tevent - if triggered by focus\n\t */\n\t_showDatepicker: function(input) {\n\t\tinput = input.target || input;\n\t\tif (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger\n\t\t\tinput = $("input", input.parentNode)[0];\n\t\t}\n\n\t\tif ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here\n\t\t\treturn;\n\t\t}\n\n\t\tvar inst, beforeShow, beforeShowSettings, isFixed,\n\t\t\toffset, showAnim, duration;\n\n\t\tinst = $.datepicker._getInst(input);\n\t\tif ($.datepicker._curInst && $.datepicker._curInst !== inst) {\n\t\t\t$.datepicker._curInst.dpDiv.stop(true, true);\n\t\t\tif ( inst && $.datepicker._datepickerShowing ) {\n\t\t\t\t$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );\n\t\t\t}\n\t\t}\n\n\t\tbeforeShow = $.datepicker._get(inst, "beforeShow");\n\t\tbeforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};\n\t\tif(beforeShowSettings === false){\n\t\t\treturn;\n\t\t}\n\t\tdatepicker_extendRemove(inst.settings, beforeShowSettings);\n\n\t\tinst.lastVal = null;\n\t\t$.datepicker._lastInput = input;\n\t\t$.datepicker._setDateFromField(inst);\n\n\t\tif ($.datepicker._inDialog) { // hide cursor\n\t\t\tinput.value = "";\n\t\t}\n\t\tif (!$.datepicker._pos) { // position below input\n\t\t\t$.datepicker._pos = $.datepicker._findPos(input);\n\t\t\t$.datepicker._pos[1] += input.offsetHeight; // add the height\n\t\t}\n\n\t\tisFixed = false;\n\t\t$(input).parents().each(function() {\n\t\t\tisFixed |= $(this).css("position") === "fixed";\n\t\t\treturn !isFixed;\n\t\t});\n\n\t\toffset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};\n\t\t$.datepicker._pos = null;\n\t\t//to avoid flashes on Firefox\n\t\tinst.dpDiv.empty();\n\t\t// determine sizing offscreen\n\t\tinst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});\n\t\t$.datepicker._updateDatepicker(inst);\n\t\t// fix width for dynamic number of date pickers\n\t\t// and adjust position before showing\n\t\toffset = $.datepicker._checkOffset(inst, offset, isFixed);\n\t\tinst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?\n\t\t\t"static" : (isFixed ? "fixed" : "absolute")), display: "none",\n\t\t\tleft: offset.left + "px", top: offset.top + "px"});\n\n\t\tif (!inst.inline) {\n\t\t\tshowAnim = $.datepicker._get(inst, "showAnim");\n\t\t\tduration = $.datepicker._get(inst, "duration");\n\t\t\tinst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );\n\t\t\t$.datepicker._datepickerShowing = true;\n\n\t\t\tif ( $.effects && $.effects.effect[ showAnim ] ) {\n\t\t\t\tinst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);\n\t\t\t} else {\n\t\t\t\tinst.dpDiv[showAnim || "show"](showAnim ? duration : null);\n\t\t\t}\n\n\t\t\tif ( $.datepicker._shouldFocusInput( inst ) ) {\n\t\t\t\tinst.input.focus();\n\t\t\t}\n\n\t\t\t$.datepicker._curInst = inst;\n\t\t}\n\t},\n\n\t/* Generate the date picker content. */\n\t_updateDatepicker: function(inst) {\n\t\tthis.maxRows = 4; //Reset the max number of rows being displayed (see #7043)\n\t\tdatepicker_instActive = inst; // for delegate hover events\n\t\tinst.dpDiv.empty().append(this._generateHTML(inst));\n\t\tthis._attachHandlers(inst);\n\n\t\tvar origyearshtml,\n\t\t\tnumMonths = this._getNumberOfMonths(inst),\n\t\t\tcols = numMonths[1],\n\t\t\twidth = 17,\n\t\t\tactiveCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );\n\n\t\tif ( activeCell.length > 0 ) {\n\t\t\tdatepicker_handleMouseover.apply( activeCell.get( 0 ) );\n\t\t}\n\n\t\tinst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");\n\t\tif (cols > 1) {\n\t\t\tinst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");\n\t\t}\n\t\tinst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +\n\t\t\t"Class"]("ui-datepicker-multi");\n\t\tinst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +\n\t\t\t"Class"]("ui-datepicker-rtl");\n\n\t\tif (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {\n\t\t\tinst.input.focus();\n\t\t}\n\n\t\t// deffered render of the years select (to avoid flashes on Firefox)\n\t\tif( inst.yearshtml ){\n\t\t\torigyearshtml = inst.yearshtml;\n\t\t\tsetTimeout(function(){\n\t\t\t\t//assure that inst.yearshtml didn\'t change.\n\t\t\t\tif( origyearshtml === inst.yearshtml && inst.yearshtml ){\n\t\t\t\t\tinst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);\n\t\t\t\t}\n\t\t\t\torigyearshtml = inst.yearshtml = null;\n\t\t\t}, 0);\n\t\t}\n\t},\n\n\t// #6694 - don\'t focus the input if it\'s already focused\n\t// this breaks the change event in IE\n\t// Support: IE and jQuery <1.9\n\t_shouldFocusInput: function( inst ) {\n\t\treturn inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );\n\t},\n\n\t/* Check positioning to remain on screen. */\n\t_checkOffset: function(inst, offset, isFixed) {\n\t\tvar dpWidth = inst.dpDiv.outerWidth(),\n\t\t\tdpHeight = inst.dpDiv.outerHeight(),\n\t\t\tinputWidth = inst.input ? inst.input.outerWidth() : 0,\n\t\t\tinputHeight = inst.input ? inst.input.outerHeight() : 0,\n\t\t\tviewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),\n\t\t\tviewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());\n\n\t\toffset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);\n\t\toffset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;\n\t\toffset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;\n\n\t\t// now check if datepicker is showing outside window viewport - move to a better place if so.\n\t\toffset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?\n\t\t\tMath.abs(offset.left + dpWidth - viewWidth) : 0);\n\t\toffset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?\n\t\t\tMath.abs(dpHeight + inputHeight) : 0);\n\n\t\treturn offset;\n\t},\n\n\t/* Find an object\'s position on the screen. */\n\t_findPos: function(obj) {\n\t\tvar position,\n\t\t\tinst = this._getInst(obj),\n\t\t\tisRTL = this._get(inst, "isRTL");\n\n\t\twhile (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {\n\t\t\tobj = obj[isRTL ? "previousSibling" : "nextSibling"];\n\t\t}\n\n\t\tposition = $(obj).offset();\n\t\treturn [position.left, position.top];\n\t},\n\n\t/* Hide the date picker from view.\n\t * @param  input  element - the input field attached to the date picker\n\t */\n\t_hideDatepicker: function(input) {\n\t\tvar showAnim, duration, postProcess, onClose,\n\t\t\tinst = this._curInst;\n\n\t\tif (!inst || (input && inst !== $.data(input, "datepicker"))) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._datepickerShowing) {\n\t\t\tshowAnim = this._get(inst, "showAnim");\n\t\t\tduration = this._get(inst, "duration");\n\t\t\tpostProcess = function() {\n\t\t\t\t$.datepicker._tidyDialog(inst);\n\t\t\t};\n\n\t\t\t// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed\n\t\t\tif ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {\n\t\t\t\tinst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);\n\t\t\t} else {\n\t\t\t\tinst.dpDiv[(showAnim === "slideDown" ? "slideUp" :\n\t\t\t\t\t(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);\n\t\t\t}\n\n\t\t\tif (!showAnim) {\n\t\t\t\tpostProcess();\n\t\t\t}\n\t\t\tthis._datepickerShowing = false;\n\n\t\t\tonClose = this._get(inst, "onClose");\n\t\t\tif (onClose) {\n\t\t\t\tonClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);\n\t\t\t}\n\n\t\t\tthis._lastInput = null;\n\t\t\tif (this._inDialog) {\n\t\t\t\tthis._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });\n\t\t\t\tif ($.blockUI) {\n\t\t\t\t\t$.unblockUI();\n\t\t\t\t\t$("body").append(this.dpDiv);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._inDialog = false;\n\t\t}\n\t},\n\n\t/* Tidy up after a dialog display. */\n\t_tidyDialog: function(inst) {\n\t\tinst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");\n\t},\n\n\t/* Close date picker if clicked elsewhere. */\n\t_checkExternalClick: function(event) {\n\t\tif (!$.datepicker._curInst) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar $target = $(event.target),\n\t\t\tinst = $.datepicker._getInst($target[0]);\n\n\t\tif ( ( ( $target[0].id !== $.datepicker._mainDivId &&\n\t\t\t\t$target.parents("#" + $.datepicker._mainDivId).length === 0 &&\n\t\t\t\t!$target.hasClass($.datepicker.markerClassName) &&\n\t\t\t\t!$target.closest("." + $.datepicker._triggerClass).length &&\n\t\t\t\t$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||\n\t\t\t( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {\n\t\t\t\t$.datepicker._hideDatepicker();\n\t\t}\n\t},\n\n\t/* Adjust one of the date sub-fields. */\n\t_adjustDate: function(id, offset, period) {\n\t\tvar target = $(id),\n\t\t\tinst = this._getInst(target[0]);\n\n\t\tif (this._isDisabledDatepicker(target[0])) {\n\t\t\treturn;\n\t\t}\n\t\tthis._adjustInstDate(inst, offset +\n\t\t\t(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning\n\t\t\tperiod);\n\t\tthis._updateDatepicker(inst);\n\t},\n\n\t/* Action for current link. */\n\t_gotoToday: function(id) {\n\t\tvar date,\n\t\t\ttarget = $(id),\n\t\t\tinst = this._getInst(target[0]);\n\n\t\tif (this._get(inst, "gotoCurrent") && inst.currentDay) {\n\t\t\tinst.selectedDay = inst.currentDay;\n\t\t\tinst.drawMonth = inst.selectedMonth = inst.currentMonth;\n\t\t\tinst.drawYear = inst.selectedYear = inst.currentYear;\n\t\t} else {\n\t\t\tdate = new Date();\n\t\t\tinst.selectedDay = date.getDate();\n\t\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\t}\n\t\tthis._notifyChange(inst);\n\t\tthis._adjustDate(target);\n\t},\n\n\t/* Action for selecting a new month/year. */\n\t_selectMonthYear: function(id, select, period) {\n\t\tvar target = $(id),\n\t\t\tinst = this._getInst(target[0]);\n\n\t\tinst["selected" + (period === "M" ? "Month" : "Year")] =\n\t\tinst["draw" + (period === "M" ? "Month" : "Year")] =\n\t\t\tparseInt(select.options[select.selectedIndex].value,10);\n\n\t\tthis._notifyChange(inst);\n\t\tthis._adjustDate(target);\n\t},\n\n\t/* Action for selecting a day. */\n\t_selectDay: function(id, month, year, td) {\n\t\tvar inst,\n\t\t\ttarget = $(id);\n\n\t\tif ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {\n\t\t\treturn;\n\t\t}\n\n\t\tinst = this._getInst(target[0]);\n\t\tinst.selectedDay = inst.currentDay = $("a", td).html();\n\t\tinst.selectedMonth = inst.currentMonth = month;\n\t\tinst.selectedYear = inst.currentYear = year;\n\t\tthis._selectDate(id, this._formatDate(inst,\n\t\t\tinst.currentDay, inst.currentMonth, inst.currentYear));\n\t},\n\n\t/* Erase the input field and hide the date picker. */\n\t_clearDate: function(id) {\n\t\tvar target = $(id);\n\t\tthis._selectDate(target, "");\n\t},\n\n\t/* Update the input field with the selected date. */\n\t_selectDate: function(id, dateStr) {\n\t\tvar onSelect,\n\t\t\ttarget = $(id),\n\t\t\tinst = this._getInst(target[0]);\n\n\t\tdateStr = (dateStr != null ? dateStr : this._formatDate(inst));\n\t\tif (inst.input) {\n\t\t\tinst.input.val(dateStr);\n\t\t}\n\t\tthis._updateAlternate(inst);\n\n\t\tonSelect = this._get(inst, "onSelect");\n\t\tif (onSelect) {\n\t\t\tonSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback\n\t\t} else if (inst.input) {\n\t\t\tinst.input.trigger("change"); // fire the change event\n\t\t}\n\n\t\tif (inst.inline){\n\t\t\tthis._updateDatepicker(inst);\n\t\t} else {\n\t\t\tthis._hideDatepicker();\n\t\t\tthis._lastInput = inst.input[0];\n\t\t\tif (typeof(inst.input[0]) !== "object") {\n\t\t\t\tinst.input.focus(); // restore focus\n\t\t\t}\n\t\t\tthis._lastInput = null;\n\t\t}\n\t},\n\n\t/* Update any alternate field to synchronise with the main field. */\n\t_updateAlternate: function(inst) {\n\t\tvar altFormat, date, dateStr,\n\t\t\taltField = this._get(inst, "altField");\n\n\t\tif (altField) { // update alternate field too\n\t\t\taltFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");\n\t\t\tdate = this._getDate(inst);\n\t\t\tdateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));\n\t\t\t$(altField).each(function() { $(this).val(dateStr); });\n\t\t}\n\t},\n\n\t/* Set as beforeShowDay function to prevent selection of weekends.\n\t * @param  date  Date - the date to customise\n\t * @return [boolean, string] - is this date selectable?, what is its CSS class?\n\t */\n\tnoWeekends: function(date) {\n\t\tvar day = date.getDay();\n\t\treturn [(day > 0 && day < 6), ""];\n\t},\n\n\t/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.\n\t * @param  date  Date - the date to get the week for\n\t * @return  number - the number of the week within the year that contains this date\n\t */\n\tiso8601Week: function(date) {\n\t\tvar time,\n\t\t\tcheckDate = new Date(date.getTime());\n\n\t\t// Find Thursday of this week starting on Monday\n\t\tcheckDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));\n\n\t\ttime = checkDate.getTime();\n\t\tcheckDate.setMonth(0); // Compare with Jan 1\n\t\tcheckDate.setDate(1);\n\t\treturn Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t},\n\n\t/* Parse a string value into a date object.\n\t * See formatDate below for the possible formats.\n\t *\n\t * @param  format string - the expected format of the date\n\t * @param  value string - the date in the above format\n\t * @param  settings Object - attributes include:\n\t *\t\t\t\t\tshortYearCutoff  number - the cutoff year for determining the century (optional)\n\t *\t\t\t\t\tdayNamesShort\tstring[7] - abbreviated names of the days from Sunday (optional)\n\t *\t\t\t\t\tdayNames\t\tstring[7] - names of the days from Sunday (optional)\n\t *\t\t\t\t\tmonthNamesShort string[12] - abbreviated names of the months (optional)\n\t *\t\t\t\t\tmonthNames\t\tstring[12] - names of the months (optional)\n\t * @return  Date - the extracted date value or null if value is blank\n\t */\n\tparseDate: function (format, value, settings) {\n\t\tif (format == null || value == null) {\n\t\t\tthrow "Invalid arguments";\n\t\t}\n\n\t\tvalue = (typeof value === "object" ? value.toString() : value + "");\n\t\tif (value === "") {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar iFormat, dim, extra,\n\t\t\tiValue = 0,\n\t\t\tshortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,\n\t\t\tshortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :\n\t\t\t\tnew Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),\n\t\t\tdayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n\t\t\tdayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n\t\t\tmonthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n\t\t\tmonthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n\t\t\tyear = -1,\n\t\t\tmonth = -1,\n\t\t\tday = -1,\n\t\t\tdoy = -1,\n\t\t\tliteral = false,\n\t\t\tdate,\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function(match) {\n\t\t\t\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t},\n\t\t\t// Extract a number from the string value\n\t\t\tgetNumber = function(match) {\n\t\t\t\tvar isDoubled = lookAhead(match),\n\t\t\t\t\tsize = (match === "@" ? 14 : (match === "!" ? 20 :\n\t\t\t\t\t(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),\n\t\t\t\t\tminSize = (match === "y" ? size : 1),\n\t\t\t\t\tdigits = new RegExp("^\\\\d{" + minSize + "," + size + "}"),\n\t\t\t\t\tnum = value.substring(iValue).match(digits);\n\t\t\t\tif (!num) {\n\t\t\t\t\tthrow "Missing number at position " + iValue;\n\t\t\t\t}\n\t\t\t\tiValue += num[0].length;\n\t\t\t\treturn parseInt(num[0], 10);\n\t\t\t},\n\t\t\t// Extract a name from the string value and convert to an index\n\t\t\tgetName = function(match, shortNames, longNames) {\n\t\t\t\tvar index = -1,\n\t\t\t\t\tnames = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {\n\t\t\t\t\t\treturn [ [k, v] ];\n\t\t\t\t\t}).sort(function (a, b) {\n\t\t\t\t\t\treturn -(a[1].length - b[1].length);\n\t\t\t\t\t});\n\n\t\t\t\t$.each(names, function (i, pair) {\n\t\t\t\t\tvar name = pair[1];\n\t\t\t\t\tif (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {\n\t\t\t\t\t\tindex = pair[0];\n\t\t\t\t\t\tiValue += name.length;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\treturn index + 1;\n\t\t\t\t} else {\n\t\t\t\t\tthrow "Unknown name at position " + iValue;\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Confirm that a literal character matches the string value\n\t\t\tcheckLiteral = function() {\n\t\t\t\tif (value.charAt(iValue) !== format.charAt(iFormat)) {\n\t\t\t\t\tthrow "Unexpected literal at position " + iValue;\n\t\t\t\t}\n\t\t\t\tiValue++;\n\t\t\t};\n\n\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\tif (literal) {\n\t\t\t\tif (format.charAt(iFormat) === "\'" && !lookAhead("\'")) {\n\t\t\t\t\tliteral = false;\n\t\t\t\t} else {\n\t\t\t\t\tcheckLiteral();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\tcase "d":\n\t\t\t\t\t\tday = getNumber("d");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "D":\n\t\t\t\t\t\tgetName("D", dayNamesShort, dayNames);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "o":\n\t\t\t\t\t\tdoy = getNumber("o");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "m":\n\t\t\t\t\t\tmonth = getNumber("m");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "M":\n\t\t\t\t\t\tmonth = getName("M", monthNamesShort, monthNames);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "y":\n\t\t\t\t\t\tyear = getNumber("y");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "@":\n\t\t\t\t\t\tdate = new Date(getNumber("@"));\n\t\t\t\t\t\tyear = date.getFullYear();\n\t\t\t\t\t\tmonth = date.getMonth() + 1;\n\t\t\t\t\t\tday = date.getDate();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "!":\n\t\t\t\t\t\tdate = new Date((getNumber("!") - this._ticksTo1970) / 10000);\n\t\t\t\t\t\tyear = date.getFullYear();\n\t\t\t\t\t\tmonth = date.getMonth() + 1;\n\t\t\t\t\t\tday = date.getDate();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "\'":\n\t\t\t\t\t\tif (lookAhead("\'")){\n\t\t\t\t\t\t\tcheckLiteral();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcheckLiteral();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (iValue < value.length){\n\t\t\textra = value.substr(iValue);\n\t\t\tif (!/^\\s+/.test(extra)) {\n\t\t\t\tthrow "Extra/unparsed characters found in date: " + extra;\n\t\t\t}\n\t\t}\n\n\t\tif (year === -1) {\n\t\t\tyear = new Date().getFullYear();\n\t\t} else if (year < 100) {\n\t\t\tyear += new Date().getFullYear() - new Date().getFullYear() % 100 +\n\t\t\t\t(year <= shortYearCutoff ? 0 : -100);\n\t\t}\n\n\t\tif (doy > -1) {\n\t\t\tmonth = 1;\n\t\t\tday = doy;\n\t\t\tdo {\n\t\t\t\tdim = this._getDaysInMonth(year, month - 1);\n\t\t\t\tif (day <= dim) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmonth++;\n\t\t\t\tday -= dim;\n\t\t\t} while (true);\n\t\t}\n\n\t\tdate = this._daylightSavingAdjust(new Date(year, month - 1, day));\n\t\tif (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {\n\t\t\tthrow "Invalid date"; // E.g. 31/02/00\n\t\t}\n\t\treturn date;\n\t},\n\n\t/* Standard date formats. */\n\tATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)\n\tCOOKIE: "D, dd M yy",\n\tISO_8601: "yy-mm-dd",\n\tRFC_822: "D, d M y",\n\tRFC_850: "DD, dd-M-y",\n\tRFC_1036: "D, d M y",\n\tRFC_1123: "D, d M yy",\n\tRFC_2822: "D, d M yy",\n\tRSS: "D, d M y", // RFC 822\n\tTICKS: "!",\n\tTIMESTAMP: "@",\n\tW3C: "yy-mm-dd", // ISO 8601\n\n\t_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +\n\t\tMath.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),\n\n\t/* Format a date object into a string value.\n\t * The format can be combinations of the following:\n\t * d  - day of month (no leading zero)\n\t * dd - day of month (two digit)\n\t * o  - day of year (no leading zeros)\n\t * oo - day of year (three digit)\n\t * D  - day name short\n\t * DD - day name long\n\t * m  - month of year (no leading zero)\n\t * mm - month of year (two digit)\n\t * M  - month name short\n\t * MM - month name long\n\t * y  - year (two digit)\n\t * yy - year (four digit)\n\t * @ - Unix timestamp (ms since 01/01/1970)\n\t * ! - Windows ticks (100ns since 01/01/0001)\n\t * "..." - literal text\n\t * \'\' - single quote\n\t *\n\t * @param  format string - the desired format of the date\n\t * @param  date Date - the date value to format\n\t * @param  settings Object - attributes include:\n\t *\t\t\t\t\tdayNamesShort\tstring[7] - abbreviated names of the days from Sunday (optional)\n\t *\t\t\t\t\tdayNames\t\tstring[7] - names of the days from Sunday (optional)\n\t *\t\t\t\t\tmonthNamesShort string[12] - abbreviated names of the months (optional)\n\t *\t\t\t\t\tmonthNames\t\tstring[12] - names of the months (optional)\n\t * @return  string - the date in the above format\n\t */\n\tformatDate: function (format, date, settings) {\n\t\tif (!date) {\n\t\t\treturn "";\n\t\t}\n\n\t\tvar iFormat,\n\t\t\tdayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n\t\t\tdayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n\t\t\tmonthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n\t\t\tmonthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function(match) {\n\t\t\t\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t},\n\t\t\t// Format a number, with leading zero if necessary\n\t\t\tformatNumber = function(match, value, len) {\n\t\t\t\tvar num = "" + value;\n\t\t\t\tif (lookAhead(match)) {\n\t\t\t\t\twhile (num.length < len) {\n\t\t\t\t\t\tnum = "0" + num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn num;\n\t\t\t},\n\t\t\t// Format a name, short or long as requested\n\t\t\tformatName = function(match, value, shortNames, longNames) {\n\t\t\t\treturn (lookAhead(match) ? longNames[value] : shortNames[value]);\n\t\t\t},\n\t\t\toutput = "",\n\t\t\tliteral = false;\n\n\t\tif (date) {\n\t\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\t\tif (literal) {\n\t\t\t\t\tif (format.charAt(iFormat) === "\'" && !lookAhead("\'")) {\n\t\t\t\t\t\tliteral = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += format.charAt(iFormat);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\t\tcase "d":\n\t\t\t\t\t\t\toutput += formatNumber("d", date.getDate(), 2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "D":\n\t\t\t\t\t\t\toutput += formatName("D", date.getDay(), dayNamesShort, dayNames);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "o":\n\t\t\t\t\t\t\toutput += formatNumber("o",\n\t\t\t\t\t\t\t\tMath.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "m":\n\t\t\t\t\t\t\toutput += formatNumber("m", date.getMonth() + 1, 2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "M":\n\t\t\t\t\t\t\toutput += formatName("M", date.getMonth(), monthNamesShort, monthNames);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "y":\n\t\t\t\t\t\t\toutput += (lookAhead("y") ? date.getFullYear() :\n\t\t\t\t\t\t\t\t(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "@":\n\t\t\t\t\t\t\toutput += date.getTime();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "!":\n\t\t\t\t\t\t\toutput += date.getTime() * 10000 + this._ticksTo1970;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "\'":\n\t\t\t\t\t\t\tif (lookAhead("\'")) {\n\t\t\t\t\t\t\t\toutput += "\'";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\toutput += format.charAt(iFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t},\n\n\t/* Extract all possible characters from the date format. */\n\t_possibleChars: function (format) {\n\t\tvar iFormat,\n\t\t\tchars = "",\n\t\t\tliteral = false,\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function(match) {\n\t\t\t\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t};\n\n\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\tif (literal) {\n\t\t\t\tif (format.charAt(iFormat) === "\'" && !lookAhead("\'")) {\n\t\t\t\t\tliteral = false;\n\t\t\t\t} else {\n\t\t\t\t\tchars += format.charAt(iFormat);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\tcase "d": case "m": case "y": case "@":\n\t\t\t\t\t\tchars += "0123456789";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "D": case "M":\n\t\t\t\t\t\treturn null; // Accept anything\n\t\t\t\t\tcase "\'":\n\t\t\t\t\t\tif (lookAhead("\'")) {\n\t\t\t\t\t\t\tchars += "\'";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tchars += format.charAt(iFormat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn chars;\n\t},\n\n\t/* Get a setting value, defaulting if necessary. */\n\t_get: function(inst, name) {\n\t\treturn inst.settings[name] !== undefined ?\n\t\t\tinst.settings[name] : this._defaults[name];\n\t},\n\n\t/* Parse existing date and initialise date picker. */\n\t_setDateFromField: function(inst, noDefault) {\n\t\tif (inst.input.val() === inst.lastVal) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar dateFormat = this._get(inst, "dateFormat"),\n\t\t\tdates = inst.lastVal = inst.input ? inst.input.val() : null,\n\t\t\tdefaultDate = this._getDefaultDate(inst),\n\t\t\tdate = defaultDate,\n\t\t\tsettings = this._getFormatConfig(inst);\n\n\t\ttry {\n\t\t\tdate = this.parseDate(dateFormat, dates, settings) || defaultDate;\n\t\t} catch (event) {\n\t\t\tdates = (noDefault ? "" : dates);\n\t\t}\n\t\tinst.selectedDay = date.getDate();\n\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\tinst.currentDay = (dates ? date.getDate() : 0);\n\t\tinst.currentMonth = (dates ? date.getMonth() : 0);\n\t\tinst.currentYear = (dates ? date.getFullYear() : 0);\n\t\tthis._adjustInstDate(inst);\n\t},\n\n\t/* Retrieve the default date shown on opening. */\n\t_getDefaultDate: function(inst) {\n\t\treturn this._restrictMinMax(inst,\n\t\t\tthis._determineDate(inst, this._get(inst, "defaultDate"), new Date()));\n\t},\n\n\t/* A date may be specified as an exact value or a relative one. */\n\t_determineDate: function(inst, date, defaultDate) {\n\t\tvar offsetNumeric = function(offset) {\n\t\t\t\tvar date = new Date();\n\t\t\t\tdate.setDate(date.getDate() + offset);\n\t\t\t\treturn date;\n\t\t\t},\n\t\t\toffsetString = function(offset) {\n\t\t\t\ttry {\n\t\t\t\t\treturn $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),\n\t\t\t\t\t\toffset, $.datepicker._getFormatConfig(inst));\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\n\t\t\t\tvar date = (offset.toLowerCase().match(/^c/) ?\n\t\t\t\t\t$.datepicker._getDate(inst) : null) || new Date(),\n\t\t\t\t\tyear = date.getFullYear(),\n\t\t\t\t\tmonth = date.getMonth(),\n\t\t\t\t\tday = date.getDate(),\n\t\t\t\t\tpattern = /([+\\-]?[0-9]+)\\s*(d|D|w|W|m|M|y|Y)?/g,\n\t\t\t\t\tmatches = pattern.exec(offset);\n\n\t\t\t\twhile (matches) {\n\t\t\t\t\tswitch (matches[2] || "d") {\n\t\t\t\t\t\tcase "d" : case "D" :\n\t\t\t\t\t\t\tday += parseInt(matches[1],10); break;\n\t\t\t\t\t\tcase "w" : case "W" :\n\t\t\t\t\t\t\tday += parseInt(matches[1],10) * 7; break;\n\t\t\t\t\t\tcase "m" : case "M" :\n\t\t\t\t\t\t\tmonth += parseInt(matches[1],10);\n\t\t\t\t\t\t\tday = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase "y": case "Y" :\n\t\t\t\t\t\t\tyear += parseInt(matches[1],10);\n\t\t\t\t\t\t\tday = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmatches = pattern.exec(offset);\n\t\t\t\t}\n\t\t\t\treturn new Date(year, month, day);\n\t\t\t},\n\t\t\tnewDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :\n\t\t\t\t(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));\n\n\t\tnewDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);\n\t\tif (newDate) {\n\t\t\tnewDate.setHours(0);\n\t\t\tnewDate.setMinutes(0);\n\t\t\tnewDate.setSeconds(0);\n\t\t\tnewDate.setMilliseconds(0);\n\t\t}\n\t\treturn this._daylightSavingAdjust(newDate);\n\t},\n\n\t/* Handle switch to/from daylight saving.\n\t * Hours may be non-zero on daylight saving cut-over:\n\t * > 12 when midnight changeover, but then cannot generate\n\t * midnight datetime, so jump to 1AM, otherwise reset.\n\t * @param  date  (Date) the date to check\n\t * @return  (Date) the corrected date\n\t */\n\t_daylightSavingAdjust: function(date) {\n\t\tif (!date) {\n\t\t\treturn null;\n\t\t}\n\t\tdate.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n\t\treturn date;\n\t},\n\n\t/* Set the date(s) directly. */\n\t_setDate: function(inst, date, noChange) {\n\t\tvar clear = !date,\n\t\t\torigMonth = inst.selectedMonth,\n\t\t\torigYear = inst.selectedYear,\n\t\t\tnewDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));\n\n\t\tinst.selectedDay = inst.currentDay = newDate.getDate();\n\t\tinst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();\n\t\tinst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();\n\t\tif ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {\n\t\t\tthis._notifyChange(inst);\n\t\t}\n\t\tthis._adjustInstDate(inst);\n\t\tif (inst.input) {\n\t\t\tinst.input.val(clear ? "" : this._formatDate(inst));\n\t\t}\n\t},\n\n\t/* Retrieve the date(s) directly. */\n\t_getDate: function(inst) {\n\t\tvar startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :\n\t\t\tthis._daylightSavingAdjust(new Date(\n\t\t\tinst.currentYear, inst.currentMonth, inst.currentDay)));\n\t\t\treturn startDate;\n\t},\n\n\t/* Attach the onxxx handlers.  These are declared statically so\n\t * they work with static code transformers like Caja.\n\t */\n\t_attachHandlers: function(inst) {\n\t\tvar stepMonths = this._get(inst, "stepMonths"),\n\t\t\tid = "#" + inst.id.replace( /\\\\\\\\/g, "\\\\" );\n\t\tinst.dpDiv.find("[data-handler]").map(function () {\n\t\t\tvar handler = {\n\t\t\t\tprev: function () {\n\t\t\t\t\t$.datepicker._adjustDate(id, -stepMonths, "M");\n\t\t\t\t},\n\t\t\t\tnext: function () {\n\t\t\t\t\t$.datepicker._adjustDate(id, +stepMonths, "M");\n\t\t\t\t},\n\t\t\t\thide: function () {\n\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t},\n\t\t\t\ttoday: function () {\n\t\t\t\t\t$.datepicker._gotoToday(id);\n\t\t\t\t},\n\t\t\t\tselectDay: function () {\n\t\t\t\t\t$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tselectMonth: function () {\n\t\t\t\t\t$.datepicker._selectMonthYear(id, this, "M");\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tselectYear: function () {\n\t\t\t\t\t$.datepicker._selectMonthYear(id, this, "Y");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t};\n\t\t\t$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);\n\t\t});\n\t},\n\n\t/* Generate the HTML for the current state of the date picker. */\n\t_generateHTML: function(inst) {\n\t\tvar maxDraw, prevText, prev, nextText, next, currentText, gotoDate,\n\t\t\tcontrols, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,\n\t\t\tmonthNames, monthNamesShort, beforeShowDay, showOtherMonths,\n\t\t\tselectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,\n\t\t\tcornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,\n\t\t\tprintDate, dRow, tbody, daySettings, otherMonth, unselectable,\n\t\t\ttempDate = new Date(),\n\t\t\ttoday = this._daylightSavingAdjust(\n\t\t\t\tnew Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time\n\t\t\tisRTL = this._get(inst, "isRTL"),\n\t\t\tshowButtonPanel = this._get(inst, "showButtonPanel"),\n\t\t\thideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),\n\t\t\tnavigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),\n\t\t\tnumMonths = this._getNumberOfMonths(inst),\n\t\t\tshowCurrentAtPos = this._get(inst, "showCurrentAtPos"),\n\t\t\tstepMonths = this._get(inst, "stepMonths"),\n\t\t\tisMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),\n\t\t\tcurrentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :\n\t\t\t\tnew Date(inst.currentYear, inst.currentMonth, inst.currentDay))),\n\t\t\tminDate = this._getMinMaxDate(inst, "min"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, "max"),\n\t\t\tdrawMonth = inst.drawMonth - showCurrentAtPos,\n\t\t\tdrawYear = inst.drawYear;\n\n\t\tif (drawMonth < 0) {\n\t\t\tdrawMonth += 12;\n\t\t\tdrawYear--;\n\t\t}\n\t\tif (maxDate) {\n\t\t\tmaxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),\n\t\t\t\tmaxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));\n\t\t\tmaxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);\n\t\t\twhile (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {\n\t\t\t\tdrawMonth--;\n\t\t\t\tif (drawMonth < 0) {\n\t\t\t\t\tdrawMonth = 11;\n\t\t\t\t\tdrawYear--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinst.drawMonth = drawMonth;\n\t\tinst.drawYear = drawYear;\n\n\t\tprevText = this._get(inst, "prevText");\n\t\tprevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,\n\t\t\tthis._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),\n\t\t\tthis._getFormatConfig(inst)));\n\n\t\tprev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?\n\t\t\t"<a class=\'ui-datepicker-prev ui-corner-all\' data-handler=\'prev\' data-event=\'click\'" +\n\t\t\t" title=\'" + prevText + "\'><span class=\'ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "\'>" + prevText + "</span></a>" :\n\t\t\t(hideIfNoPrevNext ? "" : "<a class=\'ui-datepicker-prev ui-corner-all ui-state-disabled\' title=\'"+ prevText +"\'><span class=\'ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "\'>" + prevText + "</span></a>"));\n\n\t\tnextText = this._get(inst, "nextText");\n\t\tnextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,\n\t\t\tthis._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),\n\t\t\tthis._getFormatConfig(inst)));\n\n\t\tnext = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?\n\t\t\t"<a class=\'ui-datepicker-next ui-corner-all\' data-handler=\'next\' data-event=\'click\'" +\n\t\t\t" title=\'" + nextText + "\'><span class=\'ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "\'>" + nextText + "</span></a>" :\n\t\t\t(hideIfNoPrevNext ? "" : "<a class=\'ui-datepicker-next ui-corner-all ui-state-disabled\' title=\'"+ nextText + "\'><span class=\'ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "\'>" + nextText + "</span></a>"));\n\n\t\tcurrentText = this._get(inst, "currentText");\n\t\tgotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);\n\t\tcurrentText = (!navigationAsDateFormat ? currentText :\n\t\t\tthis.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));\n\n\t\tcontrols = (!inst.inline ? "<button type=\'button\' class=\'ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all\' data-handler=\'hide\' data-event=\'click\'>" +\n\t\t\tthis._get(inst, "closeText") + "</button>" : "");\n\n\t\tbuttonPanel = (showButtonPanel) ? "<div class=\'ui-datepicker-buttonpane ui-widget-content\'>" + (isRTL ? controls : "") +\n\t\t\t(this._isInRange(inst, gotoDate) ? "<button type=\'button\' class=\'ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all\' data-handler=\'today\' data-event=\'click\'" +\n\t\t\t">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";\n\n\t\tfirstDay = parseInt(this._get(inst, "firstDay"),10);\n\t\tfirstDay = (isNaN(firstDay) ? 0 : firstDay);\n\n\t\tshowWeek = this._get(inst, "showWeek");\n\t\tdayNames = this._get(inst, "dayNames");\n\t\tdayNamesMin = this._get(inst, "dayNamesMin");\n\t\tmonthNames = this._get(inst, "monthNames");\n\t\tmonthNamesShort = this._get(inst, "monthNamesShort");\n\t\tbeforeShowDay = this._get(inst, "beforeShowDay");\n\t\tshowOtherMonths = this._get(inst, "showOtherMonths");\n\t\tselectOtherMonths = this._get(inst, "selectOtherMonths");\n\t\tdefaultDate = this._getDefaultDate(inst);\n\t\thtml = "";\n\t\tdow;\n\t\tfor (row = 0; row < numMonths[0]; row++) {\n\t\t\tgroup = "";\n\t\t\tthis.maxRows = 4;\n\t\t\tfor (col = 0; col < numMonths[1]; col++) {\n\t\t\t\tselectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));\n\t\t\t\tcornerClass = " ui-corner-all";\n\t\t\t\tcalender = "";\n\t\t\t\tif (isMultiMonth) {\n\t\t\t\t\tcalender += "<div class=\'ui-datepicker-group";\n\t\t\t\t\tif (numMonths[1] > 1) {\n\t\t\t\t\t\tswitch (col) {\n\t\t\t\t\t\t\tcase 0: calender += " ui-datepicker-group-first";\n\t\t\t\t\t\t\t\tcornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;\n\t\t\t\t\t\t\tcase numMonths[1]-1: calender += " ui-datepicker-group-last";\n\t\t\t\t\t\t\t\tcornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;\n\t\t\t\t\t\t\tdefault: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcalender += "\'>";\n\t\t\t\t}\n\t\t\t\tcalender += "<div class=\'ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "\'>" +\n\t\t\t\t\t(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +\n\t\t\t\t\t(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +\n\t\t\t\t\tthis._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,\n\t\t\t\t\trow > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers\n\t\t\t\t\t"</div><table class=\'ui-datepicker-calendar\'><thead>" +\n\t\t\t\t\t"<tr>";\n\t\t\t\tthead = (showWeek ? "<th class=\'ui-datepicker-week-col\'>" + this._get(inst, "weekHeader") + "</th>" : "");\n\t\t\t\tfor (dow = 0; dow < 7; dow++) { // days of the week\n\t\t\t\t\tday = (dow + firstDay) % 7;\n\t\t\t\t\tthead += "<th scope=\'col\'" + ((dow + firstDay + 6) % 7 >= 5 ? " class=\'ui-datepicker-week-end\'" : "") + ">" +\n\t\t\t\t\t\t"<span title=\'" + dayNames[day] + "\'>" + dayNamesMin[day] + "</span></th>";\n\t\t\t\t}\n\t\t\t\tcalender += thead + "</tr></thead><tbody>";\n\t\t\t\tdaysInMonth = this._getDaysInMonth(drawYear, drawMonth);\n\t\t\t\tif (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {\n\t\t\t\t\tinst.selectedDay = Math.min(inst.selectedDay, daysInMonth);\n\t\t\t\t}\n\t\t\t\tleadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;\n\t\t\t\tcurRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate\n\t\t\t\tnumRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)\n\t\t\t\tthis.maxRows = numRows;\n\t\t\t\tprintDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));\n\t\t\t\tfor (dRow = 0; dRow < numRows; dRow++) { // create date picker rows\n\t\t\t\t\tcalender += "<tr>";\n\t\t\t\t\ttbody = (!showWeek ? "" : "<td class=\'ui-datepicker-week-col\'>" +\n\t\t\t\t\t\tthis._get(inst, "calculateWeek")(printDate) + "</td>");\n\t\t\t\t\tfor (dow = 0; dow < 7; dow++) { // create date picker days\n\t\t\t\t\t\tdaySettings = (beforeShowDay ?\n\t\t\t\t\t\t\tbeforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);\n\t\t\t\t\t\totherMonth = (printDate.getMonth() !== drawMonth);\n\t\t\t\t\t\tunselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||\n\t\t\t\t\t\t\t(minDate && printDate < minDate) || (maxDate && printDate > maxDate);\n\t\t\t\t\t\ttbody += "<td class=\'" +\n\t\t\t\t\t\t\t((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends\n\t\t\t\t\t\t\t(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months\n\t\t\t\t\t\t\t((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key\n\t\t\t\t\t\t\t(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?\n\t\t\t\t\t\t\t// or defaultDate is current printedDate and defaultDate is selectedDate\n\t\t\t\t\t\t\t" " + this._dayOverClass : "") + // highlight selected day\n\t\t\t\t\t\t\t(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days\n\t\t\t\t\t\t\t(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates\n\t\t\t\t\t\t\t(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day\n\t\t\t\t\t\t\t(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "\'" + // highlight today (if different)\n\t\t\t\t\t\t\t((!otherMonth || showOtherMonths) && daySettings[2] ? " title=\'" + daySettings[2].replace(/\'/g, "&#39;") + "\'" : "") + // cell title\n\t\t\t\t\t\t\t(unselectable ? "" : " data-handler=\'selectDay\' data-event=\'click\' data-month=\'" + printDate.getMonth() + "\' data-year=\'" + printDate.getFullYear() + "\'") + ">" + // actions\n\t\t\t\t\t\t\t(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months\n\t\t\t\t\t\t\t(unselectable ? "<span class=\'ui-state-default\'>" + printDate.getDate() + "</span>" : "<a class=\'ui-state-default" +\n\t\t\t\t\t\t\t(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +\n\t\t\t\t\t\t\t(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day\n\t\t\t\t\t\t\t(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months\n\t\t\t\t\t\t\t"\' href=\'#\'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date\n\t\t\t\t\t\tprintDate.setDate(printDate.getDate() + 1);\n\t\t\t\t\t\tprintDate = this._daylightSavingAdjust(printDate);\n\t\t\t\t\t}\n\t\t\t\t\tcalender += tbody + "</tr>";\n\t\t\t\t}\n\t\t\t\tdrawMonth++;\n\t\t\t\tif (drawMonth > 11) {\n\t\t\t\t\tdrawMonth = 0;\n\t\t\t\t\tdrawYear++;\n\t\t\t\t}\n\t\t\t\tcalender += "</tbody></table>" + (isMultiMonth ? "</div>" +\n\t\t\t\t\t\t\t((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class=\'ui-datepicker-row-break\'></div>" : "") : "");\n\t\t\t\tgroup += calender;\n\t\t\t}\n\t\t\thtml += group;\n\t\t}\n\t\thtml += buttonPanel;\n\t\tinst._keyEvent = false;\n\t\treturn html;\n\t},\n\n\t/* Generate the month and year header. */\n\t_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,\n\t\t\tsecondary, monthNames, monthNamesShort) {\n\n\t\tvar inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,\n\t\t\tchangeMonth = this._get(inst, "changeMonth"),\n\t\t\tchangeYear = this._get(inst, "changeYear"),\n\t\t\tshowMonthAfterYear = this._get(inst, "showMonthAfterYear"),\n\t\t\thtml = "<div class=\'ui-datepicker-title\'>",\n\t\t\tmonthHtml = "";\n\n\t\t// month selection\n\t\tif (secondary || !changeMonth) {\n\t\t\tmonthHtml += "<span class=\'ui-datepicker-month\'>" + monthNames[drawMonth] + "</span>";\n\t\t} else {\n\t\t\tinMinYear = (minDate && minDate.getFullYear() === drawYear);\n\t\t\tinMaxYear = (maxDate && maxDate.getFullYear() === drawYear);\n\t\t\tmonthHtml += "<select class=\'ui-datepicker-month\' data-handler=\'selectMonth\' data-event=\'change\'>";\n\t\t\tfor ( month = 0; month < 12; month++) {\n\t\t\t\tif ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {\n\t\t\t\t\tmonthHtml += "<option value=\'" + month + "\'" +\n\t\t\t\t\t\t(month === drawMonth ? " selected=\'selected\'" : "") +\n\t\t\t\t\t\t">" + monthNamesShort[month] + "</option>";\n\t\t\t\t}\n\t\t\t}\n\t\t\tmonthHtml += "</select>";\n\t\t}\n\n\t\tif (!showMonthAfterYear) {\n\t\t\thtml += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");\n\t\t}\n\n\t\t// year selection\n\t\tif ( !inst.yearshtml ) {\n\t\t\tinst.yearshtml = "";\n\t\t\tif (secondary || !changeYear) {\n\t\t\t\thtml += "<span class=\'ui-datepicker-year\'>" + drawYear + "</span>";\n\t\t\t} else {\n\t\t\t\t// determine range of years to display\n\t\t\t\tyears = this._get(inst, "yearRange").split(":");\n\t\t\t\tthisYear = new Date().getFullYear();\n\t\t\t\tdetermineYear = function(value) {\n\t\t\t\t\tvar year = (value.match(/c[+\\-].*/) ? drawYear + parseInt(value.substring(1), 10) :\n\t\t\t\t\t\t(value.match(/[+\\-].*/) ? thisYear + parseInt(value, 10) :\n\t\t\t\t\t\tparseInt(value, 10)));\n\t\t\t\t\treturn (isNaN(year) ? thisYear : year);\n\t\t\t\t};\n\t\t\t\tyear = determineYear(years[0]);\n\t\t\t\tendYear = Math.max(year, determineYear(years[1] || ""));\n\t\t\t\tyear = (minDate ? Math.max(year, minDate.getFullYear()) : year);\n\t\t\t\tendYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);\n\t\t\t\tinst.yearshtml += "<select class=\'ui-datepicker-year\' data-handler=\'selectYear\' data-event=\'change\'>";\n\t\t\t\tfor (; year <= endYear; year++) {\n\t\t\t\t\tinst.yearshtml += "<option value=\'" + year + "\'" +\n\t\t\t\t\t\t(year === drawYear ? " selected=\'selected\'" : "") +\n\t\t\t\t\t\t">" + year + "</option>";\n\t\t\t\t}\n\t\t\t\tinst.yearshtml += "</select>";\n\n\t\t\t\thtml += inst.yearshtml;\n\t\t\t\tinst.yearshtml = null;\n\t\t\t}\n\t\t}\n\n\t\thtml += this._get(inst, "yearSuffix");\n\t\tif (showMonthAfterYear) {\n\t\t\thtml += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;\n\t\t}\n\t\thtml += "</div>"; // Close datepicker_header\n\t\treturn html;\n\t},\n\n\t/* Adjust one of the date sub-fields. */\n\t_adjustInstDate: function(inst, offset, period) {\n\t\tvar year = inst.drawYear + (period === "Y" ? offset : 0),\n\t\t\tmonth = inst.drawMonth + (period === "M" ? offset : 0),\n\t\t\tday = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),\n\t\t\tdate = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));\n\n\t\tinst.selectedDay = date.getDate();\n\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\tif (period === "M" || period === "Y") {\n\t\t\tthis._notifyChange(inst);\n\t\t}\n\t},\n\n\t/* Ensure a date is within any min/max bounds. */\n\t_restrictMinMax: function(inst, date) {\n\t\tvar minDate = this._getMinMaxDate(inst, "min"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, "max"),\n\t\t\tnewDate = (minDate && date < minDate ? minDate : date);\n\t\treturn (maxDate && newDate > maxDate ? maxDate : newDate);\n\t},\n\n\t/* Notify change of month/year. */\n\t_notifyChange: function(inst) {\n\t\tvar onChange = this._get(inst, "onChangeMonthYear");\n\t\tif (onChange) {\n\t\t\tonChange.apply((inst.input ? inst.input[0] : null),\n\t\t\t\t[inst.selectedYear, inst.selectedMonth + 1, inst]);\n\t\t}\n\t},\n\n\t/* Determine the number of months to show. */\n\t_getNumberOfMonths: function(inst) {\n\t\tvar numMonths = this._get(inst, "numberOfMonths");\n\t\treturn (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));\n\t},\n\n\t/* Determine the current maximum date - ensure no time components are set. */\n\t_getMinMaxDate: function(inst, minMax) {\n\t\treturn this._determineDate(inst, this._get(inst, minMax + "Date"), null);\n\t},\n\n\t/* Find the number of days in a given month. */\n\t_getDaysInMonth: function(year, month) {\n\t\treturn 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();\n\t},\n\n\t/* Find the day of the week of the first of a month. */\n\t_getFirstDayOfMonth: function(year, month) {\n\t\treturn new Date(year, month, 1).getDay();\n\t},\n\n\t/* Determines if we should allow a "next/prev" month display change. */\n\t_canAdjustMonth: function(inst, offset, curYear, curMonth) {\n\t\tvar numMonths = this._getNumberOfMonths(inst),\n\t\t\tdate = this._daylightSavingAdjust(new Date(curYear,\n\t\t\tcurMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));\n\n\t\tif (offset < 0) {\n\t\t\tdate.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));\n\t\t}\n\t\treturn this._isInRange(inst, date);\n\t},\n\n\t/* Is the given date in the accepted range? */\n\t_isInRange: function(inst, date) {\n\t\tvar yearSplit, currentYear,\n\t\t\tminDate = this._getMinMaxDate(inst, "min"),\n\t\t\tmaxDate = this._getMinMaxDate(inst, "max"),\n\t\t\tminYear = null,\n\t\t\tmaxYear = null,\n\t\t\tyears = this._get(inst, "yearRange");\n\t\t\tif (years){\n\t\t\t\tyearSplit = years.split(":");\n\t\t\t\tcurrentYear = new Date().getFullYear();\n\t\t\t\tminYear = parseInt(yearSplit[0], 10);\n\t\t\t\tmaxYear = parseInt(yearSplit[1], 10);\n\t\t\t\tif ( yearSplit[0].match(/[+\\-].*/) ) {\n\t\t\t\t\tminYear += currentYear;\n\t\t\t\t}\n\t\t\t\tif ( yearSplit[1].match(/[+\\-].*/) ) {\n\t\t\t\t\tmaxYear += currentYear;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn ((!minDate || date.getTime() >= minDate.getTime()) &&\n\t\t\t(!maxDate || date.getTime() <= maxDate.getTime()) &&\n\t\t\t(!minYear || date.getFullYear() >= minYear) &&\n\t\t\t(!maxYear || date.getFullYear() <= maxYear));\n\t},\n\n\t/* Provide the configuration settings for formatting/parsing. */\n\t_getFormatConfig: function(inst) {\n\t\tvar shortYearCutoff = this._get(inst, "shortYearCutoff");\n\t\tshortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :\n\t\t\tnew Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));\n\t\treturn {shortYearCutoff: shortYearCutoff,\n\t\t\tdayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),\n\t\t\tmonthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};\n\t},\n\n\t/* Format the given date for display. */\n\t_formatDate: function(inst, day, month, year) {\n\t\tif (!day) {\n\t\t\tinst.currentDay = inst.selectedDay;\n\t\t\tinst.currentMonth = inst.selectedMonth;\n\t\t\tinst.currentYear = inst.selectedYear;\n\t\t}\n\t\tvar date = (day ? (typeof day === "object" ? day :\n\t\t\tthis._daylightSavingAdjust(new Date(year, month, day))) :\n\t\t\tthis._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));\n\t\treturn this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));\n\t}\n});\n\n/*\n * Bind hover events for datepicker elements.\n * Done via delegate so the binding only occurs once in the lifetime of the parent div.\n * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.\n */\nfunction datepicker_bindHover(dpDiv) {\n\tvar selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";\n\treturn dpDiv.delegate(selector, "mouseout", function() {\n\t\t\t$(this).removeClass("ui-state-hover");\n\t\t\tif (this.className.indexOf("ui-datepicker-prev") !== -1) {\n\t\t\t\t$(this).removeClass("ui-datepicker-prev-hover");\n\t\t\t}\n\t\t\tif (this.className.indexOf("ui-datepicker-next") !== -1) {\n\t\t\t\t$(this).removeClass("ui-datepicker-next-hover");\n\t\t\t}\n\t\t})\n\t\t.delegate( selector, "mouseover", datepicker_handleMouseover );\n}\n\nfunction datepicker_handleMouseover() {\n\tif (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {\n\t\t$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");\n\t\t$(this).addClass("ui-state-hover");\n\t\tif (this.className.indexOf("ui-datepicker-prev") !== -1) {\n\t\t\t$(this).addClass("ui-datepicker-prev-hover");\n\t\t}\n\t\tif (this.className.indexOf("ui-datepicker-next") !== -1) {\n\t\t\t$(this).addClass("ui-datepicker-next-hover");\n\t\t}\n\t}\n}\n\n/* jQuery extend now ignores nulls! */\nfunction datepicker_extendRemove(target, props) {\n\t$.extend(target, props);\n\tfor (var name in props) {\n\t\tif (props[name] == null) {\n\t\t\ttarget[name] = props[name];\n\t\t}\n\t}\n\treturn target;\n}\n\n/* Invoke the datepicker functionality.\n   @param  options  string - a command, optionally followed by additional parameters or\n\t\t\t\t\tObject - settings for attaching new datepicker functionality\n   @return  jQuery object */\n$.fn.datepicker = function(options){\n\n\t/* Verify an empty collection wasn\'t passed - Fixes #6976 */\n\tif ( !this.length ) {\n\t\treturn this;\n\t}\n\n\t/* Initialise the date picker. */\n\tif (!$.datepicker.initialized) {\n\t\t$(document).mousedown($.datepicker._checkExternalClick);\n\t\t$.datepicker.initialized = true;\n\t}\n\n\t/* Append datepicker main container to body if not exist. */\n\tif ($("#"+$.datepicker._mainDivId).length === 0) {\n\t\t$("body").append($.datepicker.dpDiv);\n\t}\n\n\tvar otherArgs = Array.prototype.slice.call(arguments, 1);\n\tif (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {\n\t\treturn $.datepicker["_" + options + "Datepicker"].\n\t\t\tapply($.datepicker, [this[0]].concat(otherArgs));\n\t}\n\tif (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {\n\t\treturn $.datepicker["_" + options + "Datepicker"].\n\t\t\tapply($.datepicker, [this[0]].concat(otherArgs));\n\t}\n\treturn this.each(function() {\n\t\ttypeof options === "string" ?\n\t\t\t$.datepicker["_" + options + "Datepicker"].\n\t\t\t\tapply($.datepicker, [this].concat(otherArgs)) :\n\t\t\t$.datepicker._attachDatepicker(this, options);\n\t});\n};\n\n$.datepicker = new Datepicker(); // singleton instance\n$.datepicker.initialized = false;\n$.datepicker.uuid = new Date().getTime();\n$.datepicker.version = "1.11.4";\n\nvar datepicker = $.datepicker;\n\n\n/*!\n * jQuery UI Draggable 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/draggable/\n */\n\n\n$.widget("ui.draggable", $.ui.mouse, {\n\tversion: "1.11.4",\n\twidgetEventPrefix: "drag",\n\toptions: {\n\t\taddClasses: true,\n\t\tappendTo: "parent",\n\t\taxis: false,\n\t\tconnectToSortable: false,\n\t\tcontainment: false,\n\t\tcursor: "auto",\n\t\tcursorAt: false,\n\t\tgrid: false,\n\t\thandle: false,\n\t\thelper: "original",\n\t\tiframeFix: false,\n\t\topacity: false,\n\t\trefreshPositions: false,\n\t\trevert: false,\n\t\trevertDuration: 500,\n\t\tscope: "default",\n\t\tscroll: true,\n\t\tscrollSensitivity: 20,\n\t\tscrollSpeed: 20,\n\t\tsnap: false,\n\t\tsnapMode: "both",\n\t\tsnapTolerance: 20,\n\t\tstack: false,\n\t\tzIndex: false,\n\n\t\t// callbacks\n\t\tdrag: null,\n\t\tstart: null,\n\t\tstop: null\n\t},\n\t_create: function() {\n\n\t\tif ( this.options.helper === "original" ) {\n\t\t\tthis._setPositionRelative();\n\t\t}\n\t\tif (this.options.addClasses){\n\t\t\tthis.element.addClass("ui-draggable");\n\t\t}\n\t\tif (this.options.disabled){\n\t\t\tthis.element.addClass("ui-draggable-disabled");\n\t\t}\n\t\tthis._setHandleClassName();\n\n\t\tthis._mouseInit();\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tthis._super( key, value );\n\t\tif ( key === "handle" ) {\n\t\t\tthis._removeHandleClassName();\n\t\t\tthis._setHandleClassName();\n\t\t}\n\t},\n\n\t_destroy: function() {\n\t\tif ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {\n\t\t\tthis.destroyOnClear = true;\n\t\t\treturn;\n\t\t}\n\t\tthis.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );\n\t\tthis._removeHandleClassName();\n\t\tthis._mouseDestroy();\n\t},\n\n\t_mouseCapture: function(event) {\n\t\tvar o = this.options;\n\n\t\tthis._blurActiveElement( event );\n\n\t\t// among others, prevent a drag on a resizable-handle\n\t\tif (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t//Quit if we\'re not on a valid handle\n\t\tthis.handle = this._getHandle(event);\n\t\tif (!this.handle) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );\n\n\t\treturn true;\n\n\t},\n\n\t_blockFrames: function( selector ) {\n\t\tthis.iframeBlocks = this.document.find( selector ).map(function() {\n\t\t\tvar iframe = $( this );\n\n\t\t\treturn $( "<div>" )\n\t\t\t\t.css( "position", "absolute" )\n\t\t\t\t.appendTo( iframe.parent() )\n\t\t\t\t.outerWidth( iframe.outerWidth() )\n\t\t\t\t.outerHeight( iframe.outerHeight() )\n\t\t\t\t.offset( iframe.offset() )[ 0 ];\n\t\t});\n\t},\n\n\t_unblockFrames: function() {\n\t\tif ( this.iframeBlocks ) {\n\t\t\tthis.iframeBlocks.remove();\n\t\t\tdelete this.iframeBlocks;\n\t\t}\n\t},\n\n\t_blurActiveElement: function( event ) {\n\t\tvar document = this.document[ 0 ];\n\n\t\t// Only need to blur if the event occurred on the draggable itself, see #10527\n\t\tif ( !this.handleElement.is( event.target ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// support: IE9\n\t\t// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>\n\t\ttry {\n\n\t\t\t// Support: IE9, IE10\n\t\t\t// If the <body> is blurred, IE will switch windows, see #9520\n\t\t\tif ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {\n\n\t\t\t\t// Blur any element that currently has focus, see #4261\n\t\t\t\t$( document.activeElement ).blur();\n\t\t\t}\n\t\t} catch ( error ) {}\n\t},\n\n\t_mouseStart: function(event) {\n\n\t\tvar o = this.options;\n\n\t\t//Create and append the visible helper\n\t\tthis.helper = this._createHelper(event);\n\n\t\tthis.helper.addClass("ui-draggable-dragging");\n\n\t\t//Cache the helper size\n\t\tthis._cacheHelperProportions();\n\n\t\t//If ddmanager is used for droppables, set the global draggable\n\t\tif ($.ui.ddmanager) {\n\t\t\t$.ui.ddmanager.current = this;\n\t\t}\n\n\t\t/*\n\t\t * - Position generation -\n\t\t * This block generates everything position related - it\'s the core of draggables.\n\t\t */\n\n\t\t//Cache the margins of the original element\n\t\tthis._cacheMargins();\n\n\t\t//Store the helper\'s css position\n\t\tthis.cssPosition = this.helper.css( "position" );\n\t\tthis.scrollParent = this.helper.scrollParent( true );\n\t\tthis.offsetParent = this.helper.offsetParent();\n\t\tthis.hasFixedAncestor = this.helper.parents().filter(function() {\n\t\t\t\treturn $( this ).css( "position" ) === "fixed";\n\t\t\t}).length > 0;\n\n\t\t//The element\'s absolute position on the page minus margins\n\t\tthis.positionAbs = this.element.offset();\n\t\tthis._refreshOffsets( event );\n\n\t\t//Generate the original position\n\t\tthis.originalPosition = this.position = this._generatePosition( event, false );\n\t\tthis.originalPageX = event.pageX;\n\t\tthis.originalPageY = event.pageY;\n\n\t\t//Adjust the mouse offset relative to the helper if "cursorAt" is supplied\n\t\t(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n\t\t//Set a containment if given in the options\n\t\tthis._setContainment();\n\n\t\t//Trigger event + callbacks\n\t\tif (this._trigger("start", event) === false) {\n\t\t\tthis._clear();\n\t\t\treturn false;\n\t\t}\n\n\t\t//Recache the helper size\n\t\tthis._cacheHelperProportions();\n\n\t\t//Prepare the droppable offsets\n\t\tif ($.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t}\n\n\t\t// Reset helper\'s right/bottom css if they\'re set and set explicit width/height instead\n\t\t// as this prevents resizing of elements with right/bottom set (see #7772)\n\t\tthis._normalizeRightBottom();\n\n\t\tthis._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\n\t\t//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\n\t\tif ( $.ui.ddmanager ) {\n\t\t\t$.ui.ddmanager.dragStart(this, event);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t_refreshOffsets: function( event ) {\n\t\tthis.offset = {\n\t\t\ttop: this.positionAbs.top - this.margins.top,\n\t\t\tleft: this.positionAbs.left - this.margins.left,\n\t\t\tscroll: false,\n\t\t\tparent: this._getParentOffset(),\n\t\t\trelative: this._getRelativeOffset()\n\t\t};\n\n\t\tthis.offset.click = {\n\t\t\tleft: event.pageX - this.offset.left,\n\t\t\ttop: event.pageY - this.offset.top\n\t\t};\n\t},\n\n\t_mouseDrag: function(event, noPropagation) {\n\t\t// reset any necessary cached properties (see #5009)\n\t\tif ( this.hasFixedAncestor ) {\n\t\t\tthis.offset.parent = this._getParentOffset();\n\t\t}\n\n\t\t//Compute the helpers position\n\t\tthis.position = this._generatePosition( event, true );\n\t\tthis.positionAbs = this._convertPositionTo("absolute");\n\n\t\t//Call plugins and callbacks and use the resulting position if something is returned\n\t\tif (!noPropagation) {\n\t\t\tvar ui = this._uiHash();\n\t\t\tif (this._trigger("drag", event, ui) === false) {\n\t\t\t\tthis._mouseUp({});\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.position = ui.position;\n\t\t}\n\n\t\tthis.helper[ 0 ].style.left = this.position.left + "px";\n\t\tthis.helper[ 0 ].style.top = this.position.top + "px";\n\n\t\tif ($.ui.ddmanager) {\n\t\t\t$.ui.ddmanager.drag(this, event);\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_mouseStop: function(event) {\n\n\t\t//If we are using droppables, inform the manager about the drop\n\t\tvar that = this,\n\t\t\tdropped = false;\n\t\tif ($.ui.ddmanager && !this.options.dropBehaviour) {\n\t\t\tdropped = $.ui.ddmanager.drop(this, event);\n\t\t}\n\n\t\t//if a drop comes from outside (a sortable)\n\t\tif (this.dropped) {\n\t\t\tdropped = this.dropped;\n\t\t\tthis.dropped = false;\n\t\t}\n\n\t\tif ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {\n\t\t\t$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {\n\t\t\t\tif (that._trigger("stop", event) !== false) {\n\t\t\t\t\tthat._clear();\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tif (this._trigger("stop", event) !== false) {\n\t\t\t\tthis._clear();\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_mouseUp: function( event ) {\n\t\tthis._unblockFrames();\n\n\t\t//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\n\t\tif ( $.ui.ddmanager ) {\n\t\t\t$.ui.ddmanager.dragStop(this, event);\n\t\t}\n\n\t\t// Only need to focus if the event occurred on the draggable itself, see #10527\n\t\tif ( this.handleElement.is( event.target ) ) {\n\t\t\t// The interaction is over; whether or not the click resulted in a drag, focus the element\n\t\t\tthis.element.focus();\n\t\t}\n\n\t\treturn $.ui.mouse.prototype._mouseUp.call(this, event);\n\t},\n\n\tcancel: function() {\n\n\t\tif (this.helper.is(".ui-draggable-dragging")) {\n\t\t\tthis._mouseUp({});\n\t\t} else {\n\t\t\tthis._clear();\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t_getHandle: function(event) {\n\t\treturn this.options.handle ?\n\t\t\t!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :\n\t\t\ttrue;\n\t},\n\n\t_setHandleClassName: function() {\n\t\tthis.handleElement = this.options.handle ?\n\t\t\tthis.element.find( this.options.handle ) : this.element;\n\t\tthis.handleElement.addClass( "ui-draggable-handle" );\n\t},\n\n\t_removeHandleClassName: function() {\n\t\tthis.handleElement.removeClass( "ui-draggable-handle" );\n\t},\n\n\t_createHelper: function(event) {\n\n\t\tvar o = this.options,\n\t\t\thelperIsFunction = $.isFunction( o.helper ),\n\t\t\thelper = helperIsFunction ?\n\t\t\t\t$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :\n\t\t\t\t( o.helper === "clone" ?\n\t\t\t\t\tthis.element.clone().removeAttr( "id" ) :\n\t\t\t\t\tthis.element );\n\n\t\tif (!helper.parents("body").length) {\n\t\t\thelper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));\n\t\t}\n\n\t\t// http://bugs.jqueryui.com/ticket/9446\n\t\t// a helper function can return the original element\n\t\t// which wouldn\'t have been set to relative in _create\n\t\tif ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {\n\t\t\tthis._setPositionRelative();\n\t\t}\n\n\t\tif (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {\n\t\t\thelper.css("position", "absolute");\n\t\t}\n\n\t\treturn helper;\n\n\t},\n\n\t_setPositionRelative: function() {\n\t\tif ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {\n\t\t\tthis.element[ 0 ].style.position = "relative";\n\t\t}\n\t},\n\n\t_adjustOffsetFromHelper: function(obj) {\n\t\tif (typeof obj === "string") {\n\t\t\tobj = obj.split(" ");\n\t\t}\n\t\tif ($.isArray(obj)) {\n\t\t\tobj = { left: +obj[0], top: +obj[1] || 0 };\n\t\t}\n\t\tif ("left" in obj) {\n\t\t\tthis.offset.click.left = obj.left + this.margins.left;\n\t\t}\n\t\tif ("right" in obj) {\n\t\t\tthis.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n\t\t}\n\t\tif ("top" in obj) {\n\t\t\tthis.offset.click.top = obj.top + this.margins.top;\n\t\t}\n\t\tif ("bottom" in obj) {\n\t\t\tthis.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n\t\t}\n\t},\n\n\t_isRootNode: function( element ) {\n\t\treturn ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];\n\t},\n\n\t_getParentOffset: function() {\n\n\t\t//Get the offsetParent and cache its position\n\t\tvar po = this.offsetParent.offset(),\n\t\t\tdocument = this.document[ 0 ];\n\n\t\t// This is a special case where we need to modify a offset calculated on start, since the following happened:\n\t\t// 1. The position of the helper is absolute, so it\'s position is calculated based on the next positioned parent\n\t\t// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn\'t the document, which means that\n\t\t//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n\t\tif (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n\t\t\tpo.left += this.scrollParent.scrollLeft();\n\t\t\tpo.top += this.scrollParent.scrollTop();\n\t\t}\n\n\t\tif ( this._isRootNode( this.offsetParent[ 0 ] ) ) {\n\t\t\tpo = { top: 0, left: 0 };\n\t\t}\n\n\t\treturn {\n\t\t\ttop: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),\n\t\t\tleft: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)\n\t\t};\n\n\t},\n\n\t_getRelativeOffset: function() {\n\t\tif ( this.cssPosition !== "relative" ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\tvar p = this.element.position(),\n\t\t\tscrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );\n\n\t\treturn {\n\t\t\ttop: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),\n\t\t\tleft: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )\n\t\t};\n\n\t},\n\n\t_cacheMargins: function() {\n\t\tthis.margins = {\n\t\t\tleft: (parseInt(this.element.css("marginLeft"), 10) || 0),\n\t\t\ttop: (parseInt(this.element.css("marginTop"), 10) || 0),\n\t\t\tright: (parseInt(this.element.css("marginRight"), 10) || 0),\n\t\t\tbottom: (parseInt(this.element.css("marginBottom"), 10) || 0)\n\t\t};\n\t},\n\n\t_cacheHelperProportions: function() {\n\t\tthis.helperProportions = {\n\t\t\twidth: this.helper.outerWidth(),\n\t\t\theight: this.helper.outerHeight()\n\t\t};\n\t},\n\n\t_setContainment: function() {\n\n\t\tvar isUserScrollable, c, ce,\n\t\t\to = this.options,\n\t\t\tdocument = this.document[ 0 ];\n\n\t\tthis.relativeContainer = null;\n\n\t\tif ( !o.containment ) {\n\t\t\tthis.containment = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( o.containment === "window" ) {\n\t\t\tthis.containment = [\n\t\t\t\t$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,\n\t\t\t\t$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,\n\t\t\t\t$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,\n\t\t\t\t$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\n\t\t\t];\n\t\t\treturn;\n\t\t}\n\n\t\tif ( o.containment === "document") {\n\t\t\tthis.containment = [\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t$( document ).width() - this.helperProportions.width - this.margins.left,\n\t\t\t\t( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\n\t\t\t];\n\t\t\treturn;\n\t\t}\n\n\t\tif ( o.containment.constructor === Array ) {\n\t\t\tthis.containment = o.containment;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( o.containment === "parent" ) {\n\t\t\to.containment = this.helper[ 0 ].parentNode;\n\t\t}\n\n\t\tc = $( o.containment );\n\t\tce = c[ 0 ];\n\n\t\tif ( !ce ) {\n\t\t\treturn;\n\t\t}\n\n\t\tisUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );\n\n\t\tthis.containment = [\n\t\t\t( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),\n\t\t\t( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),\n\t\t\t( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -\n\t\t\t\t( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -\n\t\t\t\t( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -\n\t\t\t\tthis.helperProportions.width -\n\t\t\t\tthis.margins.left -\n\t\t\t\tthis.margins.right,\n\t\t\t( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -\n\t\t\t\t( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -\n\t\t\t\t( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -\n\t\t\t\tthis.helperProportions.height -\n\t\t\t\tthis.margins.top -\n\t\t\t\tthis.margins.bottom\n\t\t];\n\t\tthis.relativeContainer = c;\n\t},\n\n\t_convertPositionTo: function(d, pos) {\n\n\t\tif (!pos) {\n\t\t\tpos = this.position;\n\t\t}\n\n\t\tvar mod = d === "absolute" ? 1 : -1,\n\t\t\tscrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );\n\n\t\treturn {\n\t\t\ttop: (\n\t\t\t\tpos.top\t+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.relative.top * mod +\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top * mod -\t\t\t\t\t\t\t\t\t\t// The offsetParent\'s offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)\n\t\t\t),\n\t\t\tleft: (\n\t\t\t\tpos.left +\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.relative.left * mod +\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left * mod\t-\t\t\t\t\t\t\t\t\t\t// The offsetParent\'s offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)\n\t\t\t)\n\t\t};\n\n\t},\n\n\t_generatePosition: function( event, constrainPosition ) {\n\n\t\tvar containment, co, top, left,\n\t\t\to = this.options,\n\t\t\tscrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),\n\t\t\tpageX = event.pageX,\n\t\t\tpageY = event.pageY;\n\n\t\t// Cache the scroll\n\t\tif ( !scrollIsRootNode || !this.offset.scroll ) {\n\t\t\tthis.offset.scroll = {\n\t\t\t\ttop: this.scrollParent.scrollTop(),\n\t\t\t\tleft: this.scrollParent.scrollLeft()\n\t\t\t};\n\t\t}\n\n\t\t/*\n\t\t * - Position constraining -\n\t\t * Constrain the position to a mix of grid, containment.\n\t\t */\n\n\t\t// If we are not dragging yet, we won\'t check for options\n\t\tif ( constrainPosition ) {\n\t\t\tif ( this.containment ) {\n\t\t\t\tif ( this.relativeContainer ){\n\t\t\t\t\tco = this.relativeContainer.offset();\n\t\t\t\t\tcontainment = [\n\t\t\t\t\t\tthis.containment[ 0 ] + co.left,\n\t\t\t\t\t\tthis.containment[ 1 ] + co.top,\n\t\t\t\t\t\tthis.containment[ 2 ] + co.left,\n\t\t\t\t\t\tthis.containment[ 3 ] + co.top\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tcontainment = this.containment;\n\t\t\t\t}\n\n\t\t\t\tif (event.pageX - this.offset.click.left < containment[0]) {\n\t\t\t\t\tpageX = containment[0] + this.offset.click.left;\n\t\t\t\t}\n\t\t\t\tif (event.pageY - this.offset.click.top < containment[1]) {\n\t\t\t\t\tpageY = containment[1] + this.offset.click.top;\n\t\t\t\t}\n\t\t\t\tif (event.pageX - this.offset.click.left > containment[2]) {\n\t\t\t\t\tpageX = containment[2] + this.offset.click.left;\n\t\t\t\t}\n\t\t\t\tif (event.pageY - this.offset.click.top > containment[3]) {\n\t\t\t\t\tpageY = containment[3] + this.offset.click.top;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (o.grid) {\n\t\t\t\t//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\n\t\t\t\ttop = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\n\t\t\t\tpageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n\t\t\t\tleft = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\n\t\t\t\tpageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n\t\t\t}\n\n\t\t\tif ( o.axis === "y" ) {\n\t\t\t\tpageX = this.originalPageX;\n\t\t\t}\n\n\t\t\tif ( o.axis === "x" ) {\n\t\t\t\tpageY = this.originalPageY;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttop: (\n\t\t\t\tpageY -\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.click.top\t-\t\t\t\t\t\t\t\t\t\t\t\t// Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.top -\t\t\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top +\t\t\t\t\t\t\t\t\t\t\t\t// The offsetParent\'s offset without borders (offset + border)\n\t\t\t\t( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )\n\t\t\t),\n\t\t\tleft: (\n\t\t\t\tpageX -\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.click.left -\t\t\t\t\t\t\t\t\t\t\t\t// Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.left -\t\t\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left +\t\t\t\t\t\t\t\t\t\t\t\t// The offsetParent\'s offset without borders (offset + border)\n\t\t\t\t( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )\n\t\t\t)\n\t\t};\n\n\t},\n\n\t_clear: function() {\n\t\tthis.helper.removeClass("ui-draggable-dragging");\n\t\tif (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {\n\t\t\tthis.helper.remove();\n\t\t}\n\t\tthis.helper = null;\n\t\tthis.cancelHelperRemoval = false;\n\t\tif ( this.destroyOnClear ) {\n\t\t\tthis.destroy();\n\t\t}\n\t},\n\n\t_normalizeRightBottom: function() {\n\t\tif ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {\n\t\t\tthis.helper.width( this.helper.width() );\n\t\t\tthis.helper.css( "right", "auto" );\n\t\t}\n\t\tif ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {\n\t\t\tthis.helper.height( this.helper.height() );\n\t\t\tthis.helper.css( "bottom", "auto" );\n\t\t}\n\t},\n\n\t// From now on bulk stuff - mainly helpers\n\n\t_trigger: function( type, event, ui ) {\n\t\tui = ui || this._uiHash();\n\t\t$.ui.plugin.call( this, type, [ event, ui, this ], true );\n\n\t\t// Absolute position and offset (see #6884 ) have to be recalculated after plugins\n\t\tif ( /^(drag|start|stop)/.test( type ) ) {\n\t\t\tthis.positionAbs = this._convertPositionTo( "absolute" );\n\t\t\tui.offset = this.positionAbs;\n\t\t}\n\t\treturn $.Widget.prototype._trigger.call( this, type, event, ui );\n\t},\n\n\tplugins: {},\n\n\t_uiHash: function() {\n\t\treturn {\n\t\t\thelper: this.helper,\n\t\t\tposition: this.position,\n\t\t\toriginalPosition: this.originalPosition,\n\t\t\toffset: this.positionAbs\n\t\t};\n\t}\n\n});\n\n$.ui.plugin.add( "draggable", "connectToSortable", {\n\tstart: function( event, ui, draggable ) {\n\t\tvar uiSortable = $.extend( {}, ui, {\n\t\t\titem: draggable.element\n\t\t});\n\n\t\tdraggable.sortables = [];\n\t\t$( draggable.options.connectToSortable ).each(function() {\n\t\t\tvar sortable = $( this ).sortable( "instance" );\n\n\t\t\tif ( sortable && !sortable.options.disabled ) {\n\t\t\t\tdraggable.sortables.push( sortable );\n\n\t\t\t\t// refreshPositions is called at drag start to refresh the containerCache\n\t\t\t\t// which is used in drag. This ensures it\'s initialized and synchronized\n\t\t\t\t// with any changes that might have happened on the page since initialization.\n\t\t\t\tsortable.refreshPositions();\n\t\t\t\tsortable._trigger("activate", event, uiSortable);\n\t\t\t}\n\t\t});\n\t},\n\tstop: function( event, ui, draggable ) {\n\t\tvar uiSortable = $.extend( {}, ui, {\n\t\t\titem: draggable.element\n\t\t});\n\n\t\tdraggable.cancelHelperRemoval = false;\n\n\t\t$.each( draggable.sortables, function() {\n\t\t\tvar sortable = this;\n\n\t\t\tif ( sortable.isOver ) {\n\t\t\t\tsortable.isOver = 0;\n\n\t\t\t\t// Allow this sortable to handle removing the helper\n\t\t\t\tdraggable.cancelHelperRemoval = true;\n\t\t\t\tsortable.cancelHelperRemoval = false;\n\n\t\t\t\t// Use _storedCSS To restore properties in the sortable,\n\t\t\t\t// as this also handles revert (#9675) since the draggable\n\t\t\t\t// may have modified them in unexpected ways (#8809)\n\t\t\t\tsortable._storedCSS = {\n\t\t\t\t\tposition: sortable.placeholder.css( "position" ),\n\t\t\t\t\ttop: sortable.placeholder.css( "top" ),\n\t\t\t\t\tleft: sortable.placeholder.css( "left" )\n\t\t\t\t};\n\n\t\t\t\tsortable._mouseStop(event);\n\n\t\t\t\t// Once drag has ended, the sortable should return to using\n\t\t\t\t// its original helper, not the shared helper from draggable\n\t\t\t\tsortable.options.helper = sortable.options._helper;\n\t\t\t} else {\n\t\t\t\t// Prevent this Sortable from removing the helper.\n\t\t\t\t// However, don\'t set the draggable to remove the helper\n\t\t\t\t// either as another connected Sortable may yet handle the removal.\n\t\t\t\tsortable.cancelHelperRemoval = true;\n\n\t\t\t\tsortable._trigger( "deactivate", event, uiSortable );\n\t\t\t}\n\t\t});\n\t},\n\tdrag: function( event, ui, draggable ) {\n\t\t$.each( draggable.sortables, function() {\n\t\t\tvar innermostIntersecting = false,\n\t\t\t\tsortable = this;\n\n\t\t\t// Copy over variables that sortable\'s _intersectsWith uses\n\t\t\tsortable.positionAbs = draggable.positionAbs;\n\t\t\tsortable.helperProportions = draggable.helperProportions;\n\t\t\tsortable.offset.click = draggable.offset.click;\n\n\t\t\tif ( sortable._intersectsWith( sortable.containerCache ) ) {\n\t\t\t\tinnermostIntersecting = true;\n\n\t\t\t\t$.each( draggable.sortables, function() {\n\t\t\t\t\t// Copy over variables that sortable\'s _intersectsWith uses\n\t\t\t\t\tthis.positionAbs = draggable.positionAbs;\n\t\t\t\t\tthis.helperProportions = draggable.helperProportions;\n\t\t\t\t\tthis.offset.click = draggable.offset.click;\n\n\t\t\t\t\tif ( this !== sortable &&\n\t\t\t\t\t\t\tthis._intersectsWith( this.containerCache ) &&\n\t\t\t\t\t\t\t$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {\n\t\t\t\t\t\tinnermostIntersecting = false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn innermostIntersecting;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( innermostIntersecting ) {\n\t\t\t\t// If it intersects, we use a little isOver variable and set it once,\n\t\t\t\t// so that the move-in stuff gets fired only once.\n\t\t\t\tif ( !sortable.isOver ) {\n\t\t\t\t\tsortable.isOver = 1;\n\n\t\t\t\t\t// Store draggable\'s parent in case we need to reappend to it later.\n\t\t\t\t\tdraggable._parent = ui.helper.parent();\n\n\t\t\t\t\tsortable.currentItem = ui.helper\n\t\t\t\t\t\t.appendTo( sortable.element )\n\t\t\t\t\t\t.data( "ui-sortable-item", true );\n\n\t\t\t\t\t// Store helper option to later restore it\n\t\t\t\t\tsortable.options._helper = sortable.options.helper;\n\n\t\t\t\t\tsortable.options.helper = function() {\n\t\t\t\t\t\treturn ui.helper[ 0 ];\n\t\t\t\t\t};\n\n\t\t\t\t\t// Fire the start events of the sortable with our passed browser event,\n\t\t\t\t\t// and our own helper (so it doesn\'t create a new one)\n\t\t\t\t\tevent.target = sortable.currentItem[ 0 ];\n\t\t\t\t\tsortable._mouseCapture( event, true );\n\t\t\t\t\tsortable._mouseStart( event, true, true );\n\n\t\t\t\t\t// Because the browser event is way off the new appended portlet,\n\t\t\t\t\t// modify necessary variables to reflect the changes\n\t\t\t\t\tsortable.offset.click.top = draggable.offset.click.top;\n\t\t\t\t\tsortable.offset.click.left = draggable.offset.click.left;\n\t\t\t\t\tsortable.offset.parent.left -= draggable.offset.parent.left -\n\t\t\t\t\t\tsortable.offset.parent.left;\n\t\t\t\t\tsortable.offset.parent.top -= draggable.offset.parent.top -\n\t\t\t\t\t\tsortable.offset.parent.top;\n\n\t\t\t\t\tdraggable._trigger( "toSortable", event );\n\n\t\t\t\t\t// Inform draggable that the helper is in a valid drop zone,\n\t\t\t\t\t// used solely in the revert option to handle "valid/invalid".\n\t\t\t\t\tdraggable.dropped = sortable.element;\n\n\t\t\t\t\t// Need to refreshPositions of all sortables in the case that\n\t\t\t\t\t// adding to one sortable changes the location of the other sortables (#9675)\n\t\t\t\t\t$.each( draggable.sortables, function() {\n\t\t\t\t\t\tthis.refreshPositions();\n\t\t\t\t\t});\n\n\t\t\t\t\t// hack so receive/update callbacks work (mostly)\n\t\t\t\t\tdraggable.currentItem = draggable.element;\n\t\t\t\t\tsortable.fromOutside = draggable;\n\t\t\t\t}\n\n\t\t\t\tif ( sortable.currentItem ) {\n\t\t\t\t\tsortable._mouseDrag( event );\n\t\t\t\t\t// Copy the sortable\'s position because the draggable\'s can potentially reflect\n\t\t\t\t\t// a relative position, while sortable is always absolute, which the dragged\n\t\t\t\t\t// element has now become. (#8809)\n\t\t\t\t\tui.position = sortable.position;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If it doesn\'t intersect with the sortable, and it intersected before,\n\t\t\t\t// we fake the drag stop of the sortable, but make sure it doesn\'t remove\n\t\t\t\t// the helper by using cancelHelperRemoval.\n\t\t\t\tif ( sortable.isOver ) {\n\n\t\t\t\t\tsortable.isOver = 0;\n\t\t\t\t\tsortable.cancelHelperRemoval = true;\n\n\t\t\t\t\t// Calling sortable\'s mouseStop would trigger a revert,\n\t\t\t\t\t// so revert must be temporarily false until after mouseStop is called.\n\t\t\t\t\tsortable.options._revert = sortable.options.revert;\n\t\t\t\t\tsortable.options.revert = false;\n\n\t\t\t\t\tsortable._trigger( "out", event, sortable._uiHash( sortable ) );\n\t\t\t\t\tsortable._mouseStop( event, true );\n\n\t\t\t\t\t// restore sortable behaviors that were modfied\n\t\t\t\t\t// when the draggable entered the sortable area (#9481)\n\t\t\t\t\tsortable.options.revert = sortable.options._revert;\n\t\t\t\t\tsortable.options.helper = sortable.options._helper;\n\n\t\t\t\t\tif ( sortable.placeholder ) {\n\t\t\t\t\t\tsortable.placeholder.remove();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Restore and recalculate the draggable\'s offset considering the sortable\n\t\t\t\t\t// may have modified them in unexpected ways. (#8809, #10669)\n\t\t\t\t\tui.helper.appendTo( draggable._parent );\n\t\t\t\t\tdraggable._refreshOffsets( event );\n\t\t\t\t\tui.position = draggable._generatePosition( event, true );\n\n\t\t\t\t\tdraggable._trigger( "fromSortable", event );\n\n\t\t\t\t\t// Inform draggable that the helper is no longer in a valid drop zone\n\t\t\t\t\tdraggable.dropped = false;\n\n\t\t\t\t\t// Need to refreshPositions of all sortables just in case removing\n\t\t\t\t\t// from one sortable changes the location of other sortables (#9675)\n\t\t\t\t\t$.each( draggable.sortables, function() {\n\t\t\t\t\t\tthis.refreshPositions();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\n$.ui.plugin.add("draggable", "cursor", {\n\tstart: function( event, ui, instance ) {\n\t\tvar t = $( "body" ),\n\t\t\to = instance.options;\n\n\t\tif (t.css("cursor")) {\n\t\t\to._cursor = t.css("cursor");\n\t\t}\n\t\tt.css("cursor", o.cursor);\n\t},\n\tstop: function( event, ui, instance ) {\n\t\tvar o = instance.options;\n\t\tif (o._cursor) {\n\t\t\t$("body").css("cursor", o._cursor);\n\t\t}\n\t}\n});\n\n$.ui.plugin.add("draggable", "opacity", {\n\tstart: function( event, ui, instance ) {\n\t\tvar t = $( ui.helper ),\n\t\t\to = instance.options;\n\t\tif (t.css("opacity")) {\n\t\t\to._opacity = t.css("opacity");\n\t\t}\n\t\tt.css("opacity", o.opacity);\n\t},\n\tstop: function( event, ui, instance ) {\n\t\tvar o = instance.options;\n\t\tif (o._opacity) {\n\t\t\t$(ui.helper).css("opacity", o._opacity);\n\t\t}\n\t}\n});\n\n$.ui.plugin.add("draggable", "scroll", {\n\tstart: function( event, ui, i ) {\n\t\tif ( !i.scrollParentNotHidden ) {\n\t\t\ti.scrollParentNotHidden = i.helper.scrollParent( false );\n\t\t}\n\n\t\tif ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {\n\t\t\ti.overflowOffset = i.scrollParentNotHidden.offset();\n\t\t}\n\t},\n\tdrag: function( event, ui, i  ) {\n\n\t\tvar o = i.options,\n\t\t\tscrolled = false,\n\t\t\tscrollParent = i.scrollParentNotHidden[ 0 ],\n\t\t\tdocument = i.document[ 0 ];\n\n\t\tif ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {\n\t\t\tif ( !o.axis || o.axis !== "x" ) {\n\t\t\t\tif ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {\n\t\t\t\t\tscrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;\n\t\t\t\t} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {\n\t\t\t\t\tscrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !o.axis || o.axis !== "y" ) {\n\t\t\t\tif ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {\n\t\t\t\t\tscrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;\n\t\t\t\t} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {\n\t\t\t\t\tscrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (!o.axis || o.axis !== "x") {\n\t\t\t\tif (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n\t\t\t\t} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!o.axis || o.axis !== "y") {\n\t\t\t\tif (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n\t\t\t\t} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t$.ui.ddmanager.prepareOffsets(i, event);\n\t\t}\n\n\t}\n});\n\n$.ui.plugin.add("draggable", "snap", {\n\tstart: function( event, ui, i ) {\n\n\t\tvar o = i.options;\n\n\t\ti.snapElements = [];\n\n\t\t$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {\n\t\t\tvar $t = $(this),\n\t\t\t\t$o = $t.offset();\n\t\t\tif (this !== i.element[0]) {\n\t\t\t\ti.snapElements.push({\n\t\t\t\t\titem: this,\n\t\t\t\t\twidth: $t.outerWidth(), height: $t.outerHeight(),\n\t\t\t\t\ttop: $o.top, left: $o.left\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t},\n\tdrag: function( event, ui, inst ) {\n\n\t\tvar ts, bs, ls, rs, l, r, t, b, i, first,\n\t\t\to = inst.options,\n\t\t\td = o.snapTolerance,\n\t\t\tx1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,\n\t\t\ty1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;\n\n\t\tfor (i = inst.snapElements.length - 1; i >= 0; i--){\n\n\t\t\tl = inst.snapElements[i].left - inst.margins.left;\n\t\t\tr = l + inst.snapElements[i].width;\n\t\t\tt = inst.snapElements[i].top - inst.margins.top;\n\t\t\tb = t + inst.snapElements[i].height;\n\n\t\t\tif ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {\n\t\t\t\tif (inst.snapElements[i].snapping) {\n\t\t\t\t\t(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n\t\t\t\t}\n\t\t\t\tinst.snapElements[i].snapping = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (o.snapMode !== "inner") {\n\t\t\t\tts = Math.abs(t - y2) <= d;\n\t\t\t\tbs = Math.abs(b - y1) <= d;\n\t\t\t\tls = Math.abs(l - x2) <= d;\n\t\t\t\trs = Math.abs(r - x1) <= d;\n\t\t\t\tif (ts) {\n\t\t\t\t\tui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;\n\t\t\t\t}\n\t\t\t\tif (bs) {\n\t\t\t\t\tui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;\n\t\t\t\t}\n\t\t\t\tif (ls) {\n\t\t\t\t\tui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;\n\t\t\t\t}\n\t\t\t\tif (rs) {\n\t\t\t\t\tui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfirst = (ts || bs || ls || rs);\n\n\t\t\tif (o.snapMode !== "outer") {\n\t\t\t\tts = Math.abs(t - y1) <= d;\n\t\t\t\tbs = Math.abs(b - y2) <= d;\n\t\t\t\tls = Math.abs(l - x1) <= d;\n\t\t\t\trs = Math.abs(r - x2) <= d;\n\t\t\t\tif (ts) {\n\t\t\t\t\tui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;\n\t\t\t\t}\n\t\t\t\tif (bs) {\n\t\t\t\t\tui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;\n\t\t\t\t}\n\t\t\t\tif (ls) {\n\t\t\t\t\tui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;\n\t\t\t\t}\n\t\t\t\tif (rs) {\n\t\t\t\t\tui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {\n\t\t\t\t(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n\t\t\t}\n\t\t\tinst.snapElements[i].snapping = (ts || bs || ls || rs || first);\n\n\t\t}\n\n\t}\n});\n\n$.ui.plugin.add("draggable", "stack", {\n\tstart: function( event, ui, instance ) {\n\t\tvar min,\n\t\t\to = instance.options,\n\t\t\tgroup = $.makeArray($(o.stack)).sort(function(a, b) {\n\t\t\t\treturn (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);\n\t\t\t});\n\n\t\tif (!group.length) { return; }\n\n\t\tmin = parseInt($(group[0]).css("zIndex"), 10) || 0;\n\t\t$(group).each(function(i) {\n\t\t\t$(this).css("zIndex", min + i);\n\t\t});\n\t\tthis.css("zIndex", (min + group.length));\n\t}\n});\n\n$.ui.plugin.add("draggable", "zIndex", {\n\tstart: function( event, ui, instance ) {\n\t\tvar t = $( ui.helper ),\n\t\t\to = instance.options;\n\n\t\tif (t.css("zIndex")) {\n\t\t\to._zIndex = t.css("zIndex");\n\t\t}\n\t\tt.css("zIndex", o.zIndex);\n\t},\n\tstop: function( event, ui, instance ) {\n\t\tvar o = instance.options;\n\n\t\tif (o._zIndex) {\n\t\t\t$(ui.helper).css("zIndex", o._zIndex);\n\t\t}\n\t}\n});\n\nvar draggable = $.ui.draggable;\n\n\n/*!\n * jQuery UI Resizable 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/resizable/\n */\n\n\n$.widget("ui.resizable", $.ui.mouse, {\n\tversion: "1.11.4",\n\twidgetEventPrefix: "resize",\n\toptions: {\n\t\talsoResize: false,\n\t\tanimate: false,\n\t\tanimateDuration: "slow",\n\t\tanimateEasing: "swing",\n\t\taspectRatio: false,\n\t\tautoHide: false,\n\t\tcontainment: false,\n\t\tghost: false,\n\t\tgrid: false,\n\t\thandles: "e,s,se",\n\t\thelper: false,\n\t\tmaxHeight: null,\n\t\tmaxWidth: null,\n\t\tminHeight: 10,\n\t\tminWidth: 10,\n\t\t// See #7960\n\t\tzIndex: 90,\n\n\t\t// callbacks\n\t\tresize: null,\n\t\tstart: null,\n\t\tstop: null\n\t},\n\n\t_num: function( value ) {\n\t\treturn parseInt( value, 10 ) || 0;\n\t},\n\n\t_isNumber: function( value ) {\n\t\treturn !isNaN( parseInt( value, 10 ) );\n\t},\n\n\t_hasScroll: function( el, a ) {\n\n\t\tif ( $( el ).css( "overflow" ) === "hidden") {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",\n\t\t\thas = false;\n\n\t\tif ( el[ scroll ] > 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// TODO: determine which cases actually cause this to happen\n\t\t// if the element doesn\'t have the scroll set, see if it\'s possible to\n\t\t// set the scroll\n\t\tel[ scroll ] = 1;\n\t\thas = ( el[ scroll ] > 0 );\n\t\tel[ scroll ] = 0;\n\t\treturn has;\n\t},\n\n\t_create: function() {\n\n\t\tvar n, i, handle, axis, hname,\n\t\t\tthat = this,\n\t\t\to = this.options;\n\t\tthis.element.addClass("ui-resizable");\n\n\t\t$.extend(this, {\n\t\t\t_aspectRatio: !!(o.aspectRatio),\n\t\t\taspectRatio: o.aspectRatio,\n\t\t\toriginalElement: this.element,\n\t\t\t_proportionallyResizeElements: [],\n\t\t\t_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null\n\t\t});\n\n\t\t// Wrap the element if it cannot hold child nodes\n\t\tif (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {\n\n\t\t\tthis.element.wrap(\n\t\t\t\t$("<div class=\'ui-wrapper\' style=\'overflow: hidden;\'></div>").css({\n\t\t\t\t\tposition: this.element.css("position"),\n\t\t\t\t\twidth: this.element.outerWidth(),\n\t\t\t\t\theight: this.element.outerHeight(),\n\t\t\t\t\ttop: this.element.css("top"),\n\t\t\t\t\tleft: this.element.css("left")\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.element = this.element.parent().data(\n\t\t\t\t"ui-resizable", this.element.resizable( "instance" )\n\t\t\t);\n\n\t\t\tthis.elementIsWrapper = true;\n\n\t\t\tthis.element.css({\n\t\t\t\tmarginLeft: this.originalElement.css("marginLeft"),\n\t\t\t\tmarginTop: this.originalElement.css("marginTop"),\n\t\t\t\tmarginRight: this.originalElement.css("marginRight"),\n\t\t\t\tmarginBottom: this.originalElement.css("marginBottom")\n\t\t\t});\n\t\t\tthis.originalElement.css({\n\t\t\t\tmarginLeft: 0,\n\t\t\t\tmarginTop: 0,\n\t\t\t\tmarginRight: 0,\n\t\t\t\tmarginBottom: 0\n\t\t\t});\n\t\t\t// support: Safari\n\t\t\t// Prevent Safari textarea resize\n\t\t\tthis.originalResizeStyle = this.originalElement.css("resize");\n\t\t\tthis.originalElement.css("resize", "none");\n\n\t\t\tthis._proportionallyResizeElements.push( this.originalElement.css({\n\t\t\t\tposition: "static",\n\t\t\t\tzoom: 1,\n\t\t\t\tdisplay: "block"\n\t\t\t}) );\n\n\t\t\t// support: IE9\n\t\t\t// avoid IE jump (hard set the margin)\n\t\t\tthis.originalElement.css({ margin: this.originalElement.css("margin") });\n\n\t\t\tthis._proportionallyResize();\n\t\t}\n\n\t\tthis.handles = o.handles ||\n\t\t\t( !$(".ui-resizable-handle", this.element).length ?\n\t\t\t\t"e,s,se" : {\n\t\t\t\t\tn: ".ui-resizable-n",\n\t\t\t\t\te: ".ui-resizable-e",\n\t\t\t\t\ts: ".ui-resizable-s",\n\t\t\t\t\tw: ".ui-resizable-w",\n\t\t\t\t\tse: ".ui-resizable-se",\n\t\t\t\t\tsw: ".ui-resizable-sw",\n\t\t\t\t\tne: ".ui-resizable-ne",\n\t\t\t\t\tnw: ".ui-resizable-nw"\n\t\t\t\t} );\n\n\t\tthis._handles = $();\n\t\tif ( this.handles.constructor === String ) {\n\n\t\t\tif ( this.handles === "all") {\n\t\t\t\tthis.handles = "n,e,s,w,se,sw,ne,nw";\n\t\t\t}\n\n\t\t\tn = this.handles.split(",");\n\t\t\tthis.handles = {};\n\n\t\t\tfor (i = 0; i < n.length; i++) {\n\n\t\t\t\thandle = $.trim(n[i]);\n\t\t\t\thname = "ui-resizable-" + handle;\n\t\t\t\taxis = $("<div class=\'ui-resizable-handle " + hname + "\'></div>");\n\n\t\t\t\taxis.css({ zIndex: o.zIndex });\n\n\t\t\t\t// TODO : What\'s going on here?\n\t\t\t\tif ("se" === handle) {\n\t\t\t\t\taxis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");\n\t\t\t\t}\n\n\t\t\t\tthis.handles[handle] = ".ui-resizable-" + handle;\n\t\t\t\tthis.element.append(axis);\n\t\t\t}\n\n\t\t}\n\n\t\tthis._renderAxis = function(target) {\n\n\t\t\tvar i, axis, padPos, padWrapper;\n\n\t\t\ttarget = target || this.element;\n\n\t\t\tfor (i in this.handles) {\n\n\t\t\t\tif (this.handles[i].constructor === String) {\n\t\t\t\t\tthis.handles[i] = this.element.children( this.handles[ i ] ).first().show();\n\t\t\t\t} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {\n\t\t\t\t\tthis.handles[ i ] = $( this.handles[ i ] );\n\t\t\t\t\tthis._on( this.handles[ i ], { "mousedown": that._mouseDown });\n\t\t\t\t}\n\n\t\t\t\tif (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {\n\n\t\t\t\t\taxis = $(this.handles[i], this.element);\n\n\t\t\t\t\tpadWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();\n\n\t\t\t\t\tpadPos = [ "padding",\n\t\t\t\t\t\t/ne|nw|n/.test(i) ? "Top" :\n\t\t\t\t\t\t/se|sw|s/.test(i) ? "Bottom" :\n\t\t\t\t\t\t/^e$/.test(i) ? "Right" : "Left" ].join("");\n\n\t\t\t\t\ttarget.css(padPos, padWrapper);\n\n\t\t\t\t\tthis._proportionallyResize();\n\t\t\t\t}\n\n\t\t\t\tthis._handles = this._handles.add( this.handles[ i ] );\n\t\t\t}\n\t\t};\n\n\t\t// TODO: make renderAxis a prototype function\n\t\tthis._renderAxis(this.element);\n\n\t\tthis._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );\n\t\tthis._handles.disableSelection();\n\n\t\tthis._handles.mouseover(function() {\n\t\t\tif (!that.resizing) {\n\t\t\t\tif (this.className) {\n\t\t\t\t\taxis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);\n\t\t\t\t}\n\t\t\t\tthat.axis = axis && axis[1] ? axis[1] : "se";\n\t\t\t}\n\t\t});\n\n\t\tif (o.autoHide) {\n\t\t\tthis._handles.hide();\n\t\t\t$(this.element)\n\t\t\t\t.addClass("ui-resizable-autohide")\n\t\t\t\t.mouseenter(function() {\n\t\t\t\t\tif (o.disabled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t$(this).removeClass("ui-resizable-autohide");\n\t\t\t\t\tthat._handles.show();\n\t\t\t\t})\n\t\t\t\t.mouseleave(function() {\n\t\t\t\t\tif (o.disabled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!that.resizing) {\n\t\t\t\t\t\t$(this).addClass("ui-resizable-autohide");\n\t\t\t\t\t\tthat._handles.hide();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\n\t\tthis._mouseInit();\n\t},\n\n\t_destroy: function() {\n\n\t\tthis._mouseDestroy();\n\n\t\tvar wrapper,\n\t\t\t_destroy = function(exp) {\n\t\t\t\t$(exp)\n\t\t\t\t\t.removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")\n\t\t\t\t\t.removeData("resizable")\n\t\t\t\t\t.removeData("ui-resizable")\n\t\t\t\t\t.unbind(".resizable")\n\t\t\t\t\t.find(".ui-resizable-handle")\n\t\t\t\t\t\t.remove();\n\t\t\t};\n\n\t\t// TODO: Unwrap at same DOM position\n\t\tif (this.elementIsWrapper) {\n\t\t\t_destroy(this.element);\n\t\t\twrapper = this.element;\n\t\t\tthis.originalElement.css({\n\t\t\t\tposition: wrapper.css("position"),\n\t\t\t\twidth: wrapper.outerWidth(),\n\t\t\t\theight: wrapper.outerHeight(),\n\t\t\t\ttop: wrapper.css("top"),\n\t\t\t\tleft: wrapper.css("left")\n\t\t\t}).insertAfter( wrapper );\n\t\t\twrapper.remove();\n\t\t}\n\n\t\tthis.originalElement.css("resize", this.originalResizeStyle);\n\t\t_destroy(this.originalElement);\n\n\t\treturn this;\n\t},\n\n\t_mouseCapture: function(event) {\n\t\tvar i, handle,\n\t\t\tcapture = false;\n\n\t\tfor (i in this.handles) {\n\t\t\thandle = $(this.handles[i])[0];\n\t\t\tif (handle === event.target || $.contains(handle, event.target)) {\n\t\t\t\tcapture = true;\n\t\t\t}\n\t\t}\n\n\t\treturn !this.options.disabled && capture;\n\t},\n\n\t_mouseStart: function(event) {\n\n\t\tvar curleft, curtop, cursor,\n\t\t\to = this.options,\n\t\t\tel = this.element;\n\n\t\tthis.resizing = true;\n\n\t\tthis._renderProxy();\n\n\t\tcurleft = this._num(this.helper.css("left"));\n\t\tcurtop = this._num(this.helper.css("top"));\n\n\t\tif (o.containment) {\n\t\t\tcurleft += $(o.containment).scrollLeft() || 0;\n\t\t\tcurtop += $(o.containment).scrollTop() || 0;\n\t\t}\n\n\t\tthis.offset = this.helper.offset();\n\t\tthis.position = { left: curleft, top: curtop };\n\n\t\tthis.size = this._helper ? {\n\t\t\t\twidth: this.helper.width(),\n\t\t\t\theight: this.helper.height()\n\t\t\t} : {\n\t\t\t\twidth: el.width(),\n\t\t\t\theight: el.height()\n\t\t\t};\n\n\t\tthis.originalSize = this._helper ? {\n\t\t\t\twidth: el.outerWidth(),\n\t\t\t\theight: el.outerHeight()\n\t\t\t} : {\n\t\t\t\twidth: el.width(),\n\t\t\t\theight: el.height()\n\t\t\t};\n\n\t\tthis.sizeDiff = {\n\t\t\twidth: el.outerWidth() - el.width(),\n\t\t\theight: el.outerHeight() - el.height()\n\t\t};\n\n\t\tthis.originalPosition = { left: curleft, top: curtop };\n\t\tthis.originalMousePosition = { left: event.pageX, top: event.pageY };\n\n\t\tthis.aspectRatio = (typeof o.aspectRatio === "number") ?\n\t\t\to.aspectRatio :\n\t\t\t((this.originalSize.width / this.originalSize.height) || 1);\n\n\t\tcursor = $(".ui-resizable-" + this.axis).css("cursor");\n\t\t$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);\n\n\t\tel.addClass("ui-resizable-resizing");\n\t\tthis._propagate("start", event);\n\t\treturn true;\n\t},\n\n\t_mouseDrag: function(event) {\n\n\t\tvar data, props,\n\t\t\tsmp = this.originalMousePosition,\n\t\t\ta = this.axis,\n\t\t\tdx = (event.pageX - smp.left) || 0,\n\t\t\tdy = (event.pageY - smp.top) || 0,\n\t\t\ttrigger = this._change[a];\n\n\t\tthis._updatePrevProperties();\n\n\t\tif (!trigger) {\n\t\t\treturn false;\n\t\t}\n\n\t\tdata = trigger.apply(this, [ event, dx, dy ]);\n\n\t\tthis._updateVirtualBoundaries(event.shiftKey);\n\t\tif (this._aspectRatio || event.shiftKey) {\n\t\t\tdata = this._updateRatio(data, event);\n\t\t}\n\n\t\tdata = this._respectSize(data, event);\n\n\t\tthis._updateCache(data);\n\n\t\tthis._propagate("resize", event);\n\n\t\tprops = this._applyChanges();\n\n\t\tif ( !this._helper && this._proportionallyResizeElements.length ) {\n\t\t\tthis._proportionallyResize();\n\t\t}\n\n\t\tif ( !$.isEmptyObject( props ) ) {\n\t\t\tthis._updatePrevProperties();\n\t\t\tthis._trigger( "resize", event, this.ui() );\n\t\t\tthis._applyChanges();\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_mouseStop: function(event) {\n\n\t\tthis.resizing = false;\n\t\tvar pr, ista, soffseth, soffsetw, s, left, top,\n\t\t\to = this.options, that = this;\n\n\t\tif (this._helper) {\n\n\t\t\tpr = this._proportionallyResizeElements;\n\t\t\tista = pr.length && (/textarea/i).test(pr[0].nodeName);\n\t\t\tsoffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;\n\t\t\tsoffsetw = ista ? 0 : that.sizeDiff.width;\n\n\t\t\ts = {\n\t\t\t\twidth: (that.helper.width()  - soffsetw),\n\t\t\t\theight: (that.helper.height() - soffseth)\n\t\t\t};\n\t\t\tleft = (parseInt(that.element.css("left"), 10) +\n\t\t\t\t(that.position.left - that.originalPosition.left)) || null;\n\t\t\ttop = (parseInt(that.element.css("top"), 10) +\n\t\t\t\t(that.position.top - that.originalPosition.top)) || null;\n\n\t\t\tif (!o.animate) {\n\t\t\t\tthis.element.css($.extend(s, { top: top, left: left }));\n\t\t\t}\n\n\t\t\tthat.helper.height(that.size.height);\n\t\t\tthat.helper.width(that.size.width);\n\n\t\t\tif (this._helper && !o.animate) {\n\t\t\t\tthis._proportionallyResize();\n\t\t\t}\n\t\t}\n\n\t\t$("body").css("cursor", "auto");\n\n\t\tthis.element.removeClass("ui-resizable-resizing");\n\n\t\tthis._propagate("stop", event);\n\n\t\tif (this._helper) {\n\t\t\tthis.helper.remove();\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\t_updatePrevProperties: function() {\n\t\tthis.prevPosition = {\n\t\t\ttop: this.position.top,\n\t\t\tleft: this.position.left\n\t\t};\n\t\tthis.prevSize = {\n\t\t\twidth: this.size.width,\n\t\t\theight: this.size.height\n\t\t};\n\t},\n\n\t_applyChanges: function() {\n\t\tvar props = {};\n\n\t\tif ( this.position.top !== this.prevPosition.top ) {\n\t\t\tprops.top = this.position.top + "px";\n\t\t}\n\t\tif ( this.position.left !== this.prevPosition.left ) {\n\t\t\tprops.left = this.position.left + "px";\n\t\t}\n\t\tif ( this.size.width !== this.prevSize.width ) {\n\t\t\tprops.width = this.size.width + "px";\n\t\t}\n\t\tif ( this.size.height !== this.prevSize.height ) {\n\t\t\tprops.height = this.size.height + "px";\n\t\t}\n\n\t\tthis.helper.css( props );\n\n\t\treturn props;\n\t},\n\n\t_updateVirtualBoundaries: function(forceAspectRatio) {\n\t\tvar pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,\n\t\t\to = this.options;\n\n\t\tb = {\n\t\t\tminWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,\n\t\t\tmaxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,\n\t\t\tminHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,\n\t\t\tmaxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity\n\t\t};\n\n\t\tif (this._aspectRatio || forceAspectRatio) {\n\t\t\tpMinWidth = b.minHeight * this.aspectRatio;\n\t\t\tpMinHeight = b.minWidth / this.aspectRatio;\n\t\t\tpMaxWidth = b.maxHeight * this.aspectRatio;\n\t\t\tpMaxHeight = b.maxWidth / this.aspectRatio;\n\n\t\t\tif (pMinWidth > b.minWidth) {\n\t\t\t\tb.minWidth = pMinWidth;\n\t\t\t}\n\t\t\tif (pMinHeight > b.minHeight) {\n\t\t\t\tb.minHeight = pMinHeight;\n\t\t\t}\n\t\t\tif (pMaxWidth < b.maxWidth) {\n\t\t\t\tb.maxWidth = pMaxWidth;\n\t\t\t}\n\t\t\tif (pMaxHeight < b.maxHeight) {\n\t\t\t\tb.maxHeight = pMaxHeight;\n\t\t\t}\n\t\t}\n\t\tthis._vBoundaries = b;\n\t},\n\n\t_updateCache: function(data) {\n\t\tthis.offset = this.helper.offset();\n\t\tif (this._isNumber(data.left)) {\n\t\t\tthis.position.left = data.left;\n\t\t}\n\t\tif (this._isNumber(data.top)) {\n\t\t\tthis.position.top = data.top;\n\t\t}\n\t\tif (this._isNumber(data.height)) {\n\t\t\tthis.size.height = data.height;\n\t\t}\n\t\tif (this._isNumber(data.width)) {\n\t\t\tthis.size.width = data.width;\n\t\t}\n\t},\n\n\t_updateRatio: function( data ) {\n\n\t\tvar cpos = this.position,\n\t\t\tcsize = this.size,\n\t\t\ta = this.axis;\n\n\t\tif (this._isNumber(data.height)) {\n\t\t\tdata.width = (data.height * this.aspectRatio);\n\t\t} else if (this._isNumber(data.width)) {\n\t\t\tdata.height = (data.width / this.aspectRatio);\n\t\t}\n\n\t\tif (a === "sw") {\n\t\t\tdata.left = cpos.left + (csize.width - data.width);\n\t\t\tdata.top = null;\n\t\t}\n\t\tif (a === "nw") {\n\t\t\tdata.top = cpos.top + (csize.height - data.height);\n\t\t\tdata.left = cpos.left + (csize.width - data.width);\n\t\t}\n\n\t\treturn data;\n\t},\n\n\t_respectSize: function( data ) {\n\n\t\tvar o = this._vBoundaries,\n\t\t\ta = this.axis,\n\t\t\tismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),\n\t\t\tismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),\n\t\t\tisminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),\n\t\t\tisminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),\n\t\t\tdw = this.originalPosition.left + this.originalSize.width,\n\t\t\tdh = this.position.top + this.size.height,\n\t\t\tcw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);\n\t\tif (isminw) {\n\t\t\tdata.width = o.minWidth;\n\t\t}\n\t\tif (isminh) {\n\t\t\tdata.height = o.minHeight;\n\t\t}\n\t\tif (ismaxw) {\n\t\t\tdata.width = o.maxWidth;\n\t\t}\n\t\tif (ismaxh) {\n\t\t\tdata.height = o.maxHeight;\n\t\t}\n\n\t\tif (isminw && cw) {\n\t\t\tdata.left = dw - o.minWidth;\n\t\t}\n\t\tif (ismaxw && cw) {\n\t\t\tdata.left = dw - o.maxWidth;\n\t\t}\n\t\tif (isminh && ch) {\n\t\t\tdata.top = dh - o.minHeight;\n\t\t}\n\t\tif (ismaxh && ch) {\n\t\t\tdata.top = dh - o.maxHeight;\n\t\t}\n\n\t\t// Fixing jump error on top/left - bug #2330\n\t\tif (!data.width && !data.height && !data.left && data.top) {\n\t\t\tdata.top = null;\n\t\t} else if (!data.width && !data.height && !data.top && data.left) {\n\t\t\tdata.left = null;\n\t\t}\n\n\t\treturn data;\n\t},\n\n\t_getPaddingPlusBorderDimensions: function( element ) {\n\t\tvar i = 0,\n\t\t\twidths = [],\n\t\t\tborders = [\n\t\t\t\telement.css( "borderTopWidth" ),\n\t\t\t\telement.css( "borderRightWidth" ),\n\t\t\t\telement.css( "borderBottomWidth" ),\n\t\t\t\telement.css( "borderLeftWidth" )\n\t\t\t],\n\t\t\tpaddings = [\n\t\t\t\telement.css( "paddingTop" ),\n\t\t\t\telement.css( "paddingRight" ),\n\t\t\t\telement.css( "paddingBottom" ),\n\t\t\t\telement.css( "paddingLeft" )\n\t\t\t];\n\n\t\tfor ( ; i < 4; i++ ) {\n\t\t\twidths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );\n\t\t\twidths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );\n\t\t}\n\n\t\treturn {\n\t\t\theight: widths[ 0 ] + widths[ 2 ],\n\t\t\twidth: widths[ 1 ] + widths[ 3 ]\n\t\t};\n\t},\n\n\t_proportionallyResize: function() {\n\n\t\tif (!this._proportionallyResizeElements.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar prel,\n\t\t\ti = 0,\n\t\t\telement = this.helper || this.element;\n\n\t\tfor ( ; i < this._proportionallyResizeElements.length; i++) {\n\n\t\t\tprel = this._proportionallyResizeElements[i];\n\n\t\t\t// TODO: Seems like a bug to cache this.outerDimensions\n\t\t\t// considering that we are in a loop.\n\t\t\tif (!this.outerDimensions) {\n\t\t\t\tthis.outerDimensions = this._getPaddingPlusBorderDimensions( prel );\n\t\t\t}\n\n\t\t\tprel.css({\n\t\t\t\theight: (element.height() - this.outerDimensions.height) || 0,\n\t\t\t\twidth: (element.width() - this.outerDimensions.width) || 0\n\t\t\t});\n\n\t\t}\n\n\t},\n\n\t_renderProxy: function() {\n\n\t\tvar el = this.element, o = this.options;\n\t\tthis.elementOffset = el.offset();\n\n\t\tif (this._helper) {\n\n\t\t\tthis.helper = this.helper || $("<div style=\'overflow:hidden;\'></div>");\n\n\t\t\tthis.helper.addClass(this._helper).css({\n\t\t\t\twidth: this.element.outerWidth() - 1,\n\t\t\t\theight: this.element.outerHeight() - 1,\n\t\t\t\tposition: "absolute",\n\t\t\t\tleft: this.elementOffset.left + "px",\n\t\t\t\ttop: this.elementOffset.top + "px",\n\t\t\t\tzIndex: ++o.zIndex //TODO: Don\'t modify option\n\t\t\t});\n\n\t\t\tthis.helper\n\t\t\t\t.appendTo("body")\n\t\t\t\t.disableSelection();\n\n\t\t} else {\n\t\t\tthis.helper = this.element;\n\t\t}\n\n\t},\n\n\t_change: {\n\t\te: function(event, dx) {\n\t\t\treturn { width: this.originalSize.width + dx };\n\t\t},\n\t\tw: function(event, dx) {\n\t\t\tvar cs = this.originalSize, sp = this.originalPosition;\n\t\t\treturn { left: sp.left + dx, width: cs.width - dx };\n\t\t},\n\t\tn: function(event, dx, dy) {\n\t\t\tvar cs = this.originalSize, sp = this.originalPosition;\n\t\t\treturn { top: sp.top + dy, height: cs.height - dy };\n\t\t},\n\t\ts: function(event, dx, dy) {\n\t\t\treturn { height: this.originalSize.height + dy };\n\t\t},\n\t\tse: function(event, dx, dy) {\n\t\t\treturn $.extend(this._change.s.apply(this, arguments),\n\t\t\t\tthis._change.e.apply(this, [ event, dx, dy ]));\n\t\t},\n\t\tsw: function(event, dx, dy) {\n\t\t\treturn $.extend(this._change.s.apply(this, arguments),\n\t\t\t\tthis._change.w.apply(this, [ event, dx, dy ]));\n\t\t},\n\t\tne: function(event, dx, dy) {\n\t\t\treturn $.extend(this._change.n.apply(this, arguments),\n\t\t\t\tthis._change.e.apply(this, [ event, dx, dy ]));\n\t\t},\n\t\tnw: function(event, dx, dy) {\n\t\t\treturn $.extend(this._change.n.apply(this, arguments),\n\t\t\t\tthis._change.w.apply(this, [ event, dx, dy ]));\n\t\t}\n\t},\n\n\t_propagate: function(n, event) {\n\t\t$.ui.plugin.call(this, n, [ event, this.ui() ]);\n\t\t(n !== "resize" && this._trigger(n, event, this.ui()));\n\t},\n\n\tplugins: {},\n\n\tui: function() {\n\t\treturn {\n\t\t\toriginalElement: this.originalElement,\n\t\t\telement: this.element,\n\t\t\thelper: this.helper,\n\t\t\tposition: this.position,\n\t\t\tsize: this.size,\n\t\t\toriginalSize: this.originalSize,\n\t\t\toriginalPosition: this.originalPosition\n\t\t};\n\t}\n\n});\n\n/*\n * Resizable Extensions\n */\n\n$.ui.plugin.add("resizable", "animate", {\n\n\tstop: function( event ) {\n\t\tvar that = $(this).resizable( "instance" ),\n\t\t\to = that.options,\n\t\t\tpr = that._proportionallyResizeElements,\n\t\t\tista = pr.length && (/textarea/i).test(pr[0].nodeName),\n\t\t\tsoffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,\n\t\t\tsoffsetw = ista ? 0 : that.sizeDiff.width,\n\t\t\tstyle = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },\n\t\t\tleft = (parseInt(that.element.css("left"), 10) +\n\t\t\t\t(that.position.left - that.originalPosition.left)) || null,\n\t\t\ttop = (parseInt(that.element.css("top"), 10) +\n\t\t\t\t(that.position.top - that.originalPosition.top)) || null;\n\n\t\tthat.element.animate(\n\t\t\t$.extend(style, top && left ? { top: top, left: left } : {}), {\n\t\t\t\tduration: o.animateDuration,\n\t\t\t\teasing: o.animateEasing,\n\t\t\t\tstep: function() {\n\n\t\t\t\t\tvar data = {\n\t\t\t\t\t\twidth: parseInt(that.element.css("width"), 10),\n\t\t\t\t\t\theight: parseInt(that.element.css("height"), 10),\n\t\t\t\t\t\ttop: parseInt(that.element.css("top"), 10),\n\t\t\t\t\t\tleft: parseInt(that.element.css("left"), 10)\n\t\t\t\t\t};\n\n\t\t\t\t\tif (pr && pr.length) {\n\t\t\t\t\t\t$(pr[0]).css({ width: data.width, height: data.height });\n\t\t\t\t\t}\n\n\t\t\t\t\t// propagating resize, and updating values for each animation step\n\t\t\t\t\tthat._updateCache(data);\n\t\t\t\t\tthat._propagate("resize", event);\n\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n});\n\n$.ui.plugin.add( "resizable", "containment", {\n\n\tstart: function() {\n\t\tvar element, p, co, ch, cw, width, height,\n\t\t\tthat = $( this ).resizable( "instance" ),\n\t\t\to = that.options,\n\t\t\tel = that.element,\n\t\t\toc = o.containment,\n\t\t\tce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;\n\n\t\tif ( !ce ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthat.containerElement = $( ce );\n\n\t\tif ( /document/.test( oc ) || oc === document ) {\n\t\t\tthat.containerOffset = {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0\n\t\t\t};\n\t\t\tthat.containerPosition = {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0\n\t\t\t};\n\n\t\t\tthat.parentData = {\n\t\t\t\telement: $( document ),\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0,\n\t\t\t\twidth: $( document ).width(),\n\t\t\t\theight: $( document ).height() || document.body.parentNode.scrollHeight\n\t\t\t};\n\t\t} else {\n\t\t\telement = $( ce );\n\t\t\tp = [];\n\t\t\t$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {\n\t\t\t\tp[ i ] = that._num( element.css( "padding" + name ) );\n\t\t\t});\n\n\t\t\tthat.containerOffset = element.offset();\n\t\t\tthat.containerPosition = element.position();\n\t\t\tthat.containerSize = {\n\t\t\t\theight: ( element.innerHeight() - p[ 3 ] ),\n\t\t\t\twidth: ( element.innerWidth() - p[ 1 ] )\n\t\t\t};\n\n\t\t\tco = that.containerOffset;\n\t\t\tch = that.containerSize.height;\n\t\t\tcw = that.containerSize.width;\n\t\t\twidth = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );\n\t\t\theight = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;\n\n\t\t\tthat.parentData = {\n\t\t\t\telement: ce,\n\t\t\t\tleft: co.left,\n\t\t\t\ttop: co.top,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t}\n\t},\n\n\tresize: function( event ) {\n\t\tvar woset, hoset, isParent, isOffsetRelative,\n\t\t\tthat = $( this ).resizable( "instance" ),\n\t\t\to = that.options,\n\t\t\tco = that.containerOffset,\n\t\t\tcp = that.position,\n\t\t\tpRatio = that._aspectRatio || event.shiftKey,\n\t\t\tcop = {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t},\n\t\t\tce = that.containerElement,\n\t\t\tcontinueResize = true;\n\n\t\tif ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {\n\t\t\tcop = co;\n\t\t}\n\n\t\tif ( cp.left < ( that._helper ? co.left : 0 ) ) {\n\t\t\tthat.size.width = that.size.width +\n\t\t\t\t( that._helper ?\n\t\t\t\t\t( that.position.left - co.left ) :\n\t\t\t\t\t( that.position.left - cop.left ) );\n\n\t\t\tif ( pRatio ) {\n\t\t\t\tthat.size.height = that.size.width / that.aspectRatio;\n\t\t\t\tcontinueResize = false;\n\t\t\t}\n\t\t\tthat.position.left = o.helper ? co.left : 0;\n\t\t}\n\n\t\tif ( cp.top < ( that._helper ? co.top : 0 ) ) {\n\t\t\tthat.size.height = that.size.height +\n\t\t\t\t( that._helper ?\n\t\t\t\t\t( that.position.top - co.top ) :\n\t\t\t\t\tthat.position.top );\n\n\t\t\tif ( pRatio ) {\n\t\t\t\tthat.size.width = that.size.height * that.aspectRatio;\n\t\t\t\tcontinueResize = false;\n\t\t\t}\n\t\t\tthat.position.top = that._helper ? co.top : 0;\n\t\t}\n\n\t\tisParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );\n\t\tisOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );\n\n\t\tif ( isParent && isOffsetRelative ) {\n\t\t\tthat.offset.left = that.parentData.left + that.position.left;\n\t\t\tthat.offset.top = that.parentData.top + that.position.top;\n\t\t} else {\n\t\t\tthat.offset.left = that.element.offset().left;\n\t\t\tthat.offset.top = that.element.offset().top;\n\t\t}\n\n\t\twoset = Math.abs( that.sizeDiff.width +\n\t\t\t(that._helper ?\n\t\t\t\tthat.offset.left - cop.left :\n\t\t\t\t(that.offset.left - co.left)) );\n\n\t\thoset = Math.abs( that.sizeDiff.height +\n\t\t\t(that._helper ?\n\t\t\t\tthat.offset.top - cop.top :\n\t\t\t\t(that.offset.top - co.top)) );\n\n\t\tif ( woset + that.size.width >= that.parentData.width ) {\n\t\t\tthat.size.width = that.parentData.width - woset;\n\t\t\tif ( pRatio ) {\n\t\t\t\tthat.size.height = that.size.width / that.aspectRatio;\n\t\t\t\tcontinueResize = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( hoset + that.size.height >= that.parentData.height ) {\n\t\t\tthat.size.height = that.parentData.height - hoset;\n\t\t\tif ( pRatio ) {\n\t\t\t\tthat.size.width = that.size.height * that.aspectRatio;\n\t\t\t\tcontinueResize = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( !continueResize ) {\n\t\t\tthat.position.left = that.prevPosition.left;\n\t\t\tthat.position.top = that.prevPosition.top;\n\t\t\tthat.size.width = that.prevSize.width;\n\t\t\tthat.size.height = that.prevSize.height;\n\t\t}\n\t},\n\n\tstop: function() {\n\t\tvar that = $( this ).resizable( "instance" ),\n\t\t\to = that.options,\n\t\t\tco = that.containerOffset,\n\t\t\tcop = that.containerPosition,\n\t\t\tce = that.containerElement,\n\t\t\thelper = $( that.helper ),\n\t\t\tho = helper.offset(),\n\t\t\tw = helper.outerWidth() - that.sizeDiff.width,\n\t\t\th = helper.outerHeight() - that.sizeDiff.height;\n\n\t\tif ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {\n\t\t\t$( this ).css({\n\t\t\t\tleft: ho.left - cop.left - co.left,\n\t\t\t\twidth: w,\n\t\t\t\theight: h\n\t\t\t});\n\t\t}\n\n\t\tif ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {\n\t\t\t$( this ).css({\n\t\t\t\tleft: ho.left - cop.left - co.left,\n\t\t\t\twidth: w,\n\t\t\t\theight: h\n\t\t\t});\n\t\t}\n\t}\n});\n\n$.ui.plugin.add("resizable", "alsoResize", {\n\n\tstart: function() {\n\t\tvar that = $(this).resizable( "instance" ),\n\t\t\to = that.options;\n\n\t\t$(o.alsoResize).each(function() {\n\t\t\tvar el = $(this);\n\t\t\tel.data("ui-resizable-alsoresize", {\n\t\t\t\twidth: parseInt(el.width(), 10), height: parseInt(el.height(), 10),\n\t\t\t\tleft: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)\n\t\t\t});\n\t\t});\n\t},\n\n\tresize: function(event, ui) {\n\t\tvar that = $(this).resizable( "instance" ),\n\t\t\to = that.options,\n\t\t\tos = that.originalSize,\n\t\t\top = that.originalPosition,\n\t\t\tdelta = {\n\t\t\t\theight: (that.size.height - os.height) || 0,\n\t\t\t\twidth: (that.size.width - os.width) || 0,\n\t\t\t\ttop: (that.position.top - op.top) || 0,\n\t\t\t\tleft: (that.position.left - op.left) || 0\n\t\t\t};\n\n\t\t\t$(o.alsoResize).each(function() {\n\t\t\t\tvar el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},\n\t\t\t\t\tcss = el.parents(ui.originalElement[0]).length ?\n\t\t\t\t\t\t\t[ "width", "height" ] :\n\t\t\t\t\t\t\t[ "width", "height", "top", "left" ];\n\n\t\t\t\t$.each(css, function(i, prop) {\n\t\t\t\t\tvar sum = (start[prop] || 0) + (delta[prop] || 0);\n\t\t\t\t\tif (sum && sum >= 0) {\n\t\t\t\t\t\tstyle[prop] = sum || null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tel.css(style);\n\t\t\t});\n\t},\n\n\tstop: function() {\n\t\t$(this).removeData("resizable-alsoresize");\n\t}\n});\n\n$.ui.plugin.add("resizable", "ghost", {\n\n\tstart: function() {\n\n\t\tvar that = $(this).resizable( "instance" ), o = that.options, cs = that.size;\n\n\t\tthat.ghost = that.originalElement.clone();\n\t\tthat.ghost\n\t\t\t.css({\n\t\t\t\topacity: 0.25,\n\t\t\t\tdisplay: "block",\n\t\t\t\tposition: "relative",\n\t\t\t\theight: cs.height,\n\t\t\t\twidth: cs.width,\n\t\t\t\tmargin: 0,\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0\n\t\t\t})\n\t\t\t.addClass("ui-resizable-ghost")\n\t\t\t.addClass(typeof o.ghost === "string" ? o.ghost : "");\n\n\t\tthat.ghost.appendTo(that.helper);\n\n\t},\n\n\tresize: function() {\n\t\tvar that = $(this).resizable( "instance" );\n\t\tif (that.ghost) {\n\t\t\tthat.ghost.css({\n\t\t\t\tposition: "relative",\n\t\t\t\theight: that.size.height,\n\t\t\t\twidth: that.size.width\n\t\t\t});\n\t\t}\n\t},\n\n\tstop: function() {\n\t\tvar that = $(this).resizable( "instance" );\n\t\tif (that.ghost && that.helper) {\n\t\t\tthat.helper.get(0).removeChild(that.ghost.get(0));\n\t\t}\n\t}\n\n});\n\n$.ui.plugin.add("resizable", "grid", {\n\n\tresize: function() {\n\t\tvar outerDimensions,\n\t\t\tthat = $(this).resizable( "instance" ),\n\t\t\to = that.options,\n\t\t\tcs = that.size,\n\t\t\tos = that.originalSize,\n\t\t\top = that.originalPosition,\n\t\t\ta = that.axis,\n\t\t\tgrid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,\n\t\t\tgridX = (grid[0] || 1),\n\t\t\tgridY = (grid[1] || 1),\n\t\t\tox = Math.round((cs.width - os.width) / gridX) * gridX,\n\t\t\toy = Math.round((cs.height - os.height) / gridY) * gridY,\n\t\t\tnewWidth = os.width + ox,\n\t\t\tnewHeight = os.height + oy,\n\t\t\tisMaxWidth = o.maxWidth && (o.maxWidth < newWidth),\n\t\t\tisMaxHeight = o.maxHeight && (o.maxHeight < newHeight),\n\t\t\tisMinWidth = o.minWidth && (o.minWidth > newWidth),\n\t\t\tisMinHeight = o.minHeight && (o.minHeight > newHeight);\n\n\t\to.grid = grid;\n\n\t\tif (isMinWidth) {\n\t\t\tnewWidth += gridX;\n\t\t}\n\t\tif (isMinHeight) {\n\t\t\tnewHeight += gridY;\n\t\t}\n\t\tif (isMaxWidth) {\n\t\t\tnewWidth -= gridX;\n\t\t}\n\t\tif (isMaxHeight) {\n\t\t\tnewHeight -= gridY;\n\t\t}\n\n\t\tif (/^(se|s|e)$/.test(a)) {\n\t\t\tthat.size.width = newWidth;\n\t\t\tthat.size.height = newHeight;\n\t\t} else if (/^(ne)$/.test(a)) {\n\t\t\tthat.size.width = newWidth;\n\t\t\tthat.size.height = newHeight;\n\t\t\tthat.position.top = op.top - oy;\n\t\t} else if (/^(sw)$/.test(a)) {\n\t\t\tthat.size.width = newWidth;\n\t\t\tthat.size.height = newHeight;\n\t\t\tthat.position.left = op.left - ox;\n\t\t} else {\n\t\t\tif ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {\n\t\t\t\touterDimensions = that._getPaddingPlusBorderDimensions( this );\n\t\t\t}\n\n\t\t\tif ( newHeight - gridY > 0 ) {\n\t\t\t\tthat.size.height = newHeight;\n\t\t\t\tthat.position.top = op.top - oy;\n\t\t\t} else {\n\t\t\t\tnewHeight = gridY - outerDimensions.height;\n\t\t\t\tthat.size.height = newHeight;\n\t\t\t\tthat.position.top = op.top + os.height - newHeight;\n\t\t\t}\n\t\t\tif ( newWidth - gridX > 0 ) {\n\t\t\t\tthat.size.width = newWidth;\n\t\t\t\tthat.position.left = op.left - ox;\n\t\t\t} else {\n\t\t\t\tnewWidth = gridX - outerDimensions.width;\n\t\t\t\tthat.size.width = newWidth;\n\t\t\t\tthat.position.left = op.left + os.width - newWidth;\n\t\t\t}\n\t\t}\n\t}\n\n});\n\nvar resizable = $.ui.resizable;\n\n\n/*!\n * jQuery UI Dialog 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/dialog/\n */\n\n\nvar dialog = $.widget( "ui.dialog", {\n\tversion: "1.11.4",\n\toptions: {\n\t\tappendTo: "body",\n\t\tautoOpen: true,\n\t\tbuttons: [],\n\t\tcloseOnEscape: true,\n\t\tcloseText: "Close",\n\t\tdialogClass: "",\n\t\tdraggable: true,\n\t\thide: null,\n\t\theight: "auto",\n\t\tmaxHeight: null,\n\t\tmaxWidth: null,\n\t\tminHeight: 150,\n\t\tminWidth: 150,\n\t\tmodal: false,\n\t\tposition: {\n\t\t\tmy: "center",\n\t\t\tat: "center",\n\t\t\tof: window,\n\t\t\tcollision: "fit",\n\t\t\t// Ensure the titlebar is always visible\n\t\t\tusing: function( pos ) {\n\t\t\t\tvar topOffset = $( this ).css( pos ).offset().top;\n\t\t\t\tif ( topOffset < 0 ) {\n\t\t\t\t\t$( this ).css( "top", pos.top - topOffset );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tresizable: true,\n\t\tshow: null,\n\t\ttitle: null,\n\t\twidth: 300,\n\n\t\t// callbacks\n\t\tbeforeClose: null,\n\t\tclose: null,\n\t\tdrag: null,\n\t\tdragStart: null,\n\t\tdragStop: null,\n\t\tfocus: null,\n\t\topen: null,\n\t\tresize: null,\n\t\tresizeStart: null,\n\t\tresizeStop: null\n\t},\n\n\tsizeRelatedOptions: {\n\t\tbuttons: true,\n\t\theight: true,\n\t\tmaxHeight: true,\n\t\tmaxWidth: true,\n\t\tminHeight: true,\n\t\tminWidth: true,\n\t\twidth: true\n\t},\n\n\tresizableRelatedOptions: {\n\t\tmaxHeight: true,\n\t\tmaxWidth: true,\n\t\tminHeight: true,\n\t\tminWidth: true\n\t},\n\n\t_create: function() {\n\t\tthis.originalCss = {\n\t\t\tdisplay: this.element[ 0 ].style.display,\n\t\t\twidth: this.element[ 0 ].style.width,\n\t\t\tminHeight: this.element[ 0 ].style.minHeight,\n\t\t\tmaxHeight: this.element[ 0 ].style.maxHeight,\n\t\t\theight: this.element[ 0 ].style.height\n\t\t};\n\t\tthis.originalPosition = {\n\t\t\tparent: this.element.parent(),\n\t\t\tindex: this.element.parent().children().index( this.element )\n\t\t};\n\t\tthis.originalTitle = this.element.attr( "title" );\n\t\tthis.options.title = this.options.title || this.originalTitle;\n\n\t\tthis._createWrapper();\n\n\t\tthis.element\n\t\t\t.show()\n\t\t\t.removeAttr( "title" )\n\t\t\t.addClass( "ui-dialog-content ui-widget-content" )\n\t\t\t.appendTo( this.uiDialog );\n\n\t\tthis._createTitlebar();\n\t\tthis._createButtonPane();\n\n\t\tif ( this.options.draggable && $.fn.draggable ) {\n\t\t\tthis._makeDraggable();\n\t\t}\n\t\tif ( this.options.resizable && $.fn.resizable ) {\n\t\t\tthis._makeResizable();\n\t\t}\n\n\t\tthis._isOpen = false;\n\n\t\tthis._trackFocus();\n\t},\n\n\t_init: function() {\n\t\tif ( this.options.autoOpen ) {\n\t\t\tthis.open();\n\t\t}\n\t},\n\n\t_appendTo: function() {\n\t\tvar element = this.options.appendTo;\n\t\tif ( element && (element.jquery || element.nodeType) ) {\n\t\t\treturn $( element );\n\t\t}\n\t\treturn this.document.find( element || "body" ).eq( 0 );\n\t},\n\n\t_destroy: function() {\n\t\tvar next,\n\t\t\toriginalPosition = this.originalPosition;\n\n\t\tthis._untrackInstance();\n\t\tthis._destroyOverlay();\n\n\t\tthis.element\n\t\t\t.removeUniqueId()\n\t\t\t.removeClass( "ui-dialog-content ui-widget-content" )\n\t\t\t.css( this.originalCss )\n\t\t\t// Without detaching first, the following becomes really slow\n\t\t\t.detach();\n\n\t\tthis.uiDialog.stop( true, true ).remove();\n\n\t\tif ( this.originalTitle ) {\n\t\t\tthis.element.attr( "title", this.originalTitle );\n\t\t}\n\n\t\tnext = originalPosition.parent.children().eq( originalPosition.index );\n\t\t// Don\'t try to place the dialog next to itself (#8613)\n\t\tif ( next.length && next[ 0 ] !== this.element[ 0 ] ) {\n\t\t\tnext.before( this.element );\n\t\t} else {\n\t\t\toriginalPosition.parent.append( this.element );\n\t\t}\n\t},\n\n\twidget: function() {\n\t\treturn this.uiDialog;\n\t},\n\n\tdisable: $.noop,\n\tenable: $.noop,\n\n\tclose: function( event ) {\n\t\tvar activeElement,\n\t\t\tthat = this;\n\n\t\tif ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isOpen = false;\n\t\tthis._focusedElement = null;\n\t\tthis._destroyOverlay();\n\t\tthis._untrackInstance();\n\n\t\tif ( !this.opener.filter( ":focusable" ).focus().length ) {\n\n\t\t\t// support: IE9\n\t\t\t// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>\n\t\t\ttry {\n\t\t\t\tactiveElement = this.document[ 0 ].activeElement;\n\n\t\t\t\t// Support: IE9, IE10\n\t\t\t\t// If the <body> is blurred, IE will switch windows, see #4520\n\t\t\t\tif ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {\n\n\t\t\t\t\t// Hiding a focused element doesn\'t trigger blur in WebKit\n\t\t\t\t\t// so in case we have nothing to focus on, explicitly blur the active element\n\t\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=47182\n\t\t\t\t\t$( activeElement ).blur();\n\t\t\t\t}\n\t\t\t} catch ( error ) {}\n\t\t}\n\n\t\tthis._hide( this.uiDialog, this.options.hide, function() {\n\t\t\tthat._trigger( "close", event );\n\t\t});\n\t},\n\n\tisOpen: function() {\n\t\treturn this._isOpen;\n\t},\n\n\tmoveToTop: function() {\n\t\tthis._moveToTop();\n\t},\n\n\t_moveToTop: function( event, silent ) {\n\t\tvar moved = false,\n\t\t\tzIndices = this.uiDialog.siblings( ".ui-front:visible" ).map(function() {\n\t\t\t\treturn +$( this ).css( "z-index" );\n\t\t\t}).get(),\n\t\t\tzIndexMax = Math.max.apply( null, zIndices );\n\n\t\tif ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {\n\t\t\tthis.uiDialog.css( "z-index", zIndexMax + 1 );\n\t\t\tmoved = true;\n\t\t}\n\n\t\tif ( moved && !silent ) {\n\t\t\tthis._trigger( "focus", event );\n\t\t}\n\t\treturn moved;\n\t},\n\n\topen: function() {\n\t\tvar that = this;\n\t\tif ( this._isOpen ) {\n\t\t\tif ( this._moveToTop() ) {\n\t\t\t\tthis._focusTabbable();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isOpen = true;\n\t\tthis.opener = $( this.document[ 0 ].activeElement );\n\n\t\tthis._size();\n\t\tthis._position();\n\t\tthis._createOverlay();\n\t\tthis._moveToTop( null, true );\n\n\t\t// Ensure the overlay is moved to the top with the dialog, but only when\n\t\t// opening. The overlay shouldn\'t move after the dialog is open so that\n\t\t// modeless dialogs opened after the modal dialog stack properly.\n\t\tif ( this.overlay ) {\n\t\t\tthis.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );\n\t\t}\n\n\t\tthis._show( this.uiDialog, this.options.show, function() {\n\t\t\tthat._focusTabbable();\n\t\t\tthat._trigger( "focus" );\n\t\t});\n\n\t\t// Track the dialog immediately upon openening in case a focus event\n\t\t// somehow occurs outside of the dialog before an element inside the\n\t\t// dialog is focused (#10152)\n\t\tthis._makeFocusTarget();\n\n\t\tthis._trigger( "open" );\n\t},\n\n\t_focusTabbable: function() {\n\t\t// Set focus to the first match:\n\t\t// 1. An element that was focused previously\n\t\t// 2. First element inside the dialog matching [autofocus]\n\t\t// 3. Tabbable element inside the content element\n\t\t// 4. Tabbable element inside the buttonpane\n\t\t// 5. The close button\n\t\t// 6. The dialog itself\n\t\tvar hasFocus = this._focusedElement;\n\t\tif ( !hasFocus ) {\n\t\t\thasFocus = this.element.find( "[autofocus]" );\n\t\t}\n\t\tif ( !hasFocus.length ) {\n\t\t\thasFocus = this.element.find( ":tabbable" );\n\t\t}\n\t\tif ( !hasFocus.length ) {\n\t\t\thasFocus = this.uiDialogButtonPane.find( ":tabbable" );\n\t\t}\n\t\tif ( !hasFocus.length ) {\n\t\t\thasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );\n\t\t}\n\t\tif ( !hasFocus.length ) {\n\t\t\thasFocus = this.uiDialog;\n\t\t}\n\t\thasFocus.eq( 0 ).focus();\n\t},\n\n\t_keepFocus: function( event ) {\n\t\tfunction checkFocus() {\n\t\t\tvar activeElement = this.document[0].activeElement,\n\t\t\t\tisActive = this.uiDialog[0] === activeElement ||\n\t\t\t\t\t$.contains( this.uiDialog[0], activeElement );\n\t\t\tif ( !isActive ) {\n\t\t\t\tthis._focusTabbable();\n\t\t\t}\n\t\t}\n\t\tevent.preventDefault();\n\t\tcheckFocus.call( this );\n\t\t// support: IE\n\t\t// IE <= 8 doesn\'t prevent moving focus even with event.preventDefault()\n\t\t// so we check again later\n\t\tthis._delay( checkFocus );\n\t},\n\n\t_createWrapper: function() {\n\t\tthis.uiDialog = $("<div>")\n\t\t\t.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +\n\t\t\t\tthis.options.dialogClass )\n\t\t\t.hide()\n\t\t\t.attr({\n\t\t\t\t// Setting tabIndex makes the div focusable\n\t\t\t\ttabIndex: -1,\n\t\t\t\trole: "dialog"\n\t\t\t})\n\t\t\t.appendTo( this._appendTo() );\n\n\t\tthis._on( this.uiDialog, {\n\t\t\tkeydown: function( event ) {\n\t\t\t\tif ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&\n\t\t\t\t\t\tevent.keyCode === $.ui.keyCode.ESCAPE ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tthis.close( event );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// prevent tabbing out of dialogs\n\t\t\t\tif ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar tabbables = this.uiDialog.find( ":tabbable" ),\n\t\t\t\t\tfirst = tabbables.filter( ":first" ),\n\t\t\t\t\tlast = tabbables.filter( ":last" );\n\n\t\t\t\tif ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {\n\t\t\t\t\tthis._delay(function() {\n\t\t\t\t\t\tfirst.focus();\n\t\t\t\t\t});\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {\n\t\t\t\t\tthis._delay(function() {\n\t\t\t\t\t\tlast.focus();\n\t\t\t\t\t});\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t},\n\t\t\tmousedown: function( event ) {\n\t\t\t\tif ( this._moveToTop( event ) ) {\n\t\t\t\t\tthis._focusTabbable();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// We assume that any existing aria-describedby attribute means\n\t\t// that the dialog content is marked up properly\n\t\t// otherwise we brute force the content as the description\n\t\tif ( !this.element.find( "[aria-describedby]" ).length ) {\n\t\t\tthis.uiDialog.attr({\n\t\t\t\t"aria-describedby": this.element.uniqueId().attr( "id" )\n\t\t\t});\n\t\t}\n\t},\n\n\t_createTitlebar: function() {\n\t\tvar uiDialogTitle;\n\n\t\tthis.uiDialogTitlebar = $( "<div>" )\n\t\t\t.addClass( "ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix" )\n\t\t\t.prependTo( this.uiDialog );\n\t\tthis._on( this.uiDialogTitlebar, {\n\t\t\tmousedown: function( event ) {\n\t\t\t\t// Don\'t prevent click on close button (#8838)\n\t\t\t\t// Focusing a dialog that is partially scrolled out of view\n\t\t\t\t// causes the browser to scroll it into view, preventing the click event\n\t\t\t\tif ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {\n\t\t\t\t\t// Dialog isn\'t getting focus when dragging (#8063)\n\t\t\t\t\tthis.uiDialog.focus();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// support: IE\n\t\t// Use type="button" to prevent enter keypresses in textboxes from closing the\n\t\t// dialog in IE (#9312)\n\t\tthis.uiDialogTitlebarClose = $( "<button type=\'button\'></button>" )\n\t\t\t.button({\n\t\t\t\tlabel: this.options.closeText,\n\t\t\t\ticons: {\n\t\t\t\t\tprimary: "ui-icon-closethick"\n\t\t\t\t},\n\t\t\t\ttext: false\n\t\t\t})\n\t\t\t.addClass( "ui-dialog-titlebar-close" )\n\t\t\t.appendTo( this.uiDialogTitlebar );\n\t\tthis._on( this.uiDialogTitlebarClose, {\n\t\t\tclick: function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.close( event );\n\t\t\t}\n\t\t});\n\n\t\tuiDialogTitle = $( "<span>" )\n\t\t\t.uniqueId()\n\t\t\t.addClass( "ui-dialog-title" )\n\t\t\t.prependTo( this.uiDialogTitlebar );\n\t\tthis._title( uiDialogTitle );\n\n\t\tthis.uiDialog.attr({\n\t\t\t"aria-labelledby": uiDialogTitle.attr( "id" )\n\t\t});\n\t},\n\n\t_title: function( title ) {\n\t\tif ( !this.options.title ) {\n\t\t\ttitle.html( "&#160;" );\n\t\t}\n\t\ttitle.text( this.options.title );\n\t},\n\n\t_createButtonPane: function() {\n\t\tthis.uiDialogButtonPane = $( "<div>" )\n\t\t\t.addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" );\n\n\t\tthis.uiButtonSet = $( "<div>" )\n\t\t\t.addClass( "ui-dialog-buttonset" )\n\t\t\t.appendTo( this.uiDialogButtonPane );\n\n\t\tthis._createButtons();\n\t},\n\n\t_createButtons: function() {\n\t\tvar that = this,\n\t\t\tbuttons = this.options.buttons;\n\n\t\t// if we already have a button pane, remove it\n\t\tthis.uiDialogButtonPane.remove();\n\t\tthis.uiButtonSet.empty();\n\n\t\tif ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {\n\t\t\tthis.uiDialog.removeClass( "ui-dialog-buttons" );\n\t\t\treturn;\n\t\t}\n\n\t\t$.each( buttons, function( name, props ) {\n\t\t\tvar click, buttonOptions;\n\t\t\tprops = $.isFunction( props ) ?\n\t\t\t\t{ click: props, text: name } :\n\t\t\t\tprops;\n\t\t\t// Default to a non-submitting button\n\t\t\tprops = $.extend( { type: "button" }, props );\n\t\t\t// Change the context for the click callback to be the main element\n\t\t\tclick = props.click;\n\t\t\tprops.click = function() {\n\t\t\t\tclick.apply( that.element[ 0 ], arguments );\n\t\t\t};\n\t\t\tbuttonOptions = {\n\t\t\t\ticons: props.icons,\n\t\t\t\ttext: props.showText\n\t\t\t};\n\t\t\tdelete props.icons;\n\t\t\tdelete props.showText;\n\t\t\t$( "<button></button>", props )\n\t\t\t\t.button( buttonOptions )\n\t\t\t\t.appendTo( that.uiButtonSet );\n\t\t});\n\t\tthis.uiDialog.addClass( "ui-dialog-buttons" );\n\t\tthis.uiDialogButtonPane.appendTo( this.uiDialog );\n\t},\n\n\t_makeDraggable: function() {\n\t\tvar that = this,\n\t\t\toptions = this.options;\n\n\t\tfunction filteredUi( ui ) {\n\t\t\treturn {\n\t\t\t\tposition: ui.position,\n\t\t\t\toffset: ui.offset\n\t\t\t};\n\t\t}\n\n\t\tthis.uiDialog.draggable({\n\t\t\tcancel: ".ui-dialog-content, .ui-dialog-titlebar-close",\n\t\t\thandle: ".ui-dialog-titlebar",\n\t\t\tcontainment: "document",\n\t\t\tstart: function( event, ui ) {\n\t\t\t\t$( this ).addClass( "ui-dialog-dragging" );\n\t\t\t\tthat._blockFrames();\n\t\t\t\tthat._trigger( "dragStart", event, filteredUi( ui ) );\n\t\t\t},\n\t\t\tdrag: function( event, ui ) {\n\t\t\t\tthat._trigger( "drag", event, filteredUi( ui ) );\n\t\t\t},\n\t\t\tstop: function( event, ui ) {\n\t\t\t\tvar left = ui.offset.left - that.document.scrollLeft(),\n\t\t\t\t\ttop = ui.offset.top - that.document.scrollTop();\n\n\t\t\t\toptions.position = {\n\t\t\t\t\tmy: "left top",\n\t\t\t\t\tat: "left" + (left >= 0 ? "+" : "") + left + " " +\n\t\t\t\t\t\t"top" + (top >= 0 ? "+" : "") + top,\n\t\t\t\t\tof: that.window\n\t\t\t\t};\n\t\t\t\t$( this ).removeClass( "ui-dialog-dragging" );\n\t\t\t\tthat._unblockFrames();\n\t\t\t\tthat._trigger( "dragStop", event, filteredUi( ui ) );\n\t\t\t}\n\t\t});\n\t},\n\n\t_makeResizable: function() {\n\t\tvar that = this,\n\t\t\toptions = this.options,\n\t\t\thandles = options.resizable,\n\t\t\t// .ui-resizable has position: relative defined in the stylesheet\n\t\t\t// but dialogs have to use absolute or fixed positioning\n\t\t\tposition = this.uiDialog.css("position"),\n\t\t\tresizeHandles = typeof handles === "string" ?\n\t\t\t\thandles\t:\n\t\t\t\t"n,e,s,w,se,sw,ne,nw";\n\n\t\tfunction filteredUi( ui ) {\n\t\t\treturn {\n\t\t\t\toriginalPosition: ui.originalPosition,\n\t\t\t\toriginalSize: ui.originalSize,\n\t\t\t\tposition: ui.position,\n\t\t\t\tsize: ui.size\n\t\t\t};\n\t\t}\n\n\t\tthis.uiDialog.resizable({\n\t\t\tcancel: ".ui-dialog-content",\n\t\t\tcontainment: "document",\n\t\t\talsoResize: this.element,\n\t\t\tmaxWidth: options.maxWidth,\n\t\t\tmaxHeight: options.maxHeight,\n\t\t\tminWidth: options.minWidth,\n\t\t\tminHeight: this._minHeight(),\n\t\t\thandles: resizeHandles,\n\t\t\tstart: function( event, ui ) {\n\t\t\t\t$( this ).addClass( "ui-dialog-resizing" );\n\t\t\t\tthat._blockFrames();\n\t\t\t\tthat._trigger( "resizeStart", event, filteredUi( ui ) );\n\t\t\t},\n\t\t\tresize: function( event, ui ) {\n\t\t\t\tthat._trigger( "resize", event, filteredUi( ui ) );\n\t\t\t},\n\t\t\tstop: function( event, ui ) {\n\t\t\t\tvar offset = that.uiDialog.offset(),\n\t\t\t\t\tleft = offset.left - that.document.scrollLeft(),\n\t\t\t\t\ttop = offset.top - that.document.scrollTop();\n\n\t\t\t\toptions.height = that.uiDialog.height();\n\t\t\t\toptions.width = that.uiDialog.width();\n\t\t\t\toptions.position = {\n\t\t\t\t\tmy: "left top",\n\t\t\t\t\tat: "left" + (left >= 0 ? "+" : "") + left + " " +\n\t\t\t\t\t\t"top" + (top >= 0 ? "+" : "") + top,\n\t\t\t\t\tof: that.window\n\t\t\t\t};\n\t\t\t\t$( this ).removeClass( "ui-dialog-resizing" );\n\t\t\t\tthat._unblockFrames();\n\t\t\t\tthat._trigger( "resizeStop", event, filteredUi( ui ) );\n\t\t\t}\n\t\t})\n\t\t.css( "position", position );\n\t},\n\n\t_trackFocus: function() {\n\t\tthis._on( this.widget(), {\n\t\t\tfocusin: function( event ) {\n\t\t\t\tthis._makeFocusTarget();\n\t\t\t\tthis._focusedElement = $( event.target );\n\t\t\t}\n\t\t});\n\t},\n\n\t_makeFocusTarget: function() {\n\t\tthis._untrackInstance();\n\t\tthis._trackingInstances().unshift( this );\n\t},\n\n\t_untrackInstance: function() {\n\t\tvar instances = this._trackingInstances(),\n\t\t\texists = $.inArray( this, instances );\n\t\tif ( exists !== -1 ) {\n\t\t\tinstances.splice( exists, 1 );\n\t\t}\n\t},\n\n\t_trackingInstances: function() {\n\t\tvar instances = this.document.data( "ui-dialog-instances" );\n\t\tif ( !instances ) {\n\t\t\tinstances = [];\n\t\t\tthis.document.data( "ui-dialog-instances", instances );\n\t\t}\n\t\treturn instances;\n\t},\n\n\t_minHeight: function() {\n\t\tvar options = this.options;\n\n\t\treturn options.height === "auto" ?\n\t\t\toptions.minHeight :\n\t\t\tMath.min( options.minHeight, options.height );\n\t},\n\n\t_position: function() {\n\t\t// Need to show the dialog to get the actual offset in the position plugin\n\t\tvar isVisible = this.uiDialog.is( ":visible" );\n\t\tif ( !isVisible ) {\n\t\t\tthis.uiDialog.show();\n\t\t}\n\t\tthis.uiDialog.position( this.options.position );\n\t\tif ( !isVisible ) {\n\t\t\tthis.uiDialog.hide();\n\t\t}\n\t},\n\n\t_setOptions: function( options ) {\n\t\tvar that = this,\n\t\t\tresize = false,\n\t\t\tresizableOptions = {};\n\n\t\t$.each( options, function( key, value ) {\n\t\t\tthat._setOption( key, value );\n\n\t\t\tif ( key in that.sizeRelatedOptions ) {\n\t\t\t\tresize = true;\n\t\t\t}\n\t\t\tif ( key in that.resizableRelatedOptions ) {\n\t\t\t\tresizableOptions[ key ] = value;\n\t\t\t}\n\t\t});\n\n\t\tif ( resize ) {\n\t\t\tthis._size();\n\t\t\tthis._position();\n\t\t}\n\t\tif ( this.uiDialog.is( ":data(ui-resizable)" ) ) {\n\t\t\tthis.uiDialog.resizable( "option", resizableOptions );\n\t\t}\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tvar isDraggable, isResizable,\n\t\t\tuiDialog = this.uiDialog;\n\n\t\tif ( key === "dialogClass" ) {\n\t\t\tuiDialog\n\t\t\t\t.removeClass( this.options.dialogClass )\n\t\t\t\t.addClass( value );\n\t\t}\n\n\t\tif ( key === "disabled" ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\tif ( key === "appendTo" ) {\n\t\t\tthis.uiDialog.appendTo( this._appendTo() );\n\t\t}\n\n\t\tif ( key === "buttons" ) {\n\t\t\tthis._createButtons();\n\t\t}\n\n\t\tif ( key === "closeText" ) {\n\t\t\tthis.uiDialogTitlebarClose.button({\n\t\t\t\t// Ensure that we always pass a string\n\t\t\t\tlabel: "" + value\n\t\t\t});\n\t\t}\n\n\t\tif ( key === "draggable" ) {\n\t\t\tisDraggable = uiDialog.is( ":data(ui-draggable)" );\n\t\t\tif ( isDraggable && !value ) {\n\t\t\t\tuiDialog.draggable( "destroy" );\n\t\t\t}\n\n\t\t\tif ( !isDraggable && value ) {\n\t\t\t\tthis._makeDraggable();\n\t\t\t}\n\t\t}\n\n\t\tif ( key === "position" ) {\n\t\t\tthis._position();\n\t\t}\n\n\t\tif ( key === "resizable" ) {\n\t\t\t// currently resizable, becoming non-resizable\n\t\t\tisResizable = uiDialog.is( ":data(ui-resizable)" );\n\t\t\tif ( isResizable && !value ) {\n\t\t\t\tuiDialog.resizable( "destroy" );\n\t\t\t}\n\n\t\t\t// currently resizable, changing handles\n\t\t\tif ( isResizable && typeof value === "string" ) {\n\t\t\t\tuiDialog.resizable( "option", "handles", value );\n\t\t\t}\n\n\t\t\t// currently non-resizable, becoming resizable\n\t\t\tif ( !isResizable && value !== false ) {\n\t\t\t\tthis._makeResizable();\n\t\t\t}\n\t\t}\n\n\t\tif ( key === "title" ) {\n\t\t\tthis._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );\n\t\t}\n\t},\n\n\t_size: function() {\n\t\t// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content\n\t\t// divs will both have width and height set, so we need to reset them\n\t\tvar nonContentHeight, minContentHeight, maxContentHeight,\n\t\t\toptions = this.options;\n\n\t\t// Reset content sizing\n\t\tthis.element.show().css({\n\t\t\twidth: "auto",\n\t\t\tminHeight: 0,\n\t\t\tmaxHeight: "none",\n\t\t\theight: 0\n\t\t});\n\n\t\tif ( options.minWidth > options.width ) {\n\t\t\toptions.width = options.minWidth;\n\t\t}\n\n\t\t// reset wrapper sizing\n\t\t// determine the height of all the non-content elements\n\t\tnonContentHeight = this.uiDialog.css({\n\t\t\t\theight: "auto",\n\t\t\t\twidth: options.width\n\t\t\t})\n\t\t\t.outerHeight();\n\t\tminContentHeight = Math.max( 0, options.minHeight - nonContentHeight );\n\t\tmaxContentHeight = typeof options.maxHeight === "number" ?\n\t\t\tMath.max( 0, options.maxHeight - nonContentHeight ) :\n\t\t\t"none";\n\n\t\tif ( options.height === "auto" ) {\n\t\t\tthis.element.css({\n\t\t\t\tminHeight: minContentHeight,\n\t\t\t\tmaxHeight: maxContentHeight,\n\t\t\t\theight: "auto"\n\t\t\t});\n\t\t} else {\n\t\t\tthis.element.height( Math.max( 0, options.height - nonContentHeight ) );\n\t\t}\n\n\t\tif ( this.uiDialog.is( ":data(ui-resizable)" ) ) {\n\t\t\tthis.uiDialog.resizable( "option", "minHeight", this._minHeight() );\n\t\t}\n\t},\n\n\t_blockFrames: function() {\n\t\tthis.iframeBlocks = this.document.find( "iframe" ).map(function() {\n\t\t\tvar iframe = $( this );\n\n\t\t\treturn $( "<div>" )\n\t\t\t\t.css({\n\t\t\t\t\tposition: "absolute",\n\t\t\t\t\twidth: iframe.outerWidth(),\n\t\t\t\t\theight: iframe.outerHeight()\n\t\t\t\t})\n\t\t\t\t.appendTo( iframe.parent() )\n\t\t\t\t.offset( iframe.offset() )[0];\n\t\t});\n\t},\n\n\t_unblockFrames: function() {\n\t\tif ( this.iframeBlocks ) {\n\t\t\tthis.iframeBlocks.remove();\n\t\t\tdelete this.iframeBlocks;\n\t\t}\n\t},\n\n\t_allowInteraction: function( event ) {\n\t\tif ( $( event.target ).closest( ".ui-dialog" ).length ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// TODO: Remove hack when datepicker implements\n\t\t// the .ui-front logic (#8989)\n\t\treturn !!$( event.target ).closest( ".ui-datepicker" ).length;\n\t},\n\n\t_createOverlay: function() {\n\t\tif ( !this.options.modal ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We use a delay in case the overlay is created from an\n\t\t// event that we\'re going to be cancelling (#2804)\n\t\tvar isOpening = true;\n\t\tthis._delay(function() {\n\t\t\tisOpening = false;\n\t\t});\n\n\t\tif ( !this.document.data( "ui-dialog-overlays" ) ) {\n\n\t\t\t// Prevent use of anchors and inputs\n\t\t\t// Using _on() for an event handler shared across many instances is\n\t\t\t// safe because the dialogs stack and must be closed in reverse order\n\t\t\tthis._on( this.document, {\n\t\t\t\tfocusin: function( event ) {\n\t\t\t\t\tif ( isOpening ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !this._allowInteraction( event ) ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tthis._trackingInstances()[ 0 ]._focusTabbable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.overlay = $( "<div>" )\n\t\t\t.addClass( "ui-widget-overlay ui-front" )\n\t\t\t.appendTo( this._appendTo() );\n\t\tthis._on( this.overlay, {\n\t\t\tmousedown: "_keepFocus"\n\t\t});\n\t\tthis.document.data( "ui-dialog-overlays",\n\t\t\t(this.document.data( "ui-dialog-overlays" ) || 0) + 1 );\n\t},\n\n\t_destroyOverlay: function() {\n\t\tif ( !this.options.modal ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.overlay ) {\n\t\t\tvar overlays = this.document.data( "ui-dialog-overlays" ) - 1;\n\n\t\t\tif ( !overlays ) {\n\t\t\t\tthis.document\n\t\t\t\t\t.unbind( "focusin" )\n\t\t\t\t\t.removeData( "ui-dialog-overlays" );\n\t\t\t} else {\n\t\t\t\tthis.document.data( "ui-dialog-overlays", overlays );\n\t\t\t}\n\n\t\t\tthis.overlay.remove();\n\t\t\tthis.overlay = null;\n\t\t}\n\t}\n});\n\n\n/*!\n * jQuery UI Droppable 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/droppable/\n */\n\n\n$.widget( "ui.droppable", {\n\tversion: "1.11.4",\n\twidgetEventPrefix: "drop",\n\toptions: {\n\t\taccept: "*",\n\t\tactiveClass: false,\n\t\taddClasses: true,\n\t\tgreedy: false,\n\t\thoverClass: false,\n\t\tscope: "default",\n\t\ttolerance: "intersect",\n\n\t\t// callbacks\n\t\tactivate: null,\n\t\tdeactivate: null,\n\t\tdrop: null,\n\t\tout: null,\n\t\tover: null\n\t},\n\t_create: function() {\n\n\t\tvar proportions,\n\t\t\to = this.options,\n\t\t\taccept = o.accept;\n\n\t\tthis.isover = false;\n\t\tthis.isout = true;\n\n\t\tthis.accept = $.isFunction( accept ) ? accept : function( d ) {\n\t\t\treturn d.is( accept );\n\t\t};\n\n\t\tthis.proportions = function( /* valueToWrite */ ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\t// Store the droppable\'s proportions\n\t\t\t\tproportions = arguments[ 0 ];\n\t\t\t} else {\n\t\t\t\t// Retrieve or derive the droppable\'s proportions\n\t\t\t\treturn proportions ?\n\t\t\t\t\tproportions :\n\t\t\t\t\tproportions = {\n\t\t\t\t\t\twidth: this.element[ 0 ].offsetWidth,\n\t\t\t\t\t\theight: this.element[ 0 ].offsetHeight\n\t\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\tthis._addToManager( o.scope );\n\n\t\to.addClasses && this.element.addClass( "ui-droppable" );\n\n\t},\n\n\t_addToManager: function( scope ) {\n\t\t// Add the reference and positions to the manager\n\t\t$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];\n\t\t$.ui.ddmanager.droppables[ scope ].push( this );\n\t},\n\n\t_splice: function( drop ) {\n\t\tvar i = 0;\n\t\tfor ( ; i < drop.length; i++ ) {\n\t\t\tif ( drop[ i ] === this ) {\n\t\t\t\tdrop.splice( i, 1 );\n\t\t\t}\n\t\t}\n\t},\n\n\t_destroy: function() {\n\t\tvar drop = $.ui.ddmanager.droppables[ this.options.scope ];\n\n\t\tthis._splice( drop );\n\n\t\tthis.element.removeClass( "ui-droppable ui-droppable-disabled" );\n\t},\n\n\t_setOption: function( key, value ) {\n\n\t\tif ( key === "accept" ) {\n\t\t\tthis.accept = $.isFunction( value ) ? value : function( d ) {\n\t\t\t\treturn d.is( value );\n\t\t\t};\n\t\t} else if ( key === "scope" ) {\n\t\t\tvar drop = $.ui.ddmanager.droppables[ this.options.scope ];\n\n\t\t\tthis._splice( drop );\n\t\t\tthis._addToManager( value );\n\t\t}\n\n\t\tthis._super( key, value );\n\t},\n\n\t_activate: function( event ) {\n\t\tvar draggable = $.ui.ddmanager.current;\n\t\tif ( this.options.activeClass ) {\n\t\t\tthis.element.addClass( this.options.activeClass );\n\t\t}\n\t\tif ( draggable ){\n\t\t\tthis._trigger( "activate", event, this.ui( draggable ) );\n\t\t}\n\t},\n\n\t_deactivate: function( event ) {\n\t\tvar draggable = $.ui.ddmanager.current;\n\t\tif ( this.options.activeClass ) {\n\t\t\tthis.element.removeClass( this.options.activeClass );\n\t\t}\n\t\tif ( draggable ){\n\t\t\tthis._trigger( "deactivate", event, this.ui( draggable ) );\n\t\t}\n\t},\n\n\t_over: function( event ) {\n\n\t\tvar draggable = $.ui.ddmanager.current;\n\n\t\t// Bail if draggable and droppable are same element\n\t\tif ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\n\t\t\tif ( this.options.hoverClass ) {\n\t\t\t\tthis.element.addClass( this.options.hoverClass );\n\t\t\t}\n\t\t\tthis._trigger( "over", event, this.ui( draggable ) );\n\t\t}\n\n\t},\n\n\t_out: function( event ) {\n\n\t\tvar draggable = $.ui.ddmanager.current;\n\n\t\t// Bail if draggable and droppable are same element\n\t\tif ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\n\t\t\tif ( this.options.hoverClass ) {\n\t\t\t\tthis.element.removeClass( this.options.hoverClass );\n\t\t\t}\n\t\t\tthis._trigger( "out", event, this.ui( draggable ) );\n\t\t}\n\n\t},\n\n\t_drop: function( event, custom ) {\n\n\t\tvar draggable = custom || $.ui.ddmanager.current,\n\t\t\tchildrenIntersection = false;\n\n\t\t// Bail if draggable and droppable are same element\n\t\tif ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {\n\t\t\tvar inst = $( this ).droppable( "instance" );\n\t\t\tif (\n\t\t\t\tinst.options.greedy &&\n\t\t\t\t!inst.options.disabled &&\n\t\t\t\tinst.options.scope === draggable.options.scope &&\n\t\t\t\tinst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&\n\t\t\t\t$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )\n\t\t\t) { childrenIntersection = true; return false; }\n\t\t});\n\t\tif ( childrenIntersection ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\n\t\t\tif ( this.options.activeClass ) {\n\t\t\t\tthis.element.removeClass( this.options.activeClass );\n\t\t\t}\n\t\t\tif ( this.options.hoverClass ) {\n\t\t\t\tthis.element.removeClass( this.options.hoverClass );\n\t\t\t}\n\t\t\tthis._trigger( "drop", event, this.ui( draggable ) );\n\t\t\treturn this.element;\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tui: function( c ) {\n\t\treturn {\n\t\t\tdraggable: ( c.currentItem || c.element ),\n\t\t\thelper: c.helper,\n\t\t\tposition: c.position,\n\t\t\toffset: c.positionAbs\n\t\t};\n\t}\n\n});\n\n$.ui.intersect = (function() {\n\tfunction isOverAxis( x, reference, size ) {\n\t\treturn ( x >= reference ) && ( x < ( reference + size ) );\n\t}\n\n\treturn function( draggable, droppable, toleranceMode, event ) {\n\n\t\tif ( !droppable.offset ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,\n\t\t\ty1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,\n\t\t\tx2 = x1 + draggable.helperProportions.width,\n\t\t\ty2 = y1 + draggable.helperProportions.height,\n\t\t\tl = droppable.offset.left,\n\t\t\tt = droppable.offset.top,\n\t\t\tr = l + droppable.proportions().width,\n\t\t\tb = t + droppable.proportions().height;\n\n\t\tswitch ( toleranceMode ) {\n\t\tcase "fit":\n\t\t\treturn ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );\n\t\tcase "intersect":\n\t\t\treturn ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half\n\t\t\t\tx2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half\n\t\t\t\tt < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half\n\t\t\t\ty2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half\n\t\tcase "pointer":\n\t\t\treturn isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );\n\t\tcase "touch":\n\t\t\treturn (\n\t\t\t\t( y1 >= t && y1 <= b ) || // Top edge touching\n\t\t\t\t( y2 >= t && y2 <= b ) || // Bottom edge touching\n\t\t\t\t( y1 < t && y2 > b ) // Surrounded vertically\n\t\t\t) && (\n\t\t\t\t( x1 >= l && x1 <= r ) || // Left edge touching\n\t\t\t\t( x2 >= l && x2 <= r ) || // Right edge touching\n\t\t\t\t( x1 < l && x2 > r ) // Surrounded horizontally\n\t\t\t);\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t};\n})();\n\n/*\n\tThis manager tracks offsets of draggables and droppables\n*/\n$.ui.ddmanager = {\n\tcurrent: null,\n\tdroppables: { "default": [] },\n\tprepareOffsets: function( t, event ) {\n\n\t\tvar i, j,\n\t\t\tm = $.ui.ddmanager.droppables[ t.options.scope ] || [],\n\t\t\ttype = event ? event.type : null, // workaround for #2317\n\t\t\tlist = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();\n\n\t\tdroppablesLoop: for ( i = 0; i < m.length; i++ ) {\n\n\t\t\t// No disabled and non-accepted\n\t\t\tif ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Filter out elements in the current dragged item\n\t\t\tfor ( j = 0; j < list.length; j++ ) {\n\t\t\t\tif ( list[ j ] === m[ i ].element[ 0 ] ) {\n\t\t\t\t\tm[ i ].proportions().height = 0;\n\t\t\t\t\tcontinue droppablesLoop;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm[ i ].visible = m[ i ].element.css( "display" ) !== "none";\n\t\t\tif ( !m[ i ].visible ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Activate the droppable if used directly from draggables\n\t\t\tif ( type === "mousedown" ) {\n\t\t\t\tm[ i ]._activate.call( m[ i ], event );\n\t\t\t}\n\n\t\t\tm[ i ].offset = m[ i ].element.offset();\n\t\t\tm[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });\n\n\t\t}\n\n\t},\n\tdrop: function( draggable, event ) {\n\n\t\tvar dropped = false;\n\t\t// Create a copy of the droppables in case the list changes during the drop (#9116)\n\t\t$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {\n\n\t\t\tif ( !this.options ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {\n\t\t\t\tdropped = this._drop.call( this, event ) || dropped;\n\t\t\t}\n\n\t\t\tif ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\n\t\t\t\tthis.isout = true;\n\t\t\t\tthis.isover = false;\n\t\t\t\tthis._deactivate.call( this, event );\n\t\t\t}\n\n\t\t});\n\t\treturn dropped;\n\n\t},\n\tdragStart: function( draggable, event ) {\n\t\t// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)\n\t\tdraggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {\n\t\t\tif ( !draggable.options.refreshPositions ) {\n\t\t\t\t$.ui.ddmanager.prepareOffsets( draggable, event );\n\t\t\t}\n\t\t});\n\t},\n\tdrag: function( draggable, event ) {\n\n\t\t// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.\n\t\tif ( draggable.options.refreshPositions ) {\n\t\t\t$.ui.ddmanager.prepareOffsets( draggable, event );\n\t\t}\n\n\t\t// Run through all droppables and check their positions based on specific tolerance options\n\t\t$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {\n\n\t\t\tif ( this.options.disabled || this.greedyChild || !this.visible ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar parentInstance, scope, parent,\n\t\t\t\tintersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),\n\t\t\t\tc = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );\n\t\t\tif ( !c ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( this.options.greedy ) {\n\t\t\t\t// find droppable parents with same scope\n\t\t\t\tscope = this.options.scope;\n\t\t\t\tparent = this.element.parents( ":data(ui-droppable)" ).filter(function() {\n\t\t\t\t\treturn $( this ).droppable( "instance" ).options.scope === scope;\n\t\t\t\t});\n\n\t\t\t\tif ( parent.length ) {\n\t\t\t\t\tparentInstance = $( parent[ 0 ] ).droppable( "instance" );\n\t\t\t\t\tparentInstance.greedyChild = ( c === "isover" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we just moved into a greedy child\n\t\t\tif ( parentInstance && c === "isover" ) {\n\t\t\t\tparentInstance.isover = false;\n\t\t\t\tparentInstance.isout = true;\n\t\t\t\tparentInstance._out.call( parentInstance, event );\n\t\t\t}\n\n\t\t\tthis[ c ] = true;\n\t\t\tthis[c === "isout" ? "isover" : "isout"] = false;\n\t\t\tthis[c === "isover" ? "_over" : "_out"].call( this, event );\n\n\t\t\t// we just moved out of a greedy child\n\t\t\tif ( parentInstance && c === "isout" ) {\n\t\t\t\tparentInstance.isout = false;\n\t\t\t\tparentInstance.isover = true;\n\t\t\t\tparentInstance._over.call( parentInstance, event );\n\t\t\t}\n\t\t});\n\n\t},\n\tdragStop: function( draggable, event ) {\n\t\tdraggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );\n\t\t// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)\n\t\tif ( !draggable.options.refreshPositions ) {\n\t\t\t$.ui.ddmanager.prepareOffsets( draggable, event );\n\t\t}\n\t}\n};\n\nvar droppable = $.ui.droppable;\n\n\n/*!\n * jQuery UI Effects 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/effects-core/\n */\n\n\nvar dataSpace = "ui-effects-",\n\n\t// Create a local jQuery because jQuery Color relies on it and the\n\t// global may not exist with AMD and a custom build (#10199)\n\tjQuery = $;\n\n$.effects = {\n\teffect: {}\n};\n\n/*!\n * jQuery Color Animations v2.1.2\n * https://github.com/jquery/jquery-color\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * Date: Wed Jan 16 08:47:09 2013 -0600\n */\n(function( jQuery, undefined ) {\n\n\tvar stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",\n\n\t// plusequals test for += 100 -= 100\n\trplusequals = /^([\\-+])=\\s*(\\d+\\.?\\d*)/,\n\t// a set of RE\'s that can match strings and generate color tuples.\n\tstringParsers = [ {\n\t\t\tre: /rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\texecResult[ 1 ],\n\t\t\t\t\texecResult[ 2 ],\n\t\t\t\t\texecResult[ 3 ],\n\t\t\t\t\texecResult[ 4 ]\n\t\t\t\t];\n\t\t\t}\n\t\t}, {\n\t\t\tre: /rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\texecResult[ 1 ] * 2.55,\n\t\t\t\t\texecResult[ 2 ] * 2.55,\n\t\t\t\t\texecResult[ 3 ] * 2.55,\n\t\t\t\t\texecResult[ 4 ]\n\t\t\t\t];\n\t\t\t}\n\t\t}, {\n\t\t\t// this regex ignores A-F because it\'s compared against an already lowercased string\n\t\t\tre: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\tparseInt( execResult[ 1 ], 16 ),\n\t\t\t\t\tparseInt( execResult[ 2 ], 16 ),\n\t\t\t\t\tparseInt( execResult[ 3 ], 16 )\n\t\t\t\t];\n\t\t\t}\n\t\t}, {\n\t\t\t// this regex ignores A-F because it\'s compared against an already lowercased string\n\t\t\tre: /#([a-f0-9])([a-f0-9])([a-f0-9])/,\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\tparseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),\n\t\t\t\t\tparseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),\n\t\t\t\t\tparseInt( execResult[ 3 ] + execResult[ 3 ], 16 )\n\t\t\t\t];\n\t\t\t}\n\t\t}, {\n\t\t\tre: /hsla?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tspace: "hsla",\n\t\t\tparse: function( execResult ) {\n\t\t\t\treturn [\n\t\t\t\t\texecResult[ 1 ],\n\t\t\t\t\texecResult[ 2 ] / 100,\n\t\t\t\t\texecResult[ 3 ] / 100,\n\t\t\t\t\texecResult[ 4 ]\n\t\t\t\t];\n\t\t\t}\n\t\t} ],\n\n\t// jQuery.Color( )\n\tcolor = jQuery.Color = function( color, green, blue, alpha ) {\n\t\treturn new jQuery.Color.fn.parse( color, green, blue, alpha );\n\t},\n\tspaces = {\n\t\trgba: {\n\t\t\tprops: {\n\t\t\t\tred: {\n\t\t\t\t\tidx: 0,\n\t\t\t\t\ttype: "byte"\n\t\t\t\t},\n\t\t\t\tgreen: {\n\t\t\t\t\tidx: 1,\n\t\t\t\t\ttype: "byte"\n\t\t\t\t},\n\t\t\t\tblue: {\n\t\t\t\t\tidx: 2,\n\t\t\t\t\ttype: "byte"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\thsla: {\n\t\t\tprops: {\n\t\t\t\thue: {\n\t\t\t\t\tidx: 0,\n\t\t\t\t\ttype: "degrees"\n\t\t\t\t},\n\t\t\t\tsaturation: {\n\t\t\t\t\tidx: 1,\n\t\t\t\t\ttype: "percent"\n\t\t\t\t},\n\t\t\t\tlightness: {\n\t\t\t\t\tidx: 2,\n\t\t\t\t\ttype: "percent"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tpropTypes = {\n\t\t"byte": {\n\t\t\tfloor: true,\n\t\t\tmax: 255\n\t\t},\n\t\t"percent": {\n\t\t\tmax: 1\n\t\t},\n\t\t"degrees": {\n\t\t\tmod: 360,\n\t\t\tfloor: true\n\t\t}\n\t},\n\tsupport = color.support = {},\n\n\t// element for support tests\n\tsupportElem = jQuery( "<p>" )[ 0 ],\n\n\t// colors = jQuery.Color.names\n\tcolors,\n\n\t// local aliases of functions called often\n\teach = jQuery.each;\n\n// determine rgba support immediately\nsupportElem.style.cssText = "background-color:rgba(1,1,1,.5)";\nsupport.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;\n\n// define cache name and alpha properties\n// for rgba and hsla spaces\neach( spaces, function( spaceName, space ) {\n\tspace.cache = "_" + spaceName;\n\tspace.props.alpha = {\n\t\tidx: 3,\n\t\ttype: "percent",\n\t\tdef: 1\n\t};\n});\n\nfunction clamp( value, prop, allowEmpty ) {\n\tvar type = propTypes[ prop.type ] || {};\n\n\tif ( value == null ) {\n\t\treturn (allowEmpty || !prop.def) ? null : prop.def;\n\t}\n\n\t// ~~ is an short way of doing floor for positive numbers\n\tvalue = type.floor ? ~~value : parseFloat( value );\n\n\t// IE will pass in empty strings as value for alpha,\n\t// which will hit this case\n\tif ( isNaN( value ) ) {\n\t\treturn prop.def;\n\t}\n\n\tif ( type.mod ) {\n\t\t// we add mod before modding to make sure that negatives values\n\t\t// get converted properly: -10 -> 350\n\t\treturn (value + type.mod) % type.mod;\n\t}\n\n\t// for now all property types without mod have min and max\n\treturn 0 > value ? 0 : type.max < value ? type.max : value;\n}\n\nfunction stringParse( string ) {\n\tvar inst = color(),\n\t\trgba = inst._rgba = [];\n\n\tstring = string.toLowerCase();\n\n\teach( stringParsers, function( i, parser ) {\n\t\tvar parsed,\n\t\t\tmatch = parser.re.exec( string ),\n\t\t\tvalues = match && parser.parse( match ),\n\t\t\tspaceName = parser.space || "rgba";\n\n\t\tif ( values ) {\n\t\t\tparsed = inst[ spaceName ]( values );\n\n\t\t\t// if this was an rgba parse the assignment might happen twice\n\t\t\t// oh well....\n\t\t\tinst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];\n\t\t\trgba = inst._rgba = parsed._rgba;\n\n\t\t\t// exit each( stringParsers ) here because we matched\n\t\t\treturn false;\n\t\t}\n\t});\n\n\t// Found a stringParser that handled it\n\tif ( rgba.length ) {\n\n\t\t// if this came from a parsed string, force "transparent" when alpha is 0\n\t\t// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)\n\t\tif ( rgba.join() === "0,0,0,0" ) {\n\t\t\tjQuery.extend( rgba, colors.transparent );\n\t\t}\n\t\treturn inst;\n\t}\n\n\t// named colors\n\treturn colors[ string ];\n}\n\ncolor.fn = jQuery.extend( color.prototype, {\n\tparse: function( red, green, blue, alpha ) {\n\t\tif ( red === undefined ) {\n\t\t\tthis._rgba = [ null, null, null, null ];\n\t\t\treturn this;\n\t\t}\n\t\tif ( red.jquery || red.nodeType ) {\n\t\t\tred = jQuery( red ).css( green );\n\t\t\tgreen = undefined;\n\t\t}\n\n\t\tvar inst = this,\n\t\t\ttype = jQuery.type( red ),\n\t\t\trgba = this._rgba = [];\n\n\t\t// more than 1 argument specified - assume ( red, green, blue, alpha )\n\t\tif ( green !== undefined ) {\n\t\t\tred = [ red, green, blue, alpha ];\n\t\t\ttype = "array";\n\t\t}\n\n\t\tif ( type === "string" ) {\n\t\t\treturn this.parse( stringParse( red ) || colors._default );\n\t\t}\n\n\t\tif ( type === "array" ) {\n\t\t\teach( spaces.rgba.props, function( key, prop ) {\n\t\t\t\trgba[ prop.idx ] = clamp( red[ prop.idx ], prop );\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( type === "object" ) {\n\t\t\tif ( red instanceof color ) {\n\t\t\t\teach( spaces, function( spaceName, space ) {\n\t\t\t\t\tif ( red[ space.cache ] ) {\n\t\t\t\t\t\tinst[ space.cache ] = red[ space.cache ].slice();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\teach( spaces, function( spaceName, space ) {\n\t\t\t\t\tvar cache = space.cache;\n\t\t\t\t\teach( space.props, function( key, prop ) {\n\n\t\t\t\t\t\t// if the cache doesn\'t exist, and we know how to convert\n\t\t\t\t\t\tif ( !inst[ cache ] && space.to ) {\n\n\t\t\t\t\t\t\t// if the value was null, we don\'t need to copy it\n\t\t\t\t\t\t\t// if the key was alpha, we don\'t need to copy it either\n\t\t\t\t\t\t\tif ( key === "alpha" || red[ key ] == null ) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinst[ cache ] = space.to( inst._rgba );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// this is the only case where we allow nulls for ALL properties.\n\t\t\t\t\t\t// call clamp with alwaysAllowEmpty\n\t\t\t\t\t\tinst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );\n\t\t\t\t\t});\n\n\t\t\t\t\t// everything defined but alpha?\n\t\t\t\t\tif ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {\n\t\t\t\t\t\t// use the default of 1\n\t\t\t\t\t\tinst[ cache ][ 3 ] = 1;\n\t\t\t\t\t\tif ( space.from ) {\n\t\t\t\t\t\t\tinst._rgba = space.from( inst[ cache ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t},\n\tis: function( compare ) {\n\t\tvar is = color( compare ),\n\t\t\tsame = true,\n\t\t\tinst = this;\n\n\t\teach( spaces, function( _, space ) {\n\t\t\tvar localCache,\n\t\t\t\tisCache = is[ space.cache ];\n\t\t\tif (isCache) {\n\t\t\t\tlocalCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];\n\t\t\t\teach( space.props, function( _, prop ) {\n\t\t\t\t\tif ( isCache[ prop.idx ] != null ) {\n\t\t\t\t\t\tsame = ( isCache[ prop.idx ] === localCache[ prop.idx ] );\n\t\t\t\t\t\treturn same;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn same;\n\t\t});\n\t\treturn same;\n\t},\n\t_space: function() {\n\t\tvar used = [],\n\t\t\tinst = this;\n\t\teach( spaces, function( spaceName, space ) {\n\t\t\tif ( inst[ space.cache ] ) {\n\t\t\t\tused.push( spaceName );\n\t\t\t}\n\t\t});\n\t\treturn used.pop();\n\t},\n\ttransition: function( other, distance ) {\n\t\tvar end = color( other ),\n\t\t\tspaceName = end._space(),\n\t\t\tspace = spaces[ spaceName ],\n\t\t\tstartColor = this.alpha() === 0 ? color( "transparent" ) : this,\n\t\t\tstart = startColor[ space.cache ] || space.to( startColor._rgba ),\n\t\t\tresult = start.slice();\n\n\t\tend = end[ space.cache ];\n\t\teach( space.props, function( key, prop ) {\n\t\t\tvar index = prop.idx,\n\t\t\t\tstartValue = start[ index ],\n\t\t\t\tendValue = end[ index ],\n\t\t\t\ttype = propTypes[ prop.type ] || {};\n\n\t\t\t// if null, don\'t override start value\n\t\t\tif ( endValue === null ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// if null - use end\n\t\t\tif ( startValue === null ) {\n\t\t\t\tresult[ index ] = endValue;\n\t\t\t} else {\n\t\t\t\tif ( type.mod ) {\n\t\t\t\t\tif ( endValue - startValue > type.mod / 2 ) {\n\t\t\t\t\t\tstartValue += type.mod;\n\t\t\t\t\t} else if ( startValue - endValue > type.mod / 2 ) {\n\t\t\t\t\t\tstartValue -= type.mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );\n\t\t\t}\n\t\t});\n\t\treturn this[ spaceName ]( result );\n\t},\n\tblend: function( opaque ) {\n\t\t// if we are already opaque - return ourself\n\t\tif ( this._rgba[ 3 ] === 1 ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tvar rgb = this._rgba.slice(),\n\t\t\ta = rgb.pop(),\n\t\t\tblend = color( opaque )._rgba;\n\n\t\treturn color( jQuery.map( rgb, function( v, i ) {\n\t\t\treturn ( 1 - a ) * blend[ i ] + a * v;\n\t\t}));\n\t},\n\ttoRgbaString: function() {\n\t\tvar prefix = "rgba(",\n\t\t\trgba = jQuery.map( this._rgba, function( v, i ) {\n\t\t\t\treturn v == null ? ( i > 2 ? 1 : 0 ) : v;\n\t\t\t});\n\n\t\tif ( rgba[ 3 ] === 1 ) {\n\t\t\trgba.pop();\n\t\t\tprefix = "rgb(";\n\t\t}\n\n\t\treturn prefix + rgba.join() + ")";\n\t},\n\ttoHslaString: function() {\n\t\tvar prefix = "hsla(",\n\t\t\thsla = jQuery.map( this.hsla(), function( v, i ) {\n\t\t\t\tif ( v == null ) {\n\t\t\t\t\tv = i > 2 ? 1 : 0;\n\t\t\t\t}\n\n\t\t\t\t// catch 1 and 2\n\t\t\t\tif ( i && i < 3 ) {\n\t\t\t\t\tv = Math.round( v * 100 ) + "%";\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t});\n\n\t\tif ( hsla[ 3 ] === 1 ) {\n\t\t\thsla.pop();\n\t\t\tprefix = "hsl(";\n\t\t}\n\t\treturn prefix + hsla.join() + ")";\n\t},\n\ttoHexString: function( includeAlpha ) {\n\t\tvar rgba = this._rgba.slice(),\n\t\t\talpha = rgba.pop();\n\n\t\tif ( includeAlpha ) {\n\t\t\trgba.push( ~~( alpha * 255 ) );\n\t\t}\n\n\t\treturn "#" + jQuery.map( rgba, function( v ) {\n\n\t\t\t// default to 0 when nulls exist\n\t\t\tv = ( v || 0 ).toString( 16 );\n\t\t\treturn v.length === 1 ? "0" + v : v;\n\t\t}).join("");\n\t},\n\ttoString: function() {\n\t\treturn this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();\n\t}\n});\ncolor.fn.parse.prototype = color.fn;\n\n// hsla conversions adapted from:\n// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021\n\nfunction hue2rgb( p, q, h ) {\n\th = ( h + 1 ) % 1;\n\tif ( h * 6 < 1 ) {\n\t\treturn p + ( q - p ) * h * 6;\n\t}\n\tif ( h * 2 < 1) {\n\t\treturn q;\n\t}\n\tif ( h * 3 < 2 ) {\n\t\treturn p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;\n\t}\n\treturn p;\n}\n\nspaces.hsla.to = function( rgba ) {\n\tif ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {\n\t\treturn [ null, null, null, rgba[ 3 ] ];\n\t}\n\tvar r = rgba[ 0 ] / 255,\n\t\tg = rgba[ 1 ] / 255,\n\t\tb = rgba[ 2 ] / 255,\n\t\ta = rgba[ 3 ],\n\t\tmax = Math.max( r, g, b ),\n\t\tmin = Math.min( r, g, b ),\n\t\tdiff = max - min,\n\t\tadd = max + min,\n\t\tl = add * 0.5,\n\t\th, s;\n\n\tif ( min === max ) {\n\t\th = 0;\n\t} else if ( r === max ) {\n\t\th = ( 60 * ( g - b ) / diff ) + 360;\n\t} else if ( g === max ) {\n\t\th = ( 60 * ( b - r ) / diff ) + 120;\n\t} else {\n\t\th = ( 60 * ( r - g ) / diff ) + 240;\n\t}\n\n\t// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%\n\t// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)\n\tif ( diff === 0 ) {\n\t\ts = 0;\n\t} else if ( l <= 0.5 ) {\n\t\ts = diff / add;\n\t} else {\n\t\ts = diff / ( 2 - add );\n\t}\n\treturn [ Math.round(h) % 360, s, l, a == null ? 1 : a ];\n};\n\nspaces.hsla.from = function( hsla ) {\n\tif ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {\n\t\treturn [ null, null, null, hsla[ 3 ] ];\n\t}\n\tvar h = hsla[ 0 ] / 360,\n\t\ts = hsla[ 1 ],\n\t\tl = hsla[ 2 ],\n\t\ta = hsla[ 3 ],\n\t\tq = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,\n\t\tp = 2 * l - q;\n\n\treturn [\n\t\tMath.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),\n\t\tMath.round( hue2rgb( p, q, h ) * 255 ),\n\t\tMath.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),\n\t\ta\n\t];\n};\n\neach( spaces, function( spaceName, space ) {\n\tvar props = space.props,\n\t\tcache = space.cache,\n\t\tto = space.to,\n\t\tfrom = space.from;\n\n\t// makes rgba() and hsla()\n\tcolor.fn[ spaceName ] = function( value ) {\n\n\t\t// generate a cache for this space if it doesn\'t exist\n\t\tif ( to && !this[ cache ] ) {\n\t\t\tthis[ cache ] = to( this._rgba );\n\t\t}\n\t\tif ( value === undefined ) {\n\t\t\treturn this[ cache ].slice();\n\t\t}\n\n\t\tvar ret,\n\t\t\ttype = jQuery.type( value ),\n\t\t\tarr = ( type === "array" || type === "object" ) ? value : arguments,\n\t\t\tlocal = this[ cache ].slice();\n\n\t\teach( props, function( key, prop ) {\n\t\t\tvar val = arr[ type === "object" ? key : prop.idx ];\n\t\t\tif ( val == null ) {\n\t\t\t\tval = local[ prop.idx ];\n\t\t\t}\n\t\t\tlocal[ prop.idx ] = clamp( val, prop );\n\t\t});\n\n\t\tif ( from ) {\n\t\t\tret = color( from( local ) );\n\t\t\tret[ cache ] = local;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn color( local );\n\t\t}\n\t};\n\n\t// makes red() green() blue() alpha() hue() saturation() lightness()\n\teach( props, function( key, prop ) {\n\t\t// alpha is included in more than one space\n\t\tif ( color.fn[ key ] ) {\n\t\t\treturn;\n\t\t}\n\t\tcolor.fn[ key ] = function( value ) {\n\t\t\tvar vtype = jQuery.type( value ),\n\t\t\t\tfn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),\n\t\t\t\tlocal = this[ fn ](),\n\t\t\t\tcur = local[ prop.idx ],\n\t\t\t\tmatch;\n\n\t\t\tif ( vtype === "undefined" ) {\n\t\t\t\treturn cur;\n\t\t\t}\n\n\t\t\tif ( vtype === "function" ) {\n\t\t\t\tvalue = value.call( this, cur );\n\t\t\t\tvtype = jQuery.type( value );\n\t\t\t}\n\t\t\tif ( value == null && prop.empty ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( vtype === "string" ) {\n\t\t\t\tmatch = rplusequals.exec( value );\n\t\t\t\tif ( match ) {\n\t\t\t\t\tvalue = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tlocal[ prop.idx ] = value;\n\t\t\treturn this[ fn ]( local );\n\t\t};\n\t});\n});\n\n// add cssHook and .fx.step function for each named hook.\n// accept a space separated string of properties\ncolor.hook = function( hook ) {\n\tvar hooks = hook.split( " " );\n\teach( hooks, function( i, hook ) {\n\t\tjQuery.cssHooks[ hook ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar parsed, curElem,\n\t\t\t\t\tbackgroundColor = "";\n\n\t\t\t\tif ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {\n\t\t\t\t\tvalue = color( parsed || value );\n\t\t\t\t\tif ( !support.rgba && value._rgba[ 3 ] !== 1 ) {\n\t\t\t\t\t\tcurElem = hook === "backgroundColor" ? elem.parentNode : elem;\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\t(backgroundColor === "" || backgroundColor === "transparent") &&\n\t\t\t\t\t\t\tcurElem && curElem.style\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbackgroundColor = jQuery.css( curElem, "backgroundColor" );\n\t\t\t\t\t\t\t\tcurElem = curElem.parentNode;\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue = value.blend( backgroundColor && backgroundColor !== "transparent" ?\n\t\t\t\t\t\t\tbackgroundColor :\n\t\t\t\t\t\t\t"_default" );\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = value.toRgbaString();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\telem.style[ hook ] = value;\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// wrapped to prevent IE from throwing errors on "invalid" values like \'auto\' or \'inherit\'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tjQuery.fx.step[ hook ] = function( fx ) {\n\t\t\tif ( !fx.colorInit ) {\n\t\t\t\tfx.start = color( fx.elem, hook );\n\t\t\t\tfx.end = color( fx.end );\n\t\t\t\tfx.colorInit = true;\n\t\t\t}\n\t\t\tjQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );\n\t\t};\n\t});\n\n};\n\ncolor.hook( stepHooks );\n\njQuery.cssHooks.borderColor = {\n\texpand: function( value ) {\n\t\tvar expanded = {};\n\n\t\teach( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {\n\t\t\texpanded[ "border" + part + "Color" ] = value;\n\t\t});\n\t\treturn expanded;\n\t}\n};\n\n// Basic color names only.\n// Usage of any of the other color names requires adding yourself or including\n// jquery.color.svg-names.js.\ncolors = jQuery.Color.names = {\n\t// 4.1. Basic color keywords\n\taqua: "#00ffff",\n\tblack: "#000000",\n\tblue: "#0000ff",\n\tfuchsia: "#ff00ff",\n\tgray: "#808080",\n\tgreen: "#008000",\n\tlime: "#00ff00",\n\tmaroon: "#800000",\n\tnavy: "#000080",\n\tolive: "#808000",\n\tpurple: "#800080",\n\tred: "#ff0000",\n\tsilver: "#c0c0c0",\n\tteal: "#008080",\n\twhite: "#ffffff",\n\tyellow: "#ffff00",\n\n\t// 4.2.3. "transparent" color keyword\n\ttransparent: [ null, null, null, 0 ],\n\n\t_default: "#ffffff"\n};\n\n})( jQuery );\n\n/******************************************************************************/\n/****************************** CLASS ANIMATIONS ******************************/\n/******************************************************************************/\n(function() {\n\nvar classAnimationActions = [ "add", "remove", "toggle" ],\n\tshorthandStyles = {\n\t\tborder: 1,\n\t\tborderBottom: 1,\n\t\tborderColor: 1,\n\t\tborderLeft: 1,\n\t\tborderRight: 1,\n\t\tborderTop: 1,\n\t\tborderWidth: 1,\n\t\tmargin: 1,\n\t\tpadding: 1\n\t};\n\n$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {\n\t$.fx.step[ prop ] = function( fx ) {\n\t\tif ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {\n\t\t\tjQuery.style( fx.elem, prop, fx.end );\n\t\t\tfx.setAttr = true;\n\t\t}\n\t};\n});\n\nfunction getElementStyles( elem ) {\n\tvar key, len,\n\t\tstyle = elem.ownerDocument.defaultView ?\n\t\t\telem.ownerDocument.defaultView.getComputedStyle( elem, null ) :\n\t\t\telem.currentStyle,\n\t\tstyles = {};\n\n\tif ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {\n\t\tlen = style.length;\n\t\twhile ( len-- ) {\n\t\t\tkey = style[ len ];\n\t\t\tif ( typeof style[ key ] === "string" ) {\n\t\t\t\tstyles[ $.camelCase( key ) ] = style[ key ];\n\t\t\t}\n\t\t}\n\t// support: Opera, IE <9\n\t} else {\n\t\tfor ( key in style ) {\n\t\t\tif ( typeof style[ key ] === "string" ) {\n\t\t\t\tstyles[ key ] = style[ key ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn styles;\n}\n\nfunction styleDifference( oldStyle, newStyle ) {\n\tvar diff = {},\n\t\tname, value;\n\n\tfor ( name in newStyle ) {\n\t\tvalue = newStyle[ name ];\n\t\tif ( oldStyle[ name ] !== value ) {\n\t\t\tif ( !shorthandStyles[ name ] ) {\n\t\t\t\tif ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {\n\t\t\t\t\tdiff[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn diff;\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n\t$.fn.addBack = function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t};\n}\n\n$.effects.animateClass = function( value, duration, easing, callback ) {\n\tvar o = $.speed( duration, easing, callback );\n\n\treturn this.queue( function() {\n\t\tvar animated = $( this ),\n\t\t\tbaseClass = animated.attr( "class" ) || "",\n\t\t\tapplyClassChange,\n\t\t\tallAnimations = o.children ? animated.find( "*" ).addBack() : animated;\n\n\t\t// map the animated objects to store the original styles.\n\t\tallAnimations = allAnimations.map(function() {\n\t\t\tvar el = $( this );\n\t\t\treturn {\n\t\t\t\tel: el,\n\t\t\t\tstart: getElementStyles( this )\n\t\t\t};\n\t\t});\n\n\t\t// apply class change\n\t\tapplyClassChange = function() {\n\t\t\t$.each( classAnimationActions, function(i, action) {\n\t\t\t\tif ( value[ action ] ) {\n\t\t\t\t\tanimated[ action + "Class" ]( value[ action ] );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tapplyClassChange();\n\n\t\t// map all animated objects again - calculate new styles and diff\n\t\tallAnimations = allAnimations.map(function() {\n\t\t\tthis.end = getElementStyles( this.el[ 0 ] );\n\t\t\tthis.diff = styleDifference( this.start, this.end );\n\t\t\treturn this;\n\t\t});\n\n\t\t// apply original class\n\t\tanimated.attr( "class", baseClass );\n\n\t\t// map all animated objects again - this time collecting a promise\n\t\tallAnimations = allAnimations.map(function() {\n\t\t\tvar styleInfo = this,\n\t\t\t\tdfd = $.Deferred(),\n\t\t\t\topts = $.extend({}, o, {\n\t\t\t\t\tqueue: false,\n\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\tdfd.resolve( styleInfo );\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.el.animate( this.diff, opts );\n\t\t\treturn dfd.promise();\n\t\t});\n\n\t\t// once all animations have completed:\n\t\t$.when.apply( $, allAnimations.get() ).done(function() {\n\n\t\t\t// set the final class\n\t\t\tapplyClassChange();\n\n\t\t\t// for each animated element,\n\t\t\t// clear all css properties that were animated\n\t\t\t$.each( arguments, function() {\n\t\t\t\tvar el = this.el;\n\t\t\t\t$.each( this.diff, function(key) {\n\t\t\t\t\tel.css( key, "" );\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// this is guarnteed to be there if you use jQuery.speed()\n\t\t\t// it also handles dequeuing the next anim...\n\t\t\to.complete.call( animated[ 0 ] );\n\t\t});\n\t});\n};\n\n$.fn.extend({\n\taddClass: (function( orig ) {\n\t\treturn function( classNames, speed, easing, callback ) {\n\t\t\treturn speed ?\n\t\t\t\t$.effects.animateClass.call( this,\n\t\t\t\t\t{ add: classNames }, speed, easing, callback ) :\n\t\t\t\torig.apply( this, arguments );\n\t\t};\n\t})( $.fn.addClass ),\n\n\tremoveClass: (function( orig ) {\n\t\treturn function( classNames, speed, easing, callback ) {\n\t\t\treturn arguments.length > 1 ?\n\t\t\t\t$.effects.animateClass.call( this,\n\t\t\t\t\t{ remove: classNames }, speed, easing, callback ) :\n\t\t\t\torig.apply( this, arguments );\n\t\t};\n\t})( $.fn.removeClass ),\n\n\ttoggleClass: (function( orig ) {\n\t\treturn function( classNames, force, speed, easing, callback ) {\n\t\t\tif ( typeof force === "boolean" || force === undefined ) {\n\t\t\t\tif ( !speed ) {\n\t\t\t\t\t// without speed parameter\n\t\t\t\t\treturn orig.apply( this, arguments );\n\t\t\t\t} else {\n\t\t\t\t\treturn $.effects.animateClass.call( this,\n\t\t\t\t\t\t(force ? { add: classNames } : { remove: classNames }),\n\t\t\t\t\t\tspeed, easing, callback );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// without force parameter\n\t\t\t\treturn $.effects.animateClass.call( this,\n\t\t\t\t\t{ toggle: classNames }, force, speed, easing );\n\t\t\t}\n\t\t};\n\t})( $.fn.toggleClass ),\n\n\tswitchClass: function( remove, add, speed, easing, callback) {\n\t\treturn $.effects.animateClass.call( this, {\n\t\t\tadd: add,\n\t\t\tremove: remove\n\t\t}, speed, easing, callback );\n\t}\n});\n\n})();\n\n/******************************************************************************/\n/*********************************** EFFECTS **********************************/\n/******************************************************************************/\n\n(function() {\n\n$.extend( $.effects, {\n\tversion: "1.11.4",\n\n\t// Saves a set of properties in a data storage\n\tsave: function( element, set ) {\n\t\tfor ( var i = 0; i < set.length; i++ ) {\n\t\t\tif ( set[ i ] !== null ) {\n\t\t\t\telement.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Restores a set of previously saved properties from a data storage\n\trestore: function( element, set ) {\n\t\tvar val, i;\n\t\tfor ( i = 0; i < set.length; i++ ) {\n\t\t\tif ( set[ i ] !== null ) {\n\t\t\t\tval = element.data( dataSpace + set[ i ] );\n\t\t\t\t// support: jQuery 1.6.2\n\t\t\t\t// http://bugs.jquery.com/ticket/9917\n\t\t\t\t// jQuery 1.6.2 incorrectly returns undefined for any falsy value.\n\t\t\t\t// We can\'t differentiate between "" and 0 here, so we just assume\n\t\t\t\t// empty string since it\'s likely to be a more common value...\n\t\t\t\tif ( val === undefined ) {\n\t\t\t\t\tval = "";\n\t\t\t\t}\n\t\t\t\telement.css( set[ i ], val );\n\t\t\t}\n\t\t}\n\t},\n\n\tsetMode: function( el, mode ) {\n\t\tif (mode === "toggle") {\n\t\t\tmode = el.is( ":hidden" ) ? "show" : "hide";\n\t\t}\n\t\treturn mode;\n\t},\n\n\t// Translates a [top,left] array into a baseline value\n\t// this should be a little more flexible in the future to handle a string & hash\n\tgetBaseline: function( origin, original ) {\n\t\tvar y, x;\n\t\tswitch ( origin[ 0 ] ) {\n\t\t\tcase "top": y = 0; break;\n\t\t\tcase "middle": y = 0.5; break;\n\t\t\tcase "bottom": y = 1; break;\n\t\t\tdefault: y = origin[ 0 ] / original.height;\n\t\t}\n\t\tswitch ( origin[ 1 ] ) {\n\t\t\tcase "left": x = 0; break;\n\t\t\tcase "center": x = 0.5; break;\n\t\t\tcase "right": x = 1; break;\n\t\t\tdefault: x = origin[ 1 ] / original.width;\n\t\t}\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t},\n\n\t// Wraps the element around a wrapper that copies position properties\n\tcreateWrapper: function( element ) {\n\n\t\t// if the element is already wrapped, return it\n\t\tif ( element.parent().is( ".ui-effects-wrapper" )) {\n\t\t\treturn element.parent();\n\t\t}\n\n\t\t// wrap the element\n\t\tvar props = {\n\t\t\t\twidth: element.outerWidth(true),\n\t\t\t\theight: element.outerHeight(true),\n\t\t\t\t"float": element.css( "float" )\n\t\t\t},\n\t\t\twrapper = $( "<div></div>" )\n\t\t\t\t.addClass( "ui-effects-wrapper" )\n\t\t\t\t.css({\n\t\t\t\t\tfontSize: "100%",\n\t\t\t\t\tbackground: "transparent",\n\t\t\t\t\tborder: "none",\n\t\t\t\t\tmargin: 0,\n\t\t\t\t\tpadding: 0\n\t\t\t\t}),\n\t\t\t// Store the size in case width/height are defined in % - Fixes #5245\n\t\t\tsize = {\n\t\t\t\twidth: element.width(),\n\t\t\t\theight: element.height()\n\t\t\t},\n\t\t\tactive = document.activeElement;\n\n\t\t// support: Firefox\n\t\t// Firefox incorrectly exposes anonymous content\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=561664\n\t\ttry {\n\t\t\tactive.id;\n\t\t} catch ( e ) {\n\t\t\tactive = document.body;\n\t\t}\n\n\t\telement.wrap( wrapper );\n\n\t\t// Fixes #7595 - Elements lose focus when wrapped.\n\t\tif ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\n\t\t\t$( active ).focus();\n\t\t}\n\n\t\twrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element\n\n\t\t// transfer positioning properties to the wrapper\n\t\tif ( element.css( "position" ) === "static" ) {\n\t\t\twrapper.css({ position: "relative" });\n\t\t\telement.css({ position: "relative" });\n\t\t} else {\n\t\t\t$.extend( props, {\n\t\t\t\tposition: element.css( "position" ),\n\t\t\t\tzIndex: element.css( "z-index" )\n\t\t\t});\n\t\t\t$.each([ "top", "left", "bottom", "right" ], function(i, pos) {\n\t\t\t\tprops[ pos ] = element.css( pos );\n\t\t\t\tif ( isNaN( parseInt( props[ pos ], 10 ) ) ) {\n\t\t\t\t\tprops[ pos ] = "auto";\n\t\t\t\t}\n\t\t\t});\n\t\t\telement.css({\n\t\t\t\tposition: "relative",\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\tright: "auto",\n\t\t\t\tbottom: "auto"\n\t\t\t});\n\t\t}\n\t\telement.css(size);\n\n\t\treturn wrapper.css( props ).show();\n\t},\n\n\tremoveWrapper: function( element ) {\n\t\tvar active = document.activeElement;\n\n\t\tif ( element.parent().is( ".ui-effects-wrapper" ) ) {\n\t\t\telement.parent().replaceWith( element );\n\n\t\t\t// Fixes #7595 - Elements lose focus when wrapped.\n\t\t\tif ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\n\t\t\t\t$( active ).focus();\n\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t},\n\n\tsetTransition: function( element, list, factor, value ) {\n\t\tvalue = value || {};\n\t\t$.each( list, function( i, x ) {\n\t\t\tvar unit = element.cssUnit( x );\n\t\t\tif ( unit[ 0 ] > 0 ) {\n\t\t\t\tvalue[ x ] = unit[ 0 ] * factor + unit[ 1 ];\n\t\t\t}\n\t\t});\n\t\treturn value;\n\t}\n});\n\n// return an effect options object for the given parameters:\nfunction _normalizeArguments( effect, options, speed, callback ) {\n\n\t// allow passing all options as the first parameter\n\tif ( $.isPlainObject( effect ) ) {\n\t\toptions = effect;\n\t\teffect = effect.effect;\n\t}\n\n\t// convert to an object\n\teffect = { effect: effect };\n\n\t// catch (effect, null, ...)\n\tif ( options == null ) {\n\t\toptions = {};\n\t}\n\n\t// catch (effect, callback)\n\tif ( $.isFunction( options ) ) {\n\t\tcallback = options;\n\t\tspeed = null;\n\t\toptions = {};\n\t}\n\n\t// catch (effect, speed, ?)\n\tif ( typeof options === "number" || $.fx.speeds[ options ] ) {\n\t\tcallback = speed;\n\t\tspeed = options;\n\t\toptions = {};\n\t}\n\n\t// catch (effect, options, callback)\n\tif ( $.isFunction( speed ) ) {\n\t\tcallback = speed;\n\t\tspeed = null;\n\t}\n\n\t// add options to effect\n\tif ( options ) {\n\t\t$.extend( effect, options );\n\t}\n\n\tspeed = speed || options.duration;\n\teffect.duration = $.fx.off ? 0 :\n\t\ttypeof speed === "number" ? speed :\n\t\tspeed in $.fx.speeds ? $.fx.speeds[ speed ] :\n\t\t$.fx.speeds._default;\n\n\teffect.complete = callback || options.complete;\n\n\treturn effect;\n}\n\nfunction standardAnimationOption( option ) {\n\t// Valid standard speeds (nothing, number, named speed)\n\tif ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {\n\t\treturn true;\n\t}\n\n\t// Invalid strings - treat as "normal" speed\n\tif ( typeof option === "string" && !$.effects.effect[ option ] ) {\n\t\treturn true;\n\t}\n\n\t// Complete callback\n\tif ( $.isFunction( option ) ) {\n\t\treturn true;\n\t}\n\n\t// Options hash (but not naming an effect)\n\tif ( typeof option === "object" && !option.effect ) {\n\t\treturn true;\n\t}\n\n\t// Didn\'t match any standard API\n\treturn false;\n}\n\n$.fn.extend({\n\teffect: function( /* effect, options, speed, callback */ ) {\n\t\tvar args = _normalizeArguments.apply( this, arguments ),\n\t\t\tmode = args.mode,\n\t\t\tqueue = args.queue,\n\t\t\teffectMethod = $.effects.effect[ args.effect ];\n\n\t\tif ( $.fx.off || !effectMethod ) {\n\t\t\t// delegate to the original method (e.g., .show()) if possible\n\t\t\tif ( mode ) {\n\t\t\t\treturn this[ mode ]( args.duration, args.complete );\n\t\t\t} else {\n\t\t\t\treturn this.each( function() {\n\t\t\t\t\tif ( args.complete ) {\n\t\t\t\t\t\targs.complete.call( this );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction run( next ) {\n\t\t\tvar elem = $( this ),\n\t\t\t\tcomplete = args.complete,\n\t\t\t\tmode = args.mode;\n\n\t\t\tfunction done() {\n\t\t\t\tif ( $.isFunction( complete ) ) {\n\t\t\t\t\tcomplete.call( elem[0] );\n\t\t\t\t}\n\t\t\t\tif ( $.isFunction( next ) ) {\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the element already has the correct final state, delegate to\n\t\t\t// the core methods so the internal tracking of "olddisplay" works.\n\t\t\tif ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {\n\t\t\t\telem[ mode ]();\n\t\t\t\tdone();\n\t\t\t} else {\n\t\t\t\teffectMethod.call( elem[0], args, done );\n\t\t\t}\n\t\t}\n\n\t\treturn queue === false ? this.each( run ) : this.queue( queue || "fx", run );\n\t},\n\n\tshow: (function( orig ) {\n\t\treturn function( option ) {\n\t\t\tif ( standardAnimationOption( option ) ) {\n\t\t\t\treturn orig.apply( this, arguments );\n\t\t\t} else {\n\t\t\t\tvar args = _normalizeArguments.apply( this, arguments );\n\t\t\t\targs.mode = "show";\n\t\t\t\treturn this.effect.call( this, args );\n\t\t\t}\n\t\t};\n\t})( $.fn.show ),\n\n\thide: (function( orig ) {\n\t\treturn function( option ) {\n\t\t\tif ( standardAnimationOption( option ) ) {\n\t\t\t\treturn orig.apply( this, arguments );\n\t\t\t} else {\n\t\t\t\tvar args = _normalizeArguments.apply( this, arguments );\n\t\t\t\targs.mode = "hide";\n\t\t\t\treturn this.effect.call( this, args );\n\t\t\t}\n\t\t};\n\t})( $.fn.hide ),\n\n\ttoggle: (function( orig ) {\n\t\treturn function( option ) {\n\t\t\tif ( standardAnimationOption( option ) || typeof option === "boolean" ) {\n\t\t\t\treturn orig.apply( this, arguments );\n\t\t\t} else {\n\t\t\t\tvar args = _normalizeArguments.apply( this, arguments );\n\t\t\t\targs.mode = "toggle";\n\t\t\t\treturn this.effect.call( this, args );\n\t\t\t}\n\t\t};\n\t})( $.fn.toggle ),\n\n\t// helper functions\n\tcssUnit: function(key) {\n\t\tvar style = this.css( key ),\n\t\t\tval = [];\n\n\t\t$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {\n\t\t\tif ( style.indexOf( unit ) > 0 ) {\n\t\t\t\tval = [ parseFloat( style ), unit ];\n\t\t\t}\n\t\t});\n\t\treturn val;\n\t}\n});\n\n})();\n\n/******************************************************************************/\n/*********************************** EASING ***********************************/\n/******************************************************************************/\n\n(function() {\n\n// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)\n\nvar baseEasings = {};\n\n$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {\n\tbaseEasings[ name ] = function( p ) {\n\t\treturn Math.pow( p, i + 2 );\n\t};\n});\n\n$.extend( baseEasings, {\n\tSine: function( p ) {\n\t\treturn 1 - Math.cos( p * Math.PI / 2 );\n\t},\n\tCirc: function( p ) {\n\t\treturn 1 - Math.sqrt( 1 - p * p );\n\t},\n\tElastic: function( p ) {\n\t\treturn p === 0 || p === 1 ? p :\n\t\t\t-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );\n\t},\n\tBack: function( p ) {\n\t\treturn p * p * ( 3 * p - 2 );\n\t},\n\tBounce: function( p ) {\n\t\tvar pow2,\n\t\t\tbounce = 4;\n\n\t\twhile ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}\n\t\treturn 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );\n\t}\n});\n\n$.each( baseEasings, function( name, easeIn ) {\n\t$.easing[ "easeIn" + name ] = easeIn;\n\t$.easing[ "easeOut" + name ] = function( p ) {\n\t\treturn 1 - easeIn( 1 - p );\n\t};\n\t$.easing[ "easeInOut" + name ] = function( p ) {\n\t\treturn p < 0.5 ?\n\t\t\teaseIn( p * 2 ) / 2 :\n\t\t\t1 - easeIn( p * -2 + 2 ) / 2;\n\t};\n});\n\n})();\n\nvar effect = $.effects;\n\n\n/*!\n * jQuery UI Effects Blind 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/blind-effect/\n */\n\n\nvar effectBlind = $.effects.effect.blind = function( o, done ) {\n\t// Create element\n\tvar el = $( this ),\n\t\trvertical = /up|down|vertical/,\n\t\trpositivemotion = /up|left|vertical|horizontal/,\n\t\tprops = [ "position", "top", "bottom", "left", "right", "height", "width" ],\n\t\tmode = $.effects.setMode( el, o.mode || "hide" ),\n\t\tdirection = o.direction || "up",\n\t\tvertical = rvertical.test( direction ),\n\t\tref = vertical ? "height" : "width",\n\t\tref2 = vertical ? "top" : "left",\n\t\tmotion = rpositivemotion.test( direction ),\n\t\tanimation = {},\n\t\tshow = mode === "show",\n\t\twrapper, distance, margin;\n\n\t// if already wrapped, the wrapper\'s properties are my property. #6245\n\tif ( el.parent().is( ".ui-effects-wrapper" ) ) {\n\t\t$.effects.save( el.parent(), props );\n\t} else {\n\t\t$.effects.save( el, props );\n\t}\n\tel.show();\n\twrapper = $.effects.createWrapper( el ).css({\n\t\toverflow: "hidden"\n\t});\n\n\tdistance = wrapper[ ref ]();\n\tmargin = parseFloat( wrapper.css( ref2 ) ) || 0;\n\n\tanimation[ ref ] = show ? distance : 0;\n\tif ( !motion ) {\n\t\tel\n\t\t\t.css( vertical ? "bottom" : "right", 0 )\n\t\t\t.css( vertical ? "top" : "left", "auto" )\n\t\t\t.css({ position: "absolute" });\n\n\t\tanimation[ ref2 ] = show ? margin : distance + margin;\n\t}\n\n\t// start at 0 if we are showing\n\tif ( show ) {\n\t\twrapper.css( ref, 0 );\n\t\tif ( !motion ) {\n\t\t\twrapper.css( ref2, margin + distance );\n\t\t}\n\t}\n\n\t// Animate\n\twrapper.animate( animation, {\n\t\tduration: o.duration,\n\t\teasing: o.easing,\n\t\tqueue: false,\n\t\tcomplete: function() {\n\t\t\tif ( mode === "hide" ) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore( el, props );\n\t\t\t$.effects.removeWrapper( el );\n\t\t\tdone();\n\t\t}\n\t});\n};\n\n\n/*!\n * jQuery UI Effects Bounce 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/bounce-effect/\n */\n\n\nvar effectBounce = $.effects.effect.bounce = function( o, done ) {\n\tvar el = $( this ),\n\t\tprops = [ "position", "top", "bottom", "left", "right", "height", "width" ],\n\n\t\t// defaults:\n\t\tmode = $.effects.setMode( el, o.mode || "effect" ),\n\t\thide = mode === "hide",\n\t\tshow = mode === "show",\n\t\tdirection = o.direction || "up",\n\t\tdistance = o.distance,\n\t\ttimes = o.times || 5,\n\n\t\t// number of internal animations\n\t\tanims = times * 2 + ( show || hide ? 1 : 0 ),\n\t\tspeed = o.duration / anims,\n\t\teasing = o.easing,\n\n\t\t// utility:\n\t\tref = ( direction === "up" || direction === "down" ) ? "top" : "left",\n\t\tmotion = ( direction === "up" || direction === "left" ),\n\t\ti,\n\t\tupAnim,\n\t\tdownAnim,\n\n\t\t// we will need to re-assemble the queue to stack our animations in place\n\t\tqueue = el.queue(),\n\t\tqueuelen = queue.length;\n\n\t// Avoid touching opacity to prevent clearType and PNG issues in IE\n\tif ( show || hide ) {\n\t\tprops.push( "opacity" );\n\t}\n\n\t$.effects.save( el, props );\n\tel.show();\n\t$.effects.createWrapper( el ); // Create Wrapper\n\n\t// default distance for the BIGGEST bounce is the outer Distance / 3\n\tif ( !distance ) {\n\t\tdistance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;\n\t}\n\n\tif ( show ) {\n\t\tdownAnim = { opacity: 1 };\n\t\tdownAnim[ ref ] = 0;\n\n\t\t// if we are showing, force opacity 0 and set the initial position\n\t\t// then do the "first" animation\n\t\tel.css( "opacity", 0 )\n\t\t\t.css( ref, motion ? -distance * 2 : distance * 2 )\n\t\t\t.animate( downAnim, speed, easing );\n\t}\n\n\t// start at the smallest distance if we are hiding\n\tif ( hide ) {\n\t\tdistance = distance / Math.pow( 2, times - 1 );\n\t}\n\n\tdownAnim = {};\n\tdownAnim[ ref ] = 0;\n\t// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here\n\tfor ( i = 0; i < times; i++ ) {\n\t\tupAnim = {};\n\t\tupAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;\n\n\t\tel.animate( upAnim, speed, easing )\n\t\t\t.animate( downAnim, speed, easing );\n\n\t\tdistance = hide ? distance * 2 : distance / 2;\n\t}\n\n\t// Last Bounce when Hiding\n\tif ( hide ) {\n\t\tupAnim = { opacity: 0 };\n\t\tupAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;\n\n\t\tel.animate( upAnim, speed, easing );\n\t}\n\n\tel.queue(function() {\n\t\tif ( hide ) {\n\t\t\tel.hide();\n\t\t}\n\t\t$.effects.restore( el, props );\n\t\t$.effects.removeWrapper( el );\n\t\tdone();\n\t});\n\n\t// inject all the animations we just queued to be first in line (after "inprogress")\n\tif ( queuelen > 1) {\n\t\tqueue.splice.apply( queue,\n\t\t\t[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\n\t}\n\tel.dequeue();\n\n};\n\n\n/*!\n * jQuery UI Effects Clip 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/clip-effect/\n */\n\n\nvar effectClip = $.effects.effect.clip = function( o, done ) {\n\t// Create element\n\tvar el = $( this ),\n\t\tprops = [ "position", "top", "bottom", "left", "right", "height", "width" ],\n\t\tmode = $.effects.setMode( el, o.mode || "hide" ),\n\t\tshow = mode === "show",\n\t\tdirection = o.direction || "vertical",\n\t\tvert = direction === "vertical",\n\t\tsize = vert ? "height" : "width",\n\t\tposition = vert ? "top" : "left",\n\t\tanimation = {},\n\t\twrapper, animate, distance;\n\n\t// Save & Show\n\t$.effects.save( el, props );\n\tel.show();\n\n\t// Create Wrapper\n\twrapper = $.effects.createWrapper( el ).css({\n\t\toverflow: "hidden"\n\t});\n\tanimate = ( el[0].tagName === "IMG" ) ? wrapper : el;\n\tdistance = animate[ size ]();\n\n\t// Shift\n\tif ( show ) {\n\t\tanimate.css( size, 0 );\n\t\tanimate.css( position, distance / 2 );\n\t}\n\n\t// Create Animation Object:\n\tanimation[ size ] = show ? distance : 0;\n\tanimation[ position ] = show ? 0 : distance / 2;\n\n\t// Animate\n\tanimate.animate( animation, {\n\t\tqueue: false,\n\t\tduration: o.duration,\n\t\teasing: o.easing,\n\t\tcomplete: function() {\n\t\t\tif ( !show ) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore( el, props );\n\t\t\t$.effects.removeWrapper( el );\n\t\t\tdone();\n\t\t}\n\t});\n\n};\n\n\n/*!\n * jQuery UI Effects Drop 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/drop-effect/\n */\n\n\nvar effectDrop = $.effects.effect.drop = function( o, done ) {\n\n\tvar el = $( this ),\n\t\tprops = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],\n\t\tmode = $.effects.setMode( el, o.mode || "hide" ),\n\t\tshow = mode === "show",\n\t\tdirection = o.direction || "left",\n\t\tref = ( direction === "up" || direction === "down" ) ? "top" : "left",\n\t\tmotion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",\n\t\tanimation = {\n\t\t\topacity: show ? 1 : 0\n\t\t},\n\t\tdistance;\n\n\t// Adjust\n\t$.effects.save( el, props );\n\tel.show();\n\t$.effects.createWrapper( el );\n\n\tdistance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;\n\n\tif ( show ) {\n\t\tel\n\t\t\t.css( "opacity", 0 )\n\t\t\t.css( ref, motion === "pos" ? -distance : distance );\n\t}\n\n\t// Animation\n\tanimation[ ref ] = ( show ?\n\t\t( motion === "pos" ? "+=" : "-=" ) :\n\t\t( motion === "pos" ? "-=" : "+=" ) ) +\n\t\tdistance;\n\n\t// Animate\n\tel.animate( animation, {\n\t\tqueue: false,\n\t\tduration: o.duration,\n\t\teasing: o.easing,\n\t\tcomplete: function() {\n\t\t\tif ( mode === "hide" ) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore( el, props );\n\t\t\t$.effects.removeWrapper( el );\n\t\t\tdone();\n\t\t}\n\t});\n};\n\n\n/*!\n * jQuery UI Effects Explode 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/explode-effect/\n */\n\n\nvar effectExplode = $.effects.effect.explode = function( o, done ) {\n\n\tvar rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,\n\t\tcells = rows,\n\t\tel = $( this ),\n\t\tmode = $.effects.setMode( el, o.mode || "hide" ),\n\t\tshow = mode === "show",\n\n\t\t// show and then visibility:hidden the element before calculating offset\n\t\toffset = el.show().css( "visibility", "hidden" ).offset(),\n\n\t\t// width and height of a piece\n\t\twidth = Math.ceil( el.outerWidth() / cells ),\n\t\theight = Math.ceil( el.outerHeight() / rows ),\n\t\tpieces = [],\n\n\t\t// loop\n\t\ti, j, left, top, mx, my;\n\n\t// children animate complete:\n\tfunction childComplete() {\n\t\tpieces.push( this );\n\t\tif ( pieces.length === rows * cells ) {\n\t\t\tanimComplete();\n\t\t}\n\t}\n\n\t// clone the element for each row and cell.\n\tfor ( i = 0; i < rows ; i++ ) { // ===>\n\t\ttop = offset.top + i * height;\n\t\tmy = i - ( rows - 1 ) / 2 ;\n\n\t\tfor ( j = 0; j < cells ; j++ ) { // |||\n\t\t\tleft = offset.left + j * width;\n\t\t\tmx = j - ( cells - 1 ) / 2 ;\n\n\t\t\t// Create a clone of the now hidden main element that will be absolute positioned\n\t\t\t// within a wrapper div off the -left and -top equal to size of our pieces\n\t\t\tel\n\t\t\t\t.clone()\n\t\t\t\t.appendTo( "body" )\n\t\t\t\t.wrap( "<div></div>" )\n\t\t\t\t.css({\n\t\t\t\t\tposition: "absolute",\n\t\t\t\t\tvisibility: "visible",\n\t\t\t\t\tleft: -j * width,\n\t\t\t\t\ttop: -i * height\n\t\t\t\t})\n\n\t\t\t// select the wrapper - make it overflow: hidden and absolute positioned based on\n\t\t\t// where the original was located +left and +top equal to the size of pieces\n\t\t\t\t.parent()\n\t\t\t\t.addClass( "ui-effects-explode" )\n\t\t\t\t.css({\n\t\t\t\t\tposition: "absolute",\n\t\t\t\t\toverflow: "hidden",\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height,\n\t\t\t\t\tleft: left + ( show ? mx * width : 0 ),\n\t\t\t\t\ttop: top + ( show ? my * height : 0 ),\n\t\t\t\t\topacity: show ? 0 : 1\n\t\t\t\t}).animate({\n\t\t\t\t\tleft: left + ( show ? 0 : mx * width ),\n\t\t\t\t\ttop: top + ( show ? 0 : my * height ),\n\t\t\t\t\topacity: show ? 1 : 0\n\t\t\t\t}, o.duration || 500, o.easing, childComplete );\n\t\t}\n\t}\n\n\tfunction animComplete() {\n\t\tel.css({\n\t\t\tvisibility: "visible"\n\t\t});\n\t\t$( pieces ).remove();\n\t\tif ( !show ) {\n\t\t\tel.hide();\n\t\t}\n\t\tdone();\n\t}\n};\n\n\n/*!\n * jQuery UI Effects Fade 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/fade-effect/\n */\n\n\nvar effectFade = $.effects.effect.fade = function( o, done ) {\n\tvar el = $( this ),\n\t\tmode = $.effects.setMode( el, o.mode || "toggle" );\n\n\tel.animate({\n\t\topacity: mode\n\t}, {\n\t\tqueue: false,\n\t\tduration: o.duration,\n\t\teasing: o.easing,\n\t\tcomplete: done\n\t});\n};\n\n\n/*!\n * jQuery UI Effects Fold 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/fold-effect/\n */\n\n\nvar effectFold = $.effects.effect.fold = function( o, done ) {\n\n\t// Create element\n\tvar el = $( this ),\n\t\tprops = [ "position", "top", "bottom", "left", "right", "height", "width" ],\n\t\tmode = $.effects.setMode( el, o.mode || "hide" ),\n\t\tshow = mode === "show",\n\t\thide = mode === "hide",\n\t\tsize = o.size || 15,\n\t\tpercent = /([0-9]+)%/.exec( size ),\n\t\thorizFirst = !!o.horizFirst,\n\t\twidthFirst = show !== horizFirst,\n\t\tref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],\n\t\tduration = o.duration / 2,\n\t\twrapper, distance,\n\t\tanimation1 = {},\n\t\tanimation2 = {};\n\n\t$.effects.save( el, props );\n\tel.show();\n\n\t// Create Wrapper\n\twrapper = $.effects.createWrapper( el ).css({\n\t\toverflow: "hidden"\n\t});\n\tdistance = widthFirst ?\n\t\t[ wrapper.width(), wrapper.height() ] :\n\t\t[ wrapper.height(), wrapper.width() ];\n\n\tif ( percent ) {\n\t\tsize = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];\n\t}\n\tif ( show ) {\n\t\twrapper.css( horizFirst ? {\n\t\t\theight: 0,\n\t\t\twidth: size\n\t\t} : {\n\t\t\theight: size,\n\t\t\twidth: 0\n\t\t});\n\t}\n\n\t// Animation\n\tanimation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;\n\tanimation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;\n\n\t// Animate\n\twrapper\n\t\t.animate( animation1, duration, o.easing )\n\t\t.animate( animation2, duration, o.easing, function() {\n\t\t\tif ( hide ) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore( el, props );\n\t\t\t$.effects.removeWrapper( el );\n\t\t\tdone();\n\t\t});\n\n};\n\n\n/*!\n * jQuery UI Effects Highlight 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/highlight-effect/\n */\n\n\nvar effectHighlight = $.effects.effect.highlight = function( o, done ) {\n\tvar elem = $( this ),\n\t\tprops = [ "backgroundImage", "backgroundColor", "opacity" ],\n\t\tmode = $.effects.setMode( elem, o.mode || "show" ),\n\t\tanimation = {\n\t\t\tbackgroundColor: elem.css( "backgroundColor" )\n\t\t};\n\n\tif (mode === "hide") {\n\t\tanimation.opacity = 0;\n\t}\n\n\t$.effects.save( elem, props );\n\n\telem\n\t\t.show()\n\t\t.css({\n\t\t\tbackgroundImage: "none",\n\t\t\tbackgroundColor: o.color || "#ffff99"\n\t\t})\n\t\t.animate( animation, {\n\t\t\tqueue: false,\n\t\t\tduration: o.duration,\n\t\t\teasing: o.easing,\n\t\t\tcomplete: function() {\n\t\t\t\tif ( mode === "hide" ) {\n\t\t\t\t\telem.hide();\n\t\t\t\t}\n\t\t\t\t$.effects.restore( elem, props );\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n};\n\n\n/*!\n * jQuery UI Effects Size 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/size-effect/\n */\n\n\nvar effectSize = $.effects.effect.size = function( o, done ) {\n\n\t// Create element\n\tvar original, baseline, factor,\n\t\tel = $( this ),\n\t\tprops0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],\n\n\t\t// Always restore\n\t\tprops1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],\n\n\t\t// Copy for children\n\t\tprops2 = [ "width", "height", "overflow" ],\n\t\tcProps = [ "fontSize" ],\n\t\tvProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],\n\t\thProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],\n\n\t\t// Set options\n\t\tmode = $.effects.setMode( el, o.mode || "effect" ),\n\t\trestore = o.restore || mode !== "effect",\n\t\tscale = o.scale || "both",\n\t\torigin = o.origin || [ "middle", "center" ],\n\t\tposition = el.css( "position" ),\n\t\tprops = restore ? props0 : props1,\n\t\tzero = {\n\t\t\theight: 0,\n\t\t\twidth: 0,\n\t\t\touterHeight: 0,\n\t\t\touterWidth: 0\n\t\t};\n\n\tif ( mode === "show" ) {\n\t\tel.show();\n\t}\n\toriginal = {\n\t\theight: el.height(),\n\t\twidth: el.width(),\n\t\touterHeight: el.outerHeight(),\n\t\touterWidth: el.outerWidth()\n\t};\n\n\tif ( o.mode === "toggle" && mode === "show" ) {\n\t\tel.from = o.to || zero;\n\t\tel.to = o.from || original;\n\t} else {\n\t\tel.from = o.from || ( mode === "show" ? zero : original );\n\t\tel.to = o.to || ( mode === "hide" ? zero : original );\n\t}\n\n\t// Set scaling factor\n\tfactor = {\n\t\tfrom: {\n\t\t\ty: el.from.height / original.height,\n\t\t\tx: el.from.width / original.width\n\t\t},\n\t\tto: {\n\t\t\ty: el.to.height / original.height,\n\t\t\tx: el.to.width / original.width\n\t\t}\n\t};\n\n\t// Scale the css box\n\tif ( scale === "box" || scale === "both" ) {\n\n\t\t// Vertical props scaling\n\t\tif ( factor.from.y !== factor.to.y ) {\n\t\t\tprops = props.concat( vProps );\n\t\t\tel.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );\n\t\t\tel.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );\n\t\t}\n\n\t\t// Horizontal props scaling\n\t\tif ( factor.from.x !== factor.to.x ) {\n\t\t\tprops = props.concat( hProps );\n\t\t\tel.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );\n\t\t\tel.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );\n\t\t}\n\t}\n\n\t// Scale the content\n\tif ( scale === "content" || scale === "both" ) {\n\n\t\t// Vertical props scaling\n\t\tif ( factor.from.y !== factor.to.y ) {\n\t\t\tprops = props.concat( cProps ).concat( props2 );\n\t\t\tel.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );\n\t\t\tel.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );\n\t\t}\n\t}\n\n\t$.effects.save( el, props );\n\tel.show();\n\t$.effects.createWrapper( el );\n\tel.css( "overflow", "hidden" ).css( el.from );\n\n\t// Adjust\n\tif (origin) { // Calculate baseline shifts\n\t\tbaseline = $.effects.getBaseline( origin, original );\n\t\tel.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;\n\t\tel.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;\n\t\tel.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;\n\t\tel.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;\n\t}\n\tel.css( el.from ); // set top & left\n\n\t// Animate\n\tif ( scale === "content" || scale === "both" ) { // Scale the children\n\n\t\t// Add margins/font-size\n\t\tvProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);\n\t\thProps = hProps.concat([ "marginLeft", "marginRight" ]);\n\t\tprops2 = props0.concat(vProps).concat(hProps);\n\n\t\tel.find( "*[width]" ).each( function() {\n\t\t\tvar child = $( this ),\n\t\t\t\tc_original = {\n\t\t\t\t\theight: child.height(),\n\t\t\t\t\twidth: child.width(),\n\t\t\t\t\touterHeight: child.outerHeight(),\n\t\t\t\t\touterWidth: child.outerWidth()\n\t\t\t\t};\n\t\t\tif (restore) {\n\t\t\t\t$.effects.save(child, props2);\n\t\t\t}\n\n\t\t\tchild.from = {\n\t\t\t\theight: c_original.height * factor.from.y,\n\t\t\t\twidth: c_original.width * factor.from.x,\n\t\t\t\touterHeight: c_original.outerHeight * factor.from.y,\n\t\t\t\touterWidth: c_original.outerWidth * factor.from.x\n\t\t\t};\n\t\t\tchild.to = {\n\t\t\t\theight: c_original.height * factor.to.y,\n\t\t\t\twidth: c_original.width * factor.to.x,\n\t\t\t\touterHeight: c_original.height * factor.to.y,\n\t\t\t\touterWidth: c_original.width * factor.to.x\n\t\t\t};\n\n\t\t\t// Vertical props scaling\n\t\t\tif ( factor.from.y !== factor.to.y ) {\n\t\t\t\tchild.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );\n\t\t\t\tchild.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );\n\t\t\t}\n\n\t\t\t// Horizontal props scaling\n\t\t\tif ( factor.from.x !== factor.to.x ) {\n\t\t\t\tchild.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );\n\t\t\t\tchild.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );\n\t\t\t}\n\n\t\t\t// Animate children\n\t\t\tchild.css( child.from );\n\t\t\tchild.animate( child.to, o.duration, o.easing, function() {\n\n\t\t\t\t// Restore children\n\t\t\t\tif ( restore ) {\n\t\t\t\t\t$.effects.restore( child, props2 );\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// Animate\n\tel.animate( el.to, {\n\t\tqueue: false,\n\t\tduration: o.duration,\n\t\teasing: o.easing,\n\t\tcomplete: function() {\n\t\t\tif ( el.to.opacity === 0 ) {\n\t\t\t\tel.css( "opacity", el.from.opacity );\n\t\t\t}\n\t\t\tif ( mode === "hide" ) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore( el, props );\n\t\t\tif ( !restore ) {\n\n\t\t\t\t// we need to calculate our new positioning based on the scaling\n\t\t\t\tif ( position === "static" ) {\n\t\t\t\t\tel.css({\n\t\t\t\t\t\tposition: "relative",\n\t\t\t\t\t\ttop: el.to.top,\n\t\t\t\t\t\tleft: el.to.left\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t$.each([ "top", "left" ], function( idx, pos ) {\n\t\t\t\t\t\tel.css( pos, function( _, str ) {\n\t\t\t\t\t\t\tvar val = parseInt( str, 10 ),\n\t\t\t\t\t\t\t\ttoRef = idx ? el.to.left : el.to.top;\n\n\t\t\t\t\t\t\t// if original was "auto", recalculate the new value from wrapper\n\t\t\t\t\t\t\tif ( str === "auto" ) {\n\t\t\t\t\t\t\t\treturn toRef + "px";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn val + toRef + "px";\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$.effects.removeWrapper( el );\n\t\t\tdone();\n\t\t}\n\t});\n\n};\n\n\n/*!\n * jQuery UI Effects Scale 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/scale-effect/\n */\n\n\nvar effectScale = $.effects.effect.scale = function( o, done ) {\n\n\t// Create element\n\tvar el = $( this ),\n\t\toptions = $.extend( true, {}, o ),\n\t\tmode = $.effects.setMode( el, o.mode || "effect" ),\n\t\tpercent = parseInt( o.percent, 10 ) ||\n\t\t\t( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),\n\t\tdirection = o.direction || "both",\n\t\torigin = o.origin,\n\t\toriginal = {\n\t\t\theight: el.height(),\n\t\t\twidth: el.width(),\n\t\t\touterHeight: el.outerHeight(),\n\t\t\touterWidth: el.outerWidth()\n\t\t},\n\t\tfactor = {\n\t\t\ty: direction !== "horizontal" ? (percent / 100) : 1,\n\t\t\tx: direction !== "vertical" ? (percent / 100) : 1\n\t\t};\n\n\t// We are going to pass this effect to the size effect:\n\toptions.effect = "size";\n\toptions.queue = false;\n\toptions.complete = done;\n\n\t// Set default origin and restore for show/hide\n\tif ( mode !== "effect" ) {\n\t\toptions.origin = origin || [ "middle", "center" ];\n\t\toptions.restore = true;\n\t}\n\n\toptions.from = o.from || ( mode === "show" ? {\n\t\theight: 0,\n\t\twidth: 0,\n\t\touterHeight: 0,\n\t\touterWidth: 0\n\t} : original );\n\toptions.to = {\n\t\theight: original.height * factor.y,\n\t\twidth: original.width * factor.x,\n\t\touterHeight: original.outerHeight * factor.y,\n\t\touterWidth: original.outerWidth * factor.x\n\t};\n\n\t// Fade option to support puff\n\tif ( options.fade ) {\n\t\tif ( mode === "show" ) {\n\t\t\toptions.from.opacity = 0;\n\t\t\toptions.to.opacity = 1;\n\t\t}\n\t\tif ( mode === "hide" ) {\n\t\t\toptions.from.opacity = 1;\n\t\t\toptions.to.opacity = 0;\n\t\t}\n\t}\n\n\t// Animate\n\tel.effect( options );\n\n};\n\n\n/*!\n * jQuery UI Effects Puff 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/puff-effect/\n */\n\n\nvar effectPuff = $.effects.effect.puff = function( o, done ) {\n\tvar elem = $( this ),\n\t\tmode = $.effects.setMode( elem, o.mode || "hide" ),\n\t\thide = mode === "hide",\n\t\tpercent = parseInt( o.percent, 10 ) || 150,\n\t\tfactor = percent / 100,\n\t\toriginal = {\n\t\t\theight: elem.height(),\n\t\t\twidth: elem.width(),\n\t\t\touterHeight: elem.outerHeight(),\n\t\t\touterWidth: elem.outerWidth()\n\t\t};\n\n\t$.extend( o, {\n\t\teffect: "scale",\n\t\tqueue: false,\n\t\tfade: true,\n\t\tmode: mode,\n\t\tcomplete: done,\n\t\tpercent: hide ? percent : 100,\n\t\tfrom: hide ?\n\t\t\toriginal :\n\t\t\t{\n\t\t\t\theight: original.height * factor,\n\t\t\t\twidth: original.width * factor,\n\t\t\t\touterHeight: original.outerHeight * factor,\n\t\t\t\touterWidth: original.outerWidth * factor\n\t\t\t}\n\t});\n\n\telem.effect( o );\n};\n\n\n/*!\n * jQuery UI Effects Pulsate 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/pulsate-effect/\n */\n\n\nvar effectPulsate = $.effects.effect.pulsate = function( o, done ) {\n\tvar elem = $( this ),\n\t\tmode = $.effects.setMode( elem, o.mode || "show" ),\n\t\tshow = mode === "show",\n\t\thide = mode === "hide",\n\t\tshowhide = ( show || mode === "hide" ),\n\n\t\t// showing or hiding leaves of the "last" animation\n\t\tanims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),\n\t\tduration = o.duration / anims,\n\t\tanimateTo = 0,\n\t\tqueue = elem.queue(),\n\t\tqueuelen = queue.length,\n\t\ti;\n\n\tif ( show || !elem.is(":visible")) {\n\t\telem.css( "opacity", 0 ).show();\n\t\tanimateTo = 1;\n\t}\n\n\t// anims - 1 opacity "toggles"\n\tfor ( i = 1; i < anims; i++ ) {\n\t\telem.animate({\n\t\t\topacity: animateTo\n\t\t}, duration, o.easing );\n\t\tanimateTo = 1 - animateTo;\n\t}\n\n\telem.animate({\n\t\topacity: animateTo\n\t}, duration, o.easing);\n\n\telem.queue(function() {\n\t\tif ( hide ) {\n\t\t\telem.hide();\n\t\t}\n\t\tdone();\n\t});\n\n\t// We just queued up "anims" animations, we need to put them next in the queue\n\tif ( queuelen > 1 ) {\n\t\tqueue.splice.apply( queue,\n\t\t\t[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\n\t}\n\telem.dequeue();\n};\n\n\n/*!\n * jQuery UI Effects Shake 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/shake-effect/\n */\n\n\nvar effectShake = $.effects.effect.shake = function( o, done ) {\n\n\tvar el = $( this ),\n\t\tprops = [ "position", "top", "bottom", "left", "right", "height", "width" ],\n\t\tmode = $.effects.setMode( el, o.mode || "effect" ),\n\t\tdirection = o.direction || "left",\n\t\tdistance = o.distance || 20,\n\t\ttimes = o.times || 3,\n\t\tanims = times * 2 + 1,\n\t\tspeed = Math.round( o.duration / anims ),\n\t\tref = (direction === "up" || direction === "down") ? "top" : "left",\n\t\tpositiveMotion = (direction === "up" || direction === "left"),\n\t\tanimation = {},\n\t\tanimation1 = {},\n\t\tanimation2 = {},\n\t\ti,\n\n\t\t// we will need to re-assemble the queue to stack our animations in place\n\t\tqueue = el.queue(),\n\t\tqueuelen = queue.length;\n\n\t$.effects.save( el, props );\n\tel.show();\n\t$.effects.createWrapper( el );\n\n\t// Animation\n\tanimation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;\n\tanimation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;\n\tanimation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;\n\n\t// Animate\n\tel.animate( animation, speed, o.easing );\n\n\t// Shakes\n\tfor ( i = 1; i < times; i++ ) {\n\t\tel.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );\n\t}\n\tel\n\t\t.animate( animation1, speed, o.easing )\n\t\t.animate( animation, speed / 2, o.easing )\n\t\t.queue(function() {\n\t\t\tif ( mode === "hide" ) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore( el, props );\n\t\t\t$.effects.removeWrapper( el );\n\t\t\tdone();\n\t\t});\n\n\t// inject all the animations we just queued to be first in line (after "inprogress")\n\tif ( queuelen > 1) {\n\t\tqueue.splice.apply( queue,\n\t\t\t[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\n\t}\n\tel.dequeue();\n\n};\n\n\n/*!\n * jQuery UI Effects Slide 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/slide-effect/\n */\n\n\nvar effectSlide = $.effects.effect.slide = function( o, done ) {\n\n\t// Create element\n\tvar el = $( this ),\n\t\tprops = [ "position", "top", "bottom", "left", "right", "width", "height" ],\n\t\tmode = $.effects.setMode( el, o.mode || "show" ),\n\t\tshow = mode === "show",\n\t\tdirection = o.direction || "left",\n\t\tref = (direction === "up" || direction === "down") ? "top" : "left",\n\t\tpositiveMotion = (direction === "up" || direction === "left"),\n\t\tdistance,\n\t\tanimation = {};\n\n\t// Adjust\n\t$.effects.save( el, props );\n\tel.show();\n\tdistance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );\n\n\t$.effects.createWrapper( el ).css({\n\t\toverflow: "hidden"\n\t});\n\n\tif ( show ) {\n\t\tel.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );\n\t}\n\n\t// Animation\n\tanimation[ ref ] = ( show ?\n\t\t( positiveMotion ? "+=" : "-=") :\n\t\t( positiveMotion ? "-=" : "+=")) +\n\t\tdistance;\n\n\t// Animate\n\tel.animate( animation, {\n\t\tqueue: false,\n\t\tduration: o.duration,\n\t\teasing: o.easing,\n\t\tcomplete: function() {\n\t\t\tif ( mode === "hide" ) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore( el, props );\n\t\t\t$.effects.removeWrapper( el );\n\t\t\tdone();\n\t\t}\n\t});\n};\n\n\n/*!\n * jQuery UI Effects Transfer 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/transfer-effect/\n */\n\n\nvar effectTransfer = $.effects.effect.transfer = function( o, done ) {\n\tvar elem = $( this ),\n\t\ttarget = $( o.to ),\n\t\ttargetFixed = target.css( "position" ) === "fixed",\n\t\tbody = $("body"),\n\t\tfixTop = targetFixed ? body.scrollTop() : 0,\n\t\tfixLeft = targetFixed ? body.scrollLeft() : 0,\n\t\tendPosition = target.offset(),\n\t\tanimation = {\n\t\t\ttop: endPosition.top - fixTop,\n\t\t\tleft: endPosition.left - fixLeft,\n\t\t\theight: target.innerHeight(),\n\t\t\twidth: target.innerWidth()\n\t\t},\n\t\tstartPosition = elem.offset(),\n\t\ttransfer = $( "<div class=\'ui-effects-transfer\'></div>" )\n\t\t\t.appendTo( document.body )\n\t\t\t.addClass( o.className )\n\t\t\t.css({\n\t\t\t\ttop: startPosition.top - fixTop,\n\t\t\t\tleft: startPosition.left - fixLeft,\n\t\t\t\theight: elem.innerHeight(),\n\t\t\t\twidth: elem.innerWidth(),\n\t\t\t\tposition: targetFixed ? "fixed" : "absolute"\n\t\t\t})\n\t\t\t.animate( animation, o.duration, o.easing, function() {\n\t\t\t\ttransfer.remove();\n\t\t\t\tdone();\n\t\t\t});\n};\n\n\n/*!\n * jQuery UI Progressbar 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/progressbar/\n */\n\n\nvar progressbar = $.widget( "ui.progressbar", {\n\tversion: "1.11.4",\n\toptions: {\n\t\tmax: 100,\n\t\tvalue: 0,\n\n\t\tchange: null,\n\t\tcomplete: null\n\t},\n\n\tmin: 0,\n\n\t_create: function() {\n\t\t// Constrain initial value\n\t\tthis.oldValue = this.options.value = this._constrainedValue();\n\n\t\tthis.element\n\t\t\t.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )\n\t\t\t.attr({\n\t\t\t\t// Only set static values, aria-valuenow and aria-valuemax are\n\t\t\t\t// set inside _refreshValue()\n\t\t\t\trole: "progressbar",\n\t\t\t\t"aria-valuemin": this.min\n\t\t\t});\n\n\t\tthis.valueDiv = $( "<div class=\'ui-progressbar-value ui-widget-header ui-corner-left\'></div>" )\n\t\t\t.appendTo( this.element );\n\n\t\tthis._refreshValue();\n\t},\n\n\t_destroy: function() {\n\t\tthis.element\n\t\t\t.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )\n\t\t\t.removeAttr( "role" )\n\t\t\t.removeAttr( "aria-valuemin" )\n\t\t\t.removeAttr( "aria-valuemax" )\n\t\t\t.removeAttr( "aria-valuenow" );\n\n\t\tthis.valueDiv.remove();\n\t},\n\n\tvalue: function( newValue ) {\n\t\tif ( newValue === undefined ) {\n\t\t\treturn this.options.value;\n\t\t}\n\n\t\tthis.options.value = this._constrainedValue( newValue );\n\t\tthis._refreshValue();\n\t},\n\n\t_constrainedValue: function( newValue ) {\n\t\tif ( newValue === undefined ) {\n\t\t\tnewValue = this.options.value;\n\t\t}\n\n\t\tthis.indeterminate = newValue === false;\n\n\t\t// sanitize value\n\t\tif ( typeof newValue !== "number" ) {\n\t\t\tnewValue = 0;\n\t\t}\n\n\t\treturn this.indeterminate ? false :\n\t\t\tMath.min( this.options.max, Math.max( this.min, newValue ) );\n\t},\n\n\t_setOptions: function( options ) {\n\t\t// Ensure "value" option is set after other values (like max)\n\t\tvar value = options.value;\n\t\tdelete options.value;\n\n\t\tthis._super( options );\n\n\t\tthis.options.value = this._constrainedValue( value );\n\t\tthis._refreshValue();\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "max" ) {\n\t\t\t// Don\'t allow a max less than min\n\t\t\tvalue = Math.max( this.min, value );\n\t\t}\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.element\n\t\t\t\t.toggleClass( "ui-state-disabled", !!value )\n\t\t\t\t.attr( "aria-disabled", value );\n\t\t}\n\t\tthis._super( key, value );\n\t},\n\n\t_percentage: function() {\n\t\treturn this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );\n\t},\n\n\t_refreshValue: function() {\n\t\tvar value = this.options.value,\n\t\t\tpercentage = this._percentage();\n\n\t\tthis.valueDiv\n\t\t\t.toggle( this.indeterminate || value > this.min )\n\t\t\t.toggleClass( "ui-corner-right", value === this.options.max )\n\t\t\t.width( percentage.toFixed(0) + "%" );\n\n\t\tthis.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );\n\n\t\tif ( this.indeterminate ) {\n\t\t\tthis.element.removeAttr( "aria-valuenow" );\n\t\t\tif ( !this.overlayDiv ) {\n\t\t\t\tthis.overlayDiv = $( "<div class=\'ui-progressbar-overlay\'></div>" ).appendTo( this.valueDiv );\n\t\t\t}\n\t\t} else {\n\t\t\tthis.element.attr({\n\t\t\t\t"aria-valuemax": this.options.max,\n\t\t\t\t"aria-valuenow": value\n\t\t\t});\n\t\t\tif ( this.overlayDiv ) {\n\t\t\t\tthis.overlayDiv.remove();\n\t\t\t\tthis.overlayDiv = null;\n\t\t\t}\n\t\t}\n\n\t\tif ( this.oldValue !== value ) {\n\t\t\tthis.oldValue = value;\n\t\t\tthis._trigger( "change" );\n\t\t}\n\t\tif ( value === this.options.max ) {\n\t\t\tthis._trigger( "complete" );\n\t\t}\n\t}\n});\n\n\n/*!\n * jQuery UI Selectable 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/selectable/\n */\n\n\nvar selectable = $.widget("ui.selectable", $.ui.mouse, {\n\tversion: "1.11.4",\n\toptions: {\n\t\tappendTo: "body",\n\t\tautoRefresh: true,\n\t\tdistance: 0,\n\t\tfilter: "*",\n\t\ttolerance: "touch",\n\n\t\t// callbacks\n\t\tselected: null,\n\t\tselecting: null,\n\t\tstart: null,\n\t\tstop: null,\n\t\tunselected: null,\n\t\tunselecting: null\n\t},\n\t_create: function() {\n\t\tvar selectees,\n\t\t\tthat = this;\n\n\t\tthis.element.addClass("ui-selectable");\n\n\t\tthis.dragged = false;\n\n\t\t// cache selectee children based on filter\n\t\tthis.refresh = function() {\n\t\t\tselectees = $(that.options.filter, that.element[0]);\n\t\t\tselectees.addClass("ui-selectee");\n\t\t\tselectees.each(function() {\n\t\t\t\tvar $this = $(this),\n\t\t\t\t\tpos = $this.offset();\n\t\t\t\t$.data(this, "selectable-item", {\n\t\t\t\t\telement: this,\n\t\t\t\t\t$element: $this,\n\t\t\t\t\tleft: pos.left,\n\t\t\t\t\ttop: pos.top,\n\t\t\t\t\tright: pos.left + $this.outerWidth(),\n\t\t\t\t\tbottom: pos.top + $this.outerHeight(),\n\t\t\t\t\tstartselected: false,\n\t\t\t\t\tselected: $this.hasClass("ui-selected"),\n\t\t\t\t\tselecting: $this.hasClass("ui-selecting"),\n\t\t\t\t\tunselecting: $this.hasClass("ui-unselecting")\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\tthis.refresh();\n\n\t\tthis.selectees = selectees.addClass("ui-selectee");\n\n\t\tthis._mouseInit();\n\n\t\tthis.helper = $("<div class=\'ui-selectable-helper\'></div>");\n\t},\n\n\t_destroy: function() {\n\t\tthis.selectees\n\t\t\t.removeClass("ui-selectee")\n\t\t\t.removeData("selectable-item");\n\t\tthis.element\n\t\t\t.removeClass("ui-selectable ui-selectable-disabled");\n\t\tthis._mouseDestroy();\n\t},\n\n\t_mouseStart: function(event) {\n\t\tvar that = this,\n\t\t\toptions = this.options;\n\n\t\tthis.opos = [ event.pageX, event.pageY ];\n\n\t\tif (this.options.disabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.selectees = $(options.filter, this.element[0]);\n\n\t\tthis._trigger("start", event);\n\n\t\t$(options.appendTo).append(this.helper);\n\t\t// position helper (lasso)\n\t\tthis.helper.css({\n\t\t\t"left": event.pageX,\n\t\t\t"top": event.pageY,\n\t\t\t"width": 0,\n\t\t\t"height": 0\n\t\t});\n\n\t\tif (options.autoRefresh) {\n\t\t\tthis.refresh();\n\t\t}\n\n\t\tthis.selectees.filter(".ui-selected").each(function() {\n\t\t\tvar selectee = $.data(this, "selectable-item");\n\t\t\tselectee.startselected = true;\n\t\t\tif (!event.metaKey && !event.ctrlKey) {\n\t\t\t\tselectee.$element.removeClass("ui-selected");\n\t\t\t\tselectee.selected = false;\n\t\t\t\tselectee.$element.addClass("ui-unselecting");\n\t\t\t\tselectee.unselecting = true;\n\t\t\t\t// selectable UNSELECTING callback\n\t\t\t\tthat._trigger("unselecting", event, {\n\t\t\t\t\tunselecting: selectee.element\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t$(event.target).parents().addBack().each(function() {\n\t\t\tvar doSelect,\n\t\t\t\tselectee = $.data(this, "selectable-item");\n\t\t\tif (selectee) {\n\t\t\t\tdoSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");\n\t\t\t\tselectee.$element\n\t\t\t\t\t.removeClass(doSelect ? "ui-unselecting" : "ui-selected")\n\t\t\t\t\t.addClass(doSelect ? "ui-selecting" : "ui-unselecting");\n\t\t\t\tselectee.unselecting = !doSelect;\n\t\t\t\tselectee.selecting = doSelect;\n\t\t\t\tselectee.selected = doSelect;\n\t\t\t\t// selectable (UN)SELECTING callback\n\t\t\t\tif (doSelect) {\n\t\t\t\t\tthat._trigger("selecting", event, {\n\t\t\t\t\t\tselecting: selectee.element\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthat._trigger("unselecting", event, {\n\t\t\t\t\t\tunselecting: selectee.element\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t},\n\n\t_mouseDrag: function(event) {\n\n\t\tthis.dragged = true;\n\n\t\tif (this.options.disabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar tmp,\n\t\t\tthat = this,\n\t\t\toptions = this.options,\n\t\t\tx1 = this.opos[0],\n\t\t\ty1 = this.opos[1],\n\t\t\tx2 = event.pageX,\n\t\t\ty2 = event.pageY;\n\n\t\tif (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }\n\t\tif (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }\n\t\tthis.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });\n\n\t\tthis.selectees.each(function() {\n\t\t\tvar selectee = $.data(this, "selectable-item"),\n\t\t\t\thit = false;\n\n\t\t\t//prevent helper from being selected if appendTo: selectable\n\t\t\tif (!selectee || selectee.element === that.element[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (options.tolerance === "touch") {\n\t\t\t\thit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );\n\t\t\t} else if (options.tolerance === "fit") {\n\t\t\t\thit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);\n\t\t\t}\n\n\t\t\tif (hit) {\n\t\t\t\t// SELECT\n\t\t\t\tif (selectee.selected) {\n\t\t\t\t\tselectee.$element.removeClass("ui-selected");\n\t\t\t\t\tselectee.selected = false;\n\t\t\t\t}\n\t\t\t\tif (selectee.unselecting) {\n\t\t\t\t\tselectee.$element.removeClass("ui-unselecting");\n\t\t\t\t\tselectee.unselecting = false;\n\t\t\t\t}\n\t\t\t\tif (!selectee.selecting) {\n\t\t\t\t\tselectee.$element.addClass("ui-selecting");\n\t\t\t\t\tselectee.selecting = true;\n\t\t\t\t\t// selectable SELECTING callback\n\t\t\t\t\tthat._trigger("selecting", event, {\n\t\t\t\t\t\tselecting: selectee.element\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// UNSELECT\n\t\t\t\tif (selectee.selecting) {\n\t\t\t\t\tif ((event.metaKey || event.ctrlKey) && selectee.startselected) {\n\t\t\t\t\t\tselectee.$element.removeClass("ui-selecting");\n\t\t\t\t\t\tselectee.selecting = false;\n\t\t\t\t\t\tselectee.$element.addClass("ui-selected");\n\t\t\t\t\t\tselectee.selected = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tselectee.$element.removeClass("ui-selecting");\n\t\t\t\t\t\tselectee.selecting = false;\n\t\t\t\t\t\tif (selectee.startselected) {\n\t\t\t\t\t\t\tselectee.$element.addClass("ui-unselecting");\n\t\t\t\t\t\t\tselectee.unselecting = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// selectable UNSELECTING callback\n\t\t\t\t\t\tthat._trigger("unselecting", event, {\n\t\t\t\t\t\t\tunselecting: selectee.element\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (selectee.selected) {\n\t\t\t\t\tif (!event.metaKey && !event.ctrlKey && !selectee.startselected) {\n\t\t\t\t\t\tselectee.$element.removeClass("ui-selected");\n\t\t\t\t\t\tselectee.selected = false;\n\n\t\t\t\t\t\tselectee.$element.addClass("ui-unselecting");\n\t\t\t\t\t\tselectee.unselecting = true;\n\t\t\t\t\t\t// selectable UNSELECTING callback\n\t\t\t\t\t\tthat._trigger("unselecting", event, {\n\t\t\t\t\t\t\tunselecting: selectee.element\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn false;\n\t},\n\n\t_mouseStop: function(event) {\n\t\tvar that = this;\n\n\t\tthis.dragged = false;\n\n\t\t$(".ui-unselecting", this.element[0]).each(function() {\n\t\t\tvar selectee = $.data(this, "selectable-item");\n\t\t\tselectee.$element.removeClass("ui-unselecting");\n\t\t\tselectee.unselecting = false;\n\t\t\tselectee.startselected = false;\n\t\t\tthat._trigger("unselected", event, {\n\t\t\t\tunselected: selectee.element\n\t\t\t});\n\t\t});\n\t\t$(".ui-selecting", this.element[0]).each(function() {\n\t\t\tvar selectee = $.data(this, "selectable-item");\n\t\t\tselectee.$element.removeClass("ui-selecting").addClass("ui-selected");\n\t\t\tselectee.selecting = false;\n\t\t\tselectee.selected = true;\n\t\t\tselectee.startselected = true;\n\t\t\tthat._trigger("selected", event, {\n\t\t\t\tselected: selectee.element\n\t\t\t});\n\t\t});\n\t\tthis._trigger("stop", event);\n\n\t\tthis.helper.remove();\n\n\t\treturn false;\n\t}\n\n});\n\n\n/*!\n * jQuery UI Selectmenu 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/selectmenu\n */\n\n\nvar selectmenu = $.widget( "ui.selectmenu", {\n\tversion: "1.11.4",\n\tdefaultElement: "<select>",\n\toptions: {\n\t\tappendTo: null,\n\t\tdisabled: null,\n\t\ticons: {\n\t\t\tbutton: "ui-icon-triangle-1-s"\n\t\t},\n\t\tposition: {\n\t\t\tmy: "left top",\n\t\t\tat: "left bottom",\n\t\t\tcollision: "none"\n\t\t},\n\t\twidth: null,\n\n\t\t// callbacks\n\t\tchange: null,\n\t\tclose: null,\n\t\tfocus: null,\n\t\topen: null,\n\t\tselect: null\n\t},\n\n\t_create: function() {\n\t\tvar selectmenuId = this.element.uniqueId().attr( "id" );\n\t\tthis.ids = {\n\t\t\telement: selectmenuId,\n\t\t\tbutton: selectmenuId + "-button",\n\t\t\tmenu: selectmenuId + "-menu"\n\t\t};\n\n\t\tthis._drawButton();\n\t\tthis._drawMenu();\n\n\t\tif ( this.options.disabled ) {\n\t\t\tthis.disable();\n\t\t}\n\t},\n\n\t_drawButton: function() {\n\t\tvar that = this;\n\n\t\t// Associate existing label with the new button\n\t\tthis.label = $( "label[for=\'" + this.ids.element + "\']" ).attr( "for", this.ids.button );\n\t\tthis._on( this.label, {\n\t\t\tclick: function( event ) {\n\t\t\t\tthis.button.focus();\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t});\n\n\t\t// Hide original select element\n\t\tthis.element.hide();\n\n\t\t// Create button\n\t\tthis.button = $( "<span>", {\n\t\t\t"class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",\n\t\t\ttabindex: this.options.disabled ? -1 : 0,\n\t\t\tid: this.ids.button,\n\t\t\trole: "combobox",\n\t\t\t"aria-expanded": "false",\n\t\t\t"aria-autocomplete": "list",\n\t\t\t"aria-owns": this.ids.menu,\n\t\t\t"aria-haspopup": "true"\n\t\t})\n\t\t\t.insertAfter( this.element );\n\n\t\t$( "<span>", {\n\t\t\t"class": "ui-icon " + this.options.icons.button\n\t\t})\n\t\t\t.prependTo( this.button );\n\n\t\tthis.buttonText = $( "<span>", {\n\t\t\t"class": "ui-selectmenu-text"\n\t\t})\n\t\t\t.appendTo( this.button );\n\n\t\tthis._setText( this.buttonText, this.element.find( "option:selected" ).text() );\n\t\tthis._resizeButton();\n\n\t\tthis._on( this.button, this._buttonEvents );\n\t\tthis.button.one( "focusin", function() {\n\n\t\t\t// Delay rendering the menu items until the button receives focus.\n\t\t\t// The menu may have already been rendered via a programmatic open.\n\t\t\tif ( !that.menuItems ) {\n\t\t\t\tthat._refreshMenu();\n\t\t\t}\n\t\t});\n\t\tthis._hoverable( this.button );\n\t\tthis._focusable( this.button );\n\t},\n\n\t_drawMenu: function() {\n\t\tvar that = this;\n\n\t\t// Create menu\n\t\tthis.menu = $( "<ul>", {\n\t\t\t"aria-hidden": "true",\n\t\t\t"aria-labelledby": this.ids.button,\n\t\t\tid: this.ids.menu\n\t\t});\n\n\t\t// Wrap menu\n\t\tthis.menuWrap = $( "<div>", {\n\t\t\t"class": "ui-selectmenu-menu ui-front"\n\t\t})\n\t\t\t.append( this.menu )\n\t\t\t.appendTo( this._appendTo() );\n\n\t\t// Initialize menu widget\n\t\tthis.menuInstance = this.menu\n\t\t\t.menu({\n\t\t\t\trole: "listbox",\n\t\t\t\tselect: function( event, ui ) {\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t// support: IE8\n\t\t\t\t\t// If the item was selected via a click, the text selection\n\t\t\t\t\t// will be destroyed in IE\n\t\t\t\t\tthat._setSelection();\n\n\t\t\t\t\tthat._select( ui.item.data( "ui-selectmenu-item" ), event );\n\t\t\t\t},\n\t\t\t\tfocus: function( event, ui ) {\n\t\t\t\t\tvar item = ui.item.data( "ui-selectmenu-item" );\n\n\t\t\t\t\t// Prevent inital focus from firing and check if its a newly focused item\n\t\t\t\t\tif ( that.focusIndex != null && item.index !== that.focusIndex ) {\n\t\t\t\t\t\tthat._trigger( "focus", event, { item: item } );\n\t\t\t\t\t\tif ( !that.isOpen ) {\n\t\t\t\t\t\t\tthat._select( item, event );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthat.focusIndex = item.index;\n\n\t\t\t\t\tthat.button.attr( "aria-activedescendant",\n\t\t\t\t\t\tthat.menuItems.eq( item.index ).attr( "id" ) );\n\t\t\t\t}\n\t\t\t})\n\t\t\t.menu( "instance" );\n\n\t\t// Adjust menu styles to dropdown\n\t\tthis.menu\n\t\t\t.addClass( "ui-corner-bottom" )\n\t\t\t.removeClass( "ui-corner-all" );\n\n\t\t// Don\'t close the menu on mouseleave\n\t\tthis.menuInstance._off( this.menu, "mouseleave" );\n\n\t\t// Cancel the menu\'s collapseAll on document click\n\t\tthis.menuInstance._closeOnDocumentClick = function() {\n\t\t\treturn false;\n\t\t};\n\n\t\t// Selects often contain empty items, but never contain dividers\n\t\tthis.menuInstance._isDivider = function() {\n\t\t\treturn false;\n\t\t};\n\t},\n\n\trefresh: function() {\n\t\tthis._refreshMenu();\n\t\tthis._setText( this.buttonText, this._getSelectedItem().text() );\n\t\tif ( !this.options.width ) {\n\t\t\tthis._resizeButton();\n\t\t}\n\t},\n\n\t_refreshMenu: function() {\n\t\tthis.menu.empty();\n\n\t\tvar item,\n\t\t\toptions = this.element.find( "option" );\n\n\t\tif ( !options.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._parseOptions( options );\n\t\tthis._renderMenu( this.menu, this.items );\n\n\t\tthis.menuInstance.refresh();\n\t\tthis.menuItems = this.menu.find( "li" ).not( ".ui-selectmenu-optgroup" );\n\n\t\titem = this._getSelectedItem();\n\n\t\t// Update the menu to have the correct item focused\n\t\tthis.menuInstance.focus( null, item );\n\t\tthis._setAria( item.data( "ui-selectmenu-item" ) );\n\n\t\t// Set disabled state\n\t\tthis._setOption( "disabled", this.element.prop( "disabled" ) );\n\t},\n\n\topen: function( event ) {\n\t\tif ( this.options.disabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If this is the first time the menu is being opened, render the items\n\t\tif ( !this.menuItems ) {\n\t\t\tthis._refreshMenu();\n\t\t} else {\n\n\t\t\t// Menu clears focus on close, reset focus to selected item\n\t\t\tthis.menu.find( ".ui-state-focus" ).removeClass( "ui-state-focus" );\n\t\t\tthis.menuInstance.focus( null, this._getSelectedItem() );\n\t\t}\n\n\t\tthis.isOpen = true;\n\t\tthis._toggleAttr();\n\t\tthis._resizeMenu();\n\t\tthis._position();\n\n\t\tthis._on( this.document, this._documentClick );\n\n\t\tthis._trigger( "open", event );\n\t},\n\n\t_position: function() {\n\t\tthis.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );\n\t},\n\n\tclose: function( event ) {\n\t\tif ( !this.isOpen ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.isOpen = false;\n\t\tthis._toggleAttr();\n\n\t\tthis.range = null;\n\t\tthis._off( this.document );\n\n\t\tthis._trigger( "close", event );\n\t},\n\n\twidget: function() {\n\t\treturn this.button;\n\t},\n\n\tmenuWidget: function() {\n\t\treturn this.menu;\n\t},\n\n\t_renderMenu: function( ul, items ) {\n\t\tvar that = this,\n\t\t\tcurrentOptgroup = "";\n\n\t\t$.each( items, function( index, item ) {\n\t\t\tif ( item.optgroup !== currentOptgroup ) {\n\t\t\t\t$( "<li>", {\n\t\t\t\t\t"class": "ui-selectmenu-optgroup ui-menu-divider" +\n\t\t\t\t\t\t( item.element.parent( "optgroup" ).prop( "disabled" ) ?\n\t\t\t\t\t\t\t" ui-state-disabled" :\n\t\t\t\t\t\t\t"" ),\n\t\t\t\t\ttext: item.optgroup\n\t\t\t\t})\n\t\t\t\t\t.appendTo( ul );\n\n\t\t\t\tcurrentOptgroup = item.optgroup;\n\t\t\t}\n\n\t\t\tthat._renderItemData( ul, item );\n\t\t});\n\t},\n\n\t_renderItemData: function( ul, item ) {\n\t\treturn this._renderItem( ul, item ).data( "ui-selectmenu-item", item );\n\t},\n\n\t_renderItem: function( ul, item ) {\n\t\tvar li = $( "<li>" );\n\n\t\tif ( item.disabled ) {\n\t\t\tli.addClass( "ui-state-disabled" );\n\t\t}\n\t\tthis._setText( li, item.label );\n\n\t\treturn li.appendTo( ul );\n\t},\n\n\t_setText: function( element, value ) {\n\t\tif ( value ) {\n\t\t\telement.text( value );\n\t\t} else {\n\t\t\telement.html( "&#160;" );\n\t\t}\n\t},\n\n\t_move: function( direction, event ) {\n\t\tvar item, next,\n\t\t\tfilter = ".ui-menu-item";\n\n\t\tif ( this.isOpen ) {\n\t\t\titem = this.menuItems.eq( this.focusIndex );\n\t\t} else {\n\t\t\titem = this.menuItems.eq( this.element[ 0 ].selectedIndex );\n\t\t\tfilter += ":not(.ui-state-disabled)";\n\t\t}\n\n\t\tif ( direction === "first" || direction === "last" ) {\n\t\t\tnext = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );\n\t\t} else {\n\t\t\tnext = item[ direction + "All" ]( filter ).eq( 0 );\n\t\t}\n\n\t\tif ( next.length ) {\n\t\t\tthis.menuInstance.focus( event, next );\n\t\t}\n\t},\n\n\t_getSelectedItem: function() {\n\t\treturn this.menuItems.eq( this.element[ 0 ].selectedIndex );\n\t},\n\n\t_toggle: function( event ) {\n\t\tthis[ this.isOpen ? "close" : "open" ]( event );\n\t},\n\n\t_setSelection: function() {\n\t\tvar selection;\n\n\t\tif ( !this.range ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( window.getSelection ) {\n\t\t\tselection = window.getSelection();\n\t\t\tselection.removeAllRanges();\n\t\t\tselection.addRange( this.range );\n\n\t\t// support: IE8\n\t\t} else {\n\t\t\tthis.range.select();\n\t\t}\n\n\t\t// support: IE\n\t\t// Setting the text selection kills the button focus in IE, but\n\t\t// restoring the focus doesn\'t kill the selection.\n\t\tthis.button.focus();\n\t},\n\n\t_documentClick: {\n\t\tmousedown: function( event ) {\n\t\t\tif ( !this.isOpen ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !$( event.target ).closest( ".ui-selectmenu-menu, #" + this.ids.button ).length ) {\n\t\t\t\tthis.close( event );\n\t\t\t}\n\t\t}\n\t},\n\n\t_buttonEvents: {\n\n\t\t// Prevent text selection from being reset when interacting with the selectmenu (#10144)\n\t\tmousedown: function() {\n\t\t\tvar selection;\n\n\t\t\tif ( window.getSelection ) {\n\t\t\t\tselection = window.getSelection();\n\t\t\t\tif ( selection.rangeCount ) {\n\t\t\t\t\tthis.range = selection.getRangeAt( 0 );\n\t\t\t\t}\n\n\t\t\t// support: IE8\n\t\t\t} else {\n\t\t\t\tthis.range = document.selection.createRange();\n\t\t\t}\n\t\t},\n\n\t\tclick: function( event ) {\n\t\t\tthis._setSelection();\n\t\t\tthis._toggle( event );\n\t\t},\n\n\t\tkeydown: function( event ) {\n\t\t\tvar preventDefault = true;\n\t\t\tswitch ( event.keyCode ) {\n\t\t\t\tcase $.ui.keyCode.TAB:\n\t\t\t\tcase $.ui.keyCode.ESCAPE:\n\t\t\t\t\tthis.close( event );\n\t\t\t\t\tpreventDefault = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.ENTER:\n\t\t\t\t\tif ( this.isOpen ) {\n\t\t\t\t\t\tthis._selectFocusedItem( event );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\t\tif ( event.altKey ) {\n\t\t\t\t\t\tthis._toggle( event );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._move( "prev", event );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\t\tif ( event.altKey ) {\n\t\t\t\t\t\tthis._toggle( event );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._move( "next", event );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.SPACE:\n\t\t\t\t\tif ( this.isOpen ) {\n\t\t\t\t\t\tthis._selectFocusedItem( event );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._toggle( event );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\tthis._move( "prev", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\t\tthis._move( "next", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\t\tthis._move( "first", event );\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\t\tthis._move( "last", event );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.menu.trigger( event );\n\t\t\t\t\tpreventDefault = false;\n\t\t\t}\n\n\t\t\tif ( preventDefault ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t},\n\n\t_selectFocusedItem: function( event ) {\n\t\tvar item = this.menuItems.eq( this.focusIndex );\n\t\tif ( !item.hasClass( "ui-state-disabled" ) ) {\n\t\t\tthis._select( item.data( "ui-selectmenu-item" ), event );\n\t\t}\n\t},\n\n\t_select: function( item, event ) {\n\t\tvar oldIndex = this.element[ 0 ].selectedIndex;\n\n\t\t// Change native select element\n\t\tthis.element[ 0 ].selectedIndex = item.index;\n\t\tthis._setText( this.buttonText, item.label );\n\t\tthis._setAria( item );\n\t\tthis._trigger( "select", event, { item: item } );\n\n\t\tif ( item.index !== oldIndex ) {\n\t\t\tthis._trigger( "change", event, { item: item } );\n\t\t}\n\n\t\tthis.close( event );\n\t},\n\n\t_setAria: function( item ) {\n\t\tvar id = this.menuItems.eq( item.index ).attr( "id" );\n\n\t\tthis.button.attr({\n\t\t\t"aria-labelledby": id,\n\t\t\t"aria-activedescendant": id\n\t\t});\n\t\tthis.menu.attr( "aria-activedescendant", id );\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "icons" ) {\n\t\t\tthis.button.find( "span.ui-icon" )\n\t\t\t\t.removeClass( this.options.icons.button )\n\t\t\t\t.addClass( value.button );\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\tif ( key === "appendTo" ) {\n\t\t\tthis.menuWrap.appendTo( this._appendTo() );\n\t\t}\n\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.menuInstance.option( "disabled", value );\n\t\t\tthis.button\n\t\t\t\t.toggleClass( "ui-state-disabled", value )\n\t\t\t\t.attr( "aria-disabled", value );\n\n\t\t\tthis.element.prop( "disabled", value );\n\t\t\tif ( value ) {\n\t\t\t\tthis.button.attr( "tabindex", -1 );\n\t\t\t\tthis.close();\n\t\t\t} else {\n\t\t\t\tthis.button.attr( "tabindex", 0 );\n\t\t\t}\n\t\t}\n\n\t\tif ( key === "width" ) {\n\t\t\tthis._resizeButton();\n\t\t}\n\t},\n\n\t_appendTo: function() {\n\t\tvar element = this.options.appendTo;\n\n\t\tif ( element ) {\n\t\t\telement = element.jquery || element.nodeType ?\n\t\t\t\t$( element ) :\n\t\t\t\tthis.document.find( element ).eq( 0 );\n\t\t}\n\n\t\tif ( !element || !element[ 0 ] ) {\n\t\t\telement = this.element.closest( ".ui-front" );\n\t\t}\n\n\t\tif ( !element.length ) {\n\t\t\telement = this.document[ 0 ].body;\n\t\t}\n\n\t\treturn element;\n\t},\n\n\t_toggleAttr: function() {\n\t\tthis.button\n\t\t\t.toggleClass( "ui-corner-top", this.isOpen )\n\t\t\t.toggleClass( "ui-corner-all", !this.isOpen )\n\t\t\t.attr( "aria-expanded", this.isOpen );\n\t\tthis.menuWrap.toggleClass( "ui-selectmenu-open", this.isOpen );\n\t\tthis.menu.attr( "aria-hidden", !this.isOpen );\n\t},\n\n\t_resizeButton: function() {\n\t\tvar width = this.options.width;\n\n\t\tif ( !width ) {\n\t\t\twidth = this.element.show().outerWidth();\n\t\t\tthis.element.hide();\n\t\t}\n\n\t\tthis.button.outerWidth( width );\n\t},\n\n\t_resizeMenu: function() {\n\t\tthis.menu.outerWidth( Math.max(\n\t\t\tthis.button.outerWidth(),\n\n\t\t\t// support: IE10\n\t\t\t// IE10 wraps long text (possibly a rounding bug)\n\t\t\t// so we add 1px to avoid the wrapping\n\t\t\tthis.menu.width( "" ).outerWidth() + 1\n\t\t) );\n\t},\n\n\t_getCreateOptions: function() {\n\t\treturn { disabled: this.element.prop( "disabled" ) };\n\t},\n\n\t_parseOptions: function( options ) {\n\t\tvar data = [];\n\t\toptions.each(function( index, item ) {\n\t\t\tvar option = $( item ),\n\t\t\t\toptgroup = option.parent( "optgroup" );\n\t\t\tdata.push({\n\t\t\t\telement: option,\n\t\t\t\tindex: index,\n\t\t\t\tvalue: option.val(),\n\t\t\t\tlabel: option.text(),\n\t\t\t\toptgroup: optgroup.attr( "label" ) || "",\n\t\t\t\tdisabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )\n\t\t\t});\n\t\t});\n\t\tthis.items = data;\n\t},\n\n\t_destroy: function() {\n\t\tthis.menuWrap.remove();\n\t\tthis.button.remove();\n\t\tthis.element.show();\n\t\tthis.element.removeUniqueId();\n\t\tthis.label.attr( "for", this.ids.element );\n\t}\n});\n\n\n/*!\n * jQuery UI Slider 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/slider/\n */\n\n\nvar slider = $.widget( "ui.slider", $.ui.mouse, {\n\tversion: "1.11.4",\n\twidgetEventPrefix: "slide",\n\n\toptions: {\n\t\tanimate: false,\n\t\tdistance: 0,\n\t\tmax: 100,\n\t\tmin: 0,\n\t\torientation: "horizontal",\n\t\trange: false,\n\t\tstep: 1,\n\t\tvalue: 0,\n\t\tvalues: null,\n\n\t\t// callbacks\n\t\tchange: null,\n\t\tslide: null,\n\t\tstart: null,\n\t\tstop: null\n\t},\n\n\t// number of pages in a slider\n\t// (how many times can you page up/down to go through the whole range)\n\tnumPages: 5,\n\n\t_create: function() {\n\t\tthis._keySliding = false;\n\t\tthis._mouseSliding = false;\n\t\tthis._animateOff = true;\n\t\tthis._handleIndex = null;\n\t\tthis._detectOrientation();\n\t\tthis._mouseInit();\n\t\tthis._calculateNewMax();\n\n\t\tthis.element\n\t\t\t.addClass( "ui-slider" +\n\t\t\t\t" ui-slider-" + this.orientation +\n\t\t\t\t" ui-widget" +\n\t\t\t\t" ui-widget-content" +\n\t\t\t\t" ui-corner-all");\n\n\t\tthis._refresh();\n\t\tthis._setOption( "disabled", this.options.disabled );\n\n\t\tthis._animateOff = false;\n\t},\n\n\t_refresh: function() {\n\t\tthis._createRange();\n\t\tthis._createHandles();\n\t\tthis._setupEvents();\n\t\tthis._refreshValue();\n\t},\n\n\t_createHandles: function() {\n\t\tvar i, handleCount,\n\t\t\toptions = this.options,\n\t\t\texistingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),\n\t\t\thandle = "<span class=\'ui-slider-handle ui-state-default ui-corner-all\' tabindex=\'0\'></span>",\n\t\t\thandles = [];\n\n\t\thandleCount = ( options.values && options.values.length ) || 1;\n\n\t\tif ( existingHandles.length > handleCount ) {\n\t\t\texistingHandles.slice( handleCount ).remove();\n\t\t\texistingHandles = existingHandles.slice( 0, handleCount );\n\t\t}\n\n\t\tfor ( i = existingHandles.length; i < handleCount; i++ ) {\n\t\t\thandles.push( handle );\n\t\t}\n\n\t\tthis.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );\n\n\t\tthis.handle = this.handles.eq( 0 );\n\n\t\tthis.handles.each(function( i ) {\n\t\t\t$( this ).data( "ui-slider-handle-index", i );\n\t\t});\n\t},\n\n\t_createRange: function() {\n\t\tvar options = this.options,\n\t\t\tclasses = "";\n\n\t\tif ( options.range ) {\n\t\t\tif ( options.range === true ) {\n\t\t\t\tif ( !options.values ) {\n\t\t\t\t\toptions.values = [ this._valueMin(), this._valueMin() ];\n\t\t\t\t} else if ( options.values.length && options.values.length !== 2 ) {\n\t\t\t\t\toptions.values = [ options.values[0], options.values[0] ];\n\t\t\t\t} else if ( $.isArray( options.values ) ) {\n\t\t\t\t\toptions.values = options.values.slice(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !this.range || !this.range.length ) {\n\t\t\t\tthis.range = $( "<div></div>" )\n\t\t\t\t\t.appendTo( this.element );\n\n\t\t\t\tclasses = "ui-slider-range" +\n\t\t\t\t// note: this isn\'t the most fittingly semantic framework class for this element,\n\t\t\t\t// but worked best visually with a variety of themes\n\t\t\t\t" ui-widget-header ui-corner-all";\n\t\t\t} else {\n\t\t\t\tthis.range.removeClass( "ui-slider-range-min ui-slider-range-max" )\n\t\t\t\t\t// Handle range switching from true to min/max\n\t\t\t\t\t.css({\n\t\t\t\t\t\t"left": "",\n\t\t\t\t\t\t"bottom": ""\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.range.addClass( classes +\n\t\t\t\t( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );\n\t\t} else {\n\t\t\tif ( this.range ) {\n\t\t\t\tthis.range.remove();\n\t\t\t}\n\t\t\tthis.range = null;\n\t\t}\n\t},\n\n\t_setupEvents: function() {\n\t\tthis._off( this.handles );\n\t\tthis._on( this.handles, this._handleEvents );\n\t\tthis._hoverable( this.handles );\n\t\tthis._focusable( this.handles );\n\t},\n\n\t_destroy: function() {\n\t\tthis.handles.remove();\n\t\tif ( this.range ) {\n\t\t\tthis.range.remove();\n\t\t}\n\n\t\tthis.element\n\t\t\t.removeClass( "ui-slider" +\n\t\t\t\t" ui-slider-horizontal" +\n\t\t\t\t" ui-slider-vertical" +\n\t\t\t\t" ui-widget" +\n\t\t\t\t" ui-widget-content" +\n\t\t\t\t" ui-corner-all" );\n\n\t\tthis._mouseDestroy();\n\t},\n\n\t_mouseCapture: function( event ) {\n\t\tvar position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,\n\t\t\tthat = this,\n\t\t\to = this.options;\n\n\t\tif ( o.disabled ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.elementSize = {\n\t\t\twidth: this.element.outerWidth(),\n\t\t\theight: this.element.outerHeight()\n\t\t};\n\t\tthis.elementOffset = this.element.offset();\n\n\t\tposition = { x: event.pageX, y: event.pageY };\n\t\tnormValue = this._normValueFromMouse( position );\n\t\tdistance = this._valueMax() - this._valueMin() + 1;\n\t\tthis.handles.each(function( i ) {\n\t\t\tvar thisDistance = Math.abs( normValue - that.values(i) );\n\t\t\tif (( distance > thisDistance ) ||\n\t\t\t\t( distance === thisDistance &&\n\t\t\t\t\t(i === that._lastChangedValue || that.values(i) === o.min ))) {\n\t\t\t\tdistance = thisDistance;\n\t\t\t\tclosestHandle = $( this );\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t});\n\n\t\tallowed = this._start( event, index );\n\t\tif ( allowed === false ) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._mouseSliding = true;\n\n\t\tthis._handleIndex = index;\n\n\t\tclosestHandle\n\t\t\t.addClass( "ui-state-active" )\n\t\t\t.focus();\n\n\t\toffset = closestHandle.offset();\n\t\tmouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );\n\t\tthis._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {\n\t\t\tleft: event.pageX - offset.left - ( closestHandle.width() / 2 ),\n\t\t\ttop: event.pageY - offset.top -\n\t\t\t\t( closestHandle.height() / 2 ) -\n\t\t\t\t( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -\n\t\t\t\t( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +\n\t\t\t\t( parseInt( closestHandle.css("marginTop"), 10 ) || 0)\n\t\t};\n\n\t\tif ( !this.handles.hasClass( "ui-state-hover" ) ) {\n\t\t\tthis._slide( event, index, normValue );\n\t\t}\n\t\tthis._animateOff = true;\n\t\treturn true;\n\t},\n\n\t_mouseStart: function() {\n\t\treturn true;\n\t},\n\n\t_mouseDrag: function( event ) {\n\t\tvar position = { x: event.pageX, y: event.pageY },\n\t\t\tnormValue = this._normValueFromMouse( position );\n\n\t\tthis._slide( event, this._handleIndex, normValue );\n\n\t\treturn false;\n\t},\n\n\t_mouseStop: function( event ) {\n\t\tthis.handles.removeClass( "ui-state-active" );\n\t\tthis._mouseSliding = false;\n\n\t\tthis._stop( event, this._handleIndex );\n\t\tthis._change( event, this._handleIndex );\n\n\t\tthis._handleIndex = null;\n\t\tthis._clickOffset = null;\n\t\tthis._animateOff = false;\n\n\t\treturn false;\n\t},\n\n\t_detectOrientation: function() {\n\t\tthis.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";\n\t},\n\n\t_normValueFromMouse: function( position ) {\n\t\tvar pixelTotal,\n\t\t\tpixelMouse,\n\t\t\tpercentMouse,\n\t\t\tvalueTotal,\n\t\t\tvalueMouse;\n\n\t\tif ( this.orientation === "horizontal" ) {\n\t\t\tpixelTotal = this.elementSize.width;\n\t\t\tpixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );\n\t\t} else {\n\t\t\tpixelTotal = this.elementSize.height;\n\t\t\tpixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );\n\t\t}\n\n\t\tpercentMouse = ( pixelMouse / pixelTotal );\n\t\tif ( percentMouse > 1 ) {\n\t\t\tpercentMouse = 1;\n\t\t}\n\t\tif ( percentMouse < 0 ) {\n\t\t\tpercentMouse = 0;\n\t\t}\n\t\tif ( this.orientation === "vertical" ) {\n\t\t\tpercentMouse = 1 - percentMouse;\n\t\t}\n\n\t\tvalueTotal = this._valueMax() - this._valueMin();\n\t\tvalueMouse = this._valueMin() + percentMouse * valueTotal;\n\n\t\treturn this._trimAlignValue( valueMouse );\n\t},\n\n\t_start: function( event, index ) {\n\t\tvar uiHash = {\n\t\t\thandle: this.handles[ index ],\n\t\t\tvalue: this.value()\n\t\t};\n\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\tuiHash.value = this.values( index );\n\t\t\tuiHash.values = this.values();\n\t\t}\n\t\treturn this._trigger( "start", event, uiHash );\n\t},\n\n\t_slide: function( event, index, newVal ) {\n\t\tvar otherVal,\n\t\t\tnewValues,\n\t\t\tallowed;\n\n\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\totherVal = this.values( index ? 0 : 1 );\n\n\t\t\tif ( ( this.options.values.length === 2 && this.options.range === true ) &&\n\t\t\t\t\t( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )\n\t\t\t\t) {\n\t\t\t\tnewVal = otherVal;\n\t\t\t}\n\n\t\t\tif ( newVal !== this.values( index ) ) {\n\t\t\t\tnewValues = this.values();\n\t\t\t\tnewValues[ index ] = newVal;\n\t\t\t\t// A slide can be canceled by returning false from the slide callback\n\t\t\t\tallowed = this._trigger( "slide", event, {\n\t\t\t\t\thandle: this.handles[ index ],\n\t\t\t\t\tvalue: newVal,\n\t\t\t\t\tvalues: newValues\n\t\t\t\t} );\n\t\t\t\totherVal = this.values( index ? 0 : 1 );\n\t\t\t\tif ( allowed !== false ) {\n\t\t\t\t\tthis.values( index, newVal );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ( newVal !== this.value() ) {\n\t\t\t\t// A slide can be canceled by returning false from the slide callback\n\t\t\t\tallowed = this._trigger( "slide", event, {\n\t\t\t\t\thandle: this.handles[ index ],\n\t\t\t\t\tvalue: newVal\n\t\t\t\t} );\n\t\t\t\tif ( allowed !== false ) {\n\t\t\t\t\tthis.value( newVal );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_stop: function( event, index ) {\n\t\tvar uiHash = {\n\t\t\thandle: this.handles[ index ],\n\t\t\tvalue: this.value()\n\t\t};\n\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\tuiHash.value = this.values( index );\n\t\t\tuiHash.values = this.values();\n\t\t}\n\n\t\tthis._trigger( "stop", event, uiHash );\n\t},\n\n\t_change: function( event, index ) {\n\t\tif ( !this._keySliding && !this._mouseSliding ) {\n\t\t\tvar uiHash = {\n\t\t\t\thandle: this.handles[ index ],\n\t\t\t\tvalue: this.value()\n\t\t\t};\n\t\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\t\tuiHash.value = this.values( index );\n\t\t\t\tuiHash.values = this.values();\n\t\t\t}\n\n\t\t\t//store the last changed value index for reference when handles overlap\n\t\t\tthis._lastChangedValue = index;\n\n\t\t\tthis._trigger( "change", event, uiHash );\n\t\t}\n\t},\n\n\tvalue: function( newValue ) {\n\t\tif ( arguments.length ) {\n\t\t\tthis.options.value = this._trimAlignValue( newValue );\n\t\t\tthis._refreshValue();\n\t\t\tthis._change( null, 0 );\n\t\t\treturn;\n\t\t}\n\n\t\treturn this._value();\n\t},\n\n\tvalues: function( index, newValue ) {\n\t\tvar vals,\n\t\t\tnewValues,\n\t\t\ti;\n\n\t\tif ( arguments.length > 1 ) {\n\t\t\tthis.options.values[ index ] = this._trimAlignValue( newValue );\n\t\t\tthis._refreshValue();\n\t\t\tthis._change( null, index );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( arguments.length ) {\n\t\t\tif ( $.isArray( arguments[ 0 ] ) ) {\n\t\t\t\tvals = this.options.values;\n\t\t\t\tnewValues = arguments[ 0 ];\n\t\t\t\tfor ( i = 0; i < vals.length; i += 1 ) {\n\t\t\t\t\tvals[ i ] = this._trimAlignValue( newValues[ i ] );\n\t\t\t\t\tthis._change( null, i );\n\t\t\t\t}\n\t\t\t\tthis._refreshValue();\n\t\t\t} else {\n\t\t\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\t\t\treturn this._values( index );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.value();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._values();\n\t\t}\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tvar i,\n\t\t\tvalsLength = 0;\n\n\t\tif ( key === "range" && this.options.range === true ) {\n\t\t\tif ( value === "min" ) {\n\t\t\t\tthis.options.value = this._values( 0 );\n\t\t\t\tthis.options.values = null;\n\t\t\t} else if ( value === "max" ) {\n\t\t\t\tthis.options.value = this._values( this.options.values.length - 1 );\n\t\t\t\tthis.options.values = null;\n\t\t\t}\n\t\t}\n\n\t\tif ( $.isArray( this.options.values ) ) {\n\t\t\tvalsLength = this.options.values.length;\n\t\t}\n\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.element.toggleClass( "ui-state-disabled", !!value );\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\tswitch ( key ) {\n\t\t\tcase "orientation":\n\t\t\t\tthis._detectOrientation();\n\t\t\t\tthis.element\n\t\t\t\t\t.removeClass( "ui-slider-horizontal ui-slider-vertical" )\n\t\t\t\t\t.addClass( "ui-slider-" + this.orientation );\n\t\t\t\tthis._refreshValue();\n\n\t\t\t\t// Reset positioning from previous orientation\n\t\t\t\tthis.handles.css( value === "horizontal" ? "bottom" : "left", "" );\n\t\t\t\tbreak;\n\t\t\tcase "value":\n\t\t\t\tthis._animateOff = true;\n\t\t\t\tthis._refreshValue();\n\t\t\t\tthis._change( null, 0 );\n\t\t\t\tthis._animateOff = false;\n\t\t\t\tbreak;\n\t\t\tcase "values":\n\t\t\t\tthis._animateOff = true;\n\t\t\t\tthis._refreshValue();\n\t\t\t\tfor ( i = 0; i < valsLength; i += 1 ) {\n\t\t\t\t\tthis._change( null, i );\n\t\t\t\t}\n\t\t\t\tthis._animateOff = false;\n\t\t\t\tbreak;\n\t\t\tcase "step":\n\t\t\tcase "min":\n\t\t\tcase "max":\n\t\t\t\tthis._animateOff = true;\n\t\t\t\tthis._calculateNewMax();\n\t\t\t\tthis._refreshValue();\n\t\t\t\tthis._animateOff = false;\n\t\t\t\tbreak;\n\t\t\tcase "range":\n\t\t\t\tthis._animateOff = true;\n\t\t\t\tthis._refresh();\n\t\t\t\tthis._animateOff = false;\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\t//internal value getter\n\t// _value() returns value trimmed by min and max, aligned by step\n\t_value: function() {\n\t\tvar val = this.options.value;\n\t\tval = this._trimAlignValue( val );\n\n\t\treturn val;\n\t},\n\n\t//internal values getter\n\t// _values() returns array of values trimmed by min and max, aligned by step\n\t// _values( index ) returns single value trimmed by min and max, aligned by step\n\t_values: function( index ) {\n\t\tvar val,\n\t\t\tvals,\n\t\t\ti;\n\n\t\tif ( arguments.length ) {\n\t\t\tval = this.options.values[ index ];\n\t\t\tval = this._trimAlignValue( val );\n\n\t\t\treturn val;\n\t\t} else if ( this.options.values && this.options.values.length ) {\n\t\t\t// .slice() creates a copy of the array\n\t\t\t// this copy gets trimmed by min and max and then returned\n\t\t\tvals = this.options.values.slice();\n\t\t\tfor ( i = 0; i < vals.length; i += 1) {\n\t\t\t\tvals[ i ] = this._trimAlignValue( vals[ i ] );\n\t\t\t}\n\n\t\t\treturn vals;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t},\n\n\t// returns the step-aligned value that val is closest to, between (inclusive) min and max\n\t_trimAlignValue: function( val ) {\n\t\tif ( val <= this._valueMin() ) {\n\t\t\treturn this._valueMin();\n\t\t}\n\t\tif ( val >= this._valueMax() ) {\n\t\t\treturn this._valueMax();\n\t\t}\n\t\tvar step = ( this.options.step > 0 ) ? this.options.step : 1,\n\t\t\tvalModStep = (val - this._valueMin()) % step,\n\t\t\talignValue = val - valModStep;\n\n\t\tif ( Math.abs(valModStep) * 2 >= step ) {\n\t\t\talignValue += ( valModStep > 0 ) ? step : ( -step );\n\t\t}\n\n\t\t// Since JavaScript has problems with large floats, round\n\t\t// the final value to 5 digits after the decimal point (see #4124)\n\t\treturn parseFloat( alignValue.toFixed(5) );\n\t},\n\n\t_calculateNewMax: function() {\n\t\tvar max = this.options.max,\n\t\t\tmin = this._valueMin(),\n\t\t\tstep = this.options.step,\n\t\t\taboveMin = Math.floor( ( +( max - min ).toFixed( this._precision() ) ) / step ) * step;\n\t\tmax = aboveMin + min;\n\t\tthis.max = parseFloat( max.toFixed( this._precision() ) );\n\t},\n\n\t_precision: function() {\n\t\tvar precision = this._precisionOf( this.options.step );\n\t\tif ( this.options.min !== null ) {\n\t\t\tprecision = Math.max( precision, this._precisionOf( this.options.min ) );\n\t\t}\n\t\treturn precision;\n\t},\n\n\t_precisionOf: function( num ) {\n\t\tvar str = num.toString(),\n\t\t\tdecimal = str.indexOf( "." );\n\t\treturn decimal === -1 ? 0 : str.length - decimal - 1;\n\t},\n\n\t_valueMin: function() {\n\t\treturn this.options.min;\n\t},\n\n\t_valueMax: function() {\n\t\treturn this.max;\n\t},\n\n\t_refreshValue: function() {\n\t\tvar lastValPercent, valPercent, value, valueMin, valueMax,\n\t\t\toRange = this.options.range,\n\t\t\to = this.options,\n\t\t\tthat = this,\n\t\t\tanimate = ( !this._animateOff ) ? o.animate : false,\n\t\t\t_set = {};\n\n\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\tthis.handles.each(function( i ) {\n\t\t\t\tvalPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;\n\t\t\t\t_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";\n\t\t\t\t$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );\n\t\t\t\tif ( that.options.range === true ) {\n\t\t\t\t\tif ( that.orientation === "horizontal" ) {\n\t\t\t\t\t\tif ( i === 0 ) {\n\t\t\t\t\t\t\tthat.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( i === 1 ) {\n\t\t\t\t\t\t\tthat.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( i === 0 ) {\n\t\t\t\t\t\t\tthat.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( i === 1 ) {\n\t\t\t\t\t\t\tthat.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastValPercent = valPercent;\n\t\t\t});\n\t\t} else {\n\t\t\tvalue = this.value();\n\t\t\tvalueMin = this._valueMin();\n\t\t\tvalueMax = this._valueMax();\n\t\t\tvalPercent = ( valueMax !== valueMin ) ?\n\t\t\t\t\t( value - valueMin ) / ( valueMax - valueMin ) * 100 :\n\t\t\t\t\t0;\n\t\t\t_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";\n\t\t\tthis.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );\n\n\t\t\tif ( oRange === "min" && this.orientation === "horizontal" ) {\n\t\t\t\tthis.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );\n\t\t\t}\n\t\t\tif ( oRange === "max" && this.orientation === "horizontal" ) {\n\t\t\t\tthis.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );\n\t\t\t}\n\t\t\tif ( oRange === "min" && this.orientation === "vertical" ) {\n\t\t\t\tthis.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );\n\t\t\t}\n\t\t\tif ( oRange === "max" && this.orientation === "vertical" ) {\n\t\t\t\tthis.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleEvents: {\n\t\tkeydown: function( event ) {\n\t\t\tvar allowed, curVal, newVal, step,\n\t\t\t\tindex = $( event.target ).data( "ui-slider-handle-index" );\n\n\t\t\tswitch ( event.keyCode ) {\n\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tif ( !this._keySliding ) {\n\t\t\t\t\t\tthis._keySliding = true;\n\t\t\t\t\t\t$( event.target ).addClass( "ui-state-active" );\n\t\t\t\t\t\tallowed = this._start( event, index );\n\t\t\t\t\t\tif ( allowed === false ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstep = this.options.step;\n\t\t\tif ( this.options.values && this.options.values.length ) {\n\t\t\t\tcurVal = newVal = this.values( index );\n\t\t\t} else {\n\t\t\t\tcurVal = newVal = this.value();\n\t\t\t}\n\n\t\t\tswitch ( event.keyCode ) {\n\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\t\tnewVal = this._valueMin();\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\t\tnewVal = this._valueMax();\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\t\tnewVal = this._trimAlignValue(\n\t\t\t\t\t\tcurVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\t\tnewVal = this._trimAlignValue(\n\t\t\t\t\t\tcurVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\t\tif ( curVal === this._valueMax() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnewVal = this._trimAlignValue( curVal + step );\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\tif ( curVal === this._valueMin() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnewVal = this._trimAlignValue( curVal - step );\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis._slide( event, index, newVal );\n\t\t},\n\t\tkeyup: function( event ) {\n\t\t\tvar index = $( event.target ).data( "ui-slider-handle-index" );\n\n\t\t\tif ( this._keySliding ) {\n\t\t\t\tthis._keySliding = false;\n\t\t\t\tthis._stop( event, index );\n\t\t\t\tthis._change( event, index );\n\t\t\t\t$( event.target ).removeClass( "ui-state-active" );\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*!\n * jQuery UI Sortable 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/sortable/\n */\n\n\nvar sortable = $.widget("ui.sortable", $.ui.mouse, {\n\tversion: "1.11.4",\n\twidgetEventPrefix: "sort",\n\tready: false,\n\toptions: {\n\t\tappendTo: "parent",\n\t\taxis: false,\n\t\tconnectWith: false,\n\t\tcontainment: false,\n\t\tcursor: "auto",\n\t\tcursorAt: false,\n\t\tdropOnEmpty: true,\n\t\tforcePlaceholderSize: false,\n\t\tforceHelperSize: false,\n\t\tgrid: false,\n\t\thandle: false,\n\t\thelper: "original",\n\t\titems: "> *",\n\t\topacity: false,\n\t\tplaceholder: false,\n\t\trevert: false,\n\t\tscroll: true,\n\t\tscrollSensitivity: 20,\n\t\tscrollSpeed: 20,\n\t\tscope: "default",\n\t\ttolerance: "intersect",\n\t\tzIndex: 1000,\n\n\t\t// callbacks\n\t\tactivate: null,\n\t\tbeforeStop: null,\n\t\tchange: null,\n\t\tdeactivate: null,\n\t\tout: null,\n\t\tover: null,\n\t\treceive: null,\n\t\tremove: null,\n\t\tsort: null,\n\t\tstart: null,\n\t\tstop: null,\n\t\tupdate: null\n\t},\n\n\t_isOverAxis: function( x, reference, size ) {\n\t\treturn ( x >= reference ) && ( x < ( reference + size ) );\n\t},\n\n\t_isFloating: function( item ) {\n\t\treturn (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));\n\t},\n\n\t_create: function() {\n\t\tthis.containerCache = {};\n\t\tthis.element.addClass("ui-sortable");\n\n\t\t//Get the items\n\t\tthis.refresh();\n\n\t\t//Let\'s determine the parent\'s offset\n\t\tthis.offset = this.element.offset();\n\n\t\t//Initialize mouse events for interaction\n\t\tthis._mouseInit();\n\n\t\tthis._setHandleClassName();\n\n\t\t//We\'re ready to go\n\t\tthis.ready = true;\n\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tthis._super( key, value );\n\n\t\tif ( key === "handle" ) {\n\t\t\tthis._setHandleClassName();\n\t\t}\n\t},\n\n\t_setHandleClassName: function() {\n\t\tthis.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );\n\t\t$.each( this.items, function() {\n\t\t\t( this.instance.options.handle ?\n\t\t\t\tthis.item.find( this.instance.options.handle ) : this.item )\n\t\t\t\t.addClass( "ui-sortable-handle" );\n\t\t});\n\t},\n\n\t_destroy: function() {\n\t\tthis.element\n\t\t\t.removeClass( "ui-sortable ui-sortable-disabled" )\n\t\t\t.find( ".ui-sortable-handle" )\n\t\t\t\t.removeClass( "ui-sortable-handle" );\n\t\tthis._mouseDestroy();\n\n\t\tfor ( var i = this.items.length - 1; i >= 0; i-- ) {\n\t\t\tthis.items[i].item.removeData(this.widgetName + "-item");\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_mouseCapture: function(event, overrideHandle) {\n\t\tvar currentItem = null,\n\t\t\tvalidHandle = false,\n\t\t\tthat = this;\n\n\t\tif (this.reverting) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(this.options.disabled || this.options.type === "static") {\n\t\t\treturn false;\n\t\t}\n\n\t\t//We have to refresh the items data once first\n\t\tthis._refreshItems(event);\n\n\t\t//Find out if the clicked node (or one of its parents) is a actual item in this.items\n\t\t$(event.target).parents().each(function() {\n\t\t\tif($.data(this, that.widgetName + "-item") === that) {\n\t\t\t\tcurrentItem = $(this);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tif($.data(event.target, that.widgetName + "-item") === that) {\n\t\t\tcurrentItem = $(event.target);\n\t\t}\n\n\t\tif(!currentItem) {\n\t\t\treturn false;\n\t\t}\n\t\tif(this.options.handle && !overrideHandle) {\n\t\t\t$(this.options.handle, currentItem).find("*").addBack().each(function() {\n\t\t\t\tif(this === event.target) {\n\t\t\t\t\tvalidHandle = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(!validHandle) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.currentItem = currentItem;\n\t\tthis._removeCurrentsFromItems();\n\t\treturn true;\n\n\t},\n\n\t_mouseStart: function(event, overrideHandle, noActivation) {\n\n\t\tvar i, body,\n\t\t\to = this.options;\n\n\t\tthis.currentContainer = this;\n\n\t\t//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\n\t\tthis.refreshPositions();\n\n\t\t//Create and append the visible helper\n\t\tthis.helper = this._createHelper(event);\n\n\t\t//Cache the helper size\n\t\tthis._cacheHelperProportions();\n\n\t\t/*\n\t\t * - Position generation -\n\t\t * This block generates everything position related - it\'s the core of draggables.\n\t\t */\n\n\t\t//Cache the margins of the original element\n\t\tthis._cacheMargins();\n\n\t\t//Get the next scrolling parent\n\t\tthis.scrollParent = this.helper.scrollParent();\n\n\t\t//The element\'s absolute position on the page minus margins\n\t\tthis.offset = this.currentItem.offset();\n\t\tthis.offset = {\n\t\t\ttop: this.offset.top - this.margins.top,\n\t\t\tleft: this.offset.left - this.margins.left\n\t\t};\n\n\t\t$.extend(this.offset, {\n\t\t\tclick: { //Where the click happened, relative to the element\n\t\t\t\tleft: event.pageX - this.offset.left,\n\t\t\t\ttop: event.pageY - this.offset.top\n\t\t\t},\n\t\t\tparent: this._getParentOffset(),\n\t\t\trelative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n\t\t});\n\n\t\t// Only after we got the offset, we can change the helper\'s position to absolute\n\t\t// TODO: Still need to figure out a way to make relative sorting possible\n\t\tthis.helper.css("position", "absolute");\n\t\tthis.cssPosition = this.helper.css("position");\n\n\t\t//Generate the original position\n\t\tthis.originalPosition = this._generatePosition(event);\n\t\tthis.originalPageX = event.pageX;\n\t\tthis.originalPageY = event.pageY;\n\n\t\t//Adjust the mouse offset relative to the helper if "cursorAt" is supplied\n\t\t(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n\t\t//Cache the former DOM position\n\t\tthis.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\n\n\t\t//If the helper is not the original, hide the original so it\'s not playing any role during the drag, won\'t cause anything bad this way\n\t\tif(this.helper[0] !== this.currentItem[0]) {\n\t\t\tthis.currentItem.hide();\n\t\t}\n\n\t\t//Create the placeholder\n\t\tthis._createPlaceholder();\n\n\t\t//Set a containment if given in the options\n\t\tif(o.containment) {\n\t\t\tthis._setContainment();\n\t\t}\n\n\t\tif( o.cursor && o.cursor !== "auto" ) { // cursor option\n\t\t\tbody = this.document.find( "body" );\n\n\t\t\t// support: IE\n\t\t\tthis.storedCursor = body.css( "cursor" );\n\t\t\tbody.css( "cursor", o.cursor );\n\n\t\t\tthis.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );\n\t\t}\n\n\t\tif(o.opacity) { // opacity option\n\t\t\tif (this.helper.css("opacity")) {\n\t\t\t\tthis._storedOpacity = this.helper.css("opacity");\n\t\t\t}\n\t\t\tthis.helper.css("opacity", o.opacity);\n\t\t}\n\n\t\tif(o.zIndex) { // zIndex option\n\t\t\tif (this.helper.css("zIndex")) {\n\t\t\t\tthis._storedZIndex = this.helper.css("zIndex");\n\t\t\t}\n\t\t\tthis.helper.css("zIndex", o.zIndex);\n\t\t}\n\n\t\t//Prepare scrolling\n\t\tif(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {\n\t\t\tthis.overflowOffset = this.scrollParent.offset();\n\t\t}\n\n\t\t//Call callbacks\n\t\tthis._trigger("start", event, this._uiHash());\n\n\t\t//Recache the helper size\n\t\tif(!this._preserveHelperProportions) {\n\t\t\tthis._cacheHelperProportions();\n\t\t}\n\n\n\t\t//Post "activate" events to possible containers\n\t\tif( !noActivation ) {\n\t\t\tfor ( i = this.containers.length - 1; i >= 0; i-- ) {\n\t\t\t\tthis.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );\n\t\t\t}\n\t\t}\n\n\t\t//Prepare possible droppables\n\t\tif($.ui.ddmanager) {\n\t\t\t$.ui.ddmanager.current = this;\n\t\t}\n\n\t\tif ($.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t}\n\n\t\tthis.dragging = true;\n\n\t\tthis.helper.addClass("ui-sortable-helper");\n\t\tthis._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\t\treturn true;\n\n\t},\n\n\t_mouseDrag: function(event) {\n\t\tvar i, item, itemElement, intersection,\n\t\t\to = this.options,\n\t\t\tscrolled = false;\n\n\t\t//Compute the helpers position\n\t\tthis.position = this._generatePosition(event);\n\t\tthis.positionAbs = this._convertPositionTo("absolute");\n\n\t\tif (!this.lastPositionAbs) {\n\t\t\tthis.lastPositionAbs = this.positionAbs;\n\t\t}\n\n\t\t//Do scrolling\n\t\tif(this.options.scroll) {\n\t\t\tif(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {\n\n\t\t\t\tif((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {\n\t\t\t\t\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\n\t\t\t\t} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {\n\t\t\t\t\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\n\t\t\t\t}\n\n\t\t\t\tif((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {\n\t\t\t\t\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\n\t\t\t\t} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {\n\t\t\t\t\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif(event.pageY - this.document.scrollTop() < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);\n\t\t\t\t} else if(this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);\n\t\t\t\t}\n\n\t\t\t\tif(event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);\n\t\t\t\t} else if(this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t\t}\n\t\t}\n\n\t\t//Regenerate the absolute position used for position checks\n\t\tthis.positionAbs = this._convertPositionTo("absolute");\n\n\t\t//Set the helper position\n\t\tif(!this.options.axis || this.options.axis !== "y") {\n\t\t\tthis.helper[0].style.left = this.position.left+"px";\n\t\t}\n\t\tif(!this.options.axis || this.options.axis !== "x") {\n\t\t\tthis.helper[0].style.top = this.position.top+"px";\n\t\t}\n\n\t\t//Rearrange\n\t\tfor (i = this.items.length - 1; i >= 0; i--) {\n\n\t\t\t//Cache variables and intersection, continue if no intersection\n\t\t\titem = this.items[i];\n\t\t\titemElement = item.item[0];\n\t\t\tintersection = this._intersectsWithPointer(item);\n\t\t\tif (!intersection) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Only put the placeholder inside the current Container, skip all\n\t\t\t// items from other containers. This works because when moving\n\t\t\t// an item from one container to another the\n\t\t\t// currentContainer is switched before the placeholder is moved.\n\t\t\t//\n\t\t\t// Without this, moving items in "sub-sortables" can cause\n\t\t\t// the placeholder to jitter between the outer and inner container.\n\t\t\tif (item.instance !== this.currentContainer) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// cannot intersect with itself\n\t\t\t// no useless actions that have been done before\n\t\t\t// no action if the item moved is the parent of the item checked\n\t\t\tif (itemElement !== this.currentItem[0] &&\n\t\t\t\tthis.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&\n\t\t\t\t!$.contains(this.placeholder[0], itemElement) &&\n\t\t\t\t(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)\n\t\t\t) {\n\n\t\t\t\tthis.direction = intersection === 1 ? "down" : "up";\n\n\t\t\t\tif (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {\n\t\t\t\t\tthis._rearrange(event, item);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tthis._trigger("change", event, this._uiHash());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//Post events to containers\n\t\tthis._contactContainers(event);\n\n\t\t//Interconnect with droppables\n\t\tif($.ui.ddmanager) {\n\t\t\t$.ui.ddmanager.drag(this, event);\n\t\t}\n\n\t\t//Call callbacks\n\t\tthis._trigger("sort", event, this._uiHash());\n\n\t\tthis.lastPositionAbs = this.positionAbs;\n\t\treturn false;\n\n\t},\n\n\t_mouseStop: function(event, noPropagation) {\n\n\t\tif(!event) {\n\t\t\treturn;\n\t\t}\n\n\t\t//If we are using droppables, inform the manager about the drop\n\t\tif ($.ui.ddmanager && !this.options.dropBehaviour) {\n\t\t\t$.ui.ddmanager.drop(this, event);\n\t\t}\n\n\t\tif(this.options.revert) {\n\t\t\tvar that = this,\n\t\t\t\tcur = this.placeholder.offset(),\n\t\t\t\taxis = this.options.axis,\n\t\t\t\tanimation = {};\n\n\t\t\tif ( !axis || axis === "x" ) {\n\t\t\t\tanimation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);\n\t\t\t}\n\t\t\tif ( !axis || axis === "y" ) {\n\t\t\t\tanimation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);\n\t\t\t}\n\t\t\tthis.reverting = true;\n\t\t\t$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {\n\t\t\t\tthat._clear(event);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._clear(event, noPropagation);\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tcancel: function() {\n\n\t\tif(this.dragging) {\n\n\t\t\tthis._mouseUp({ target: null });\n\n\t\t\tif(this.options.helper === "original") {\n\t\t\t\tthis.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");\n\t\t\t} else {\n\t\t\t\tthis.currentItem.show();\n\t\t\t}\n\n\t\t\t//Post deactivating events to containers\n\t\t\tfor (var i = this.containers.length - 1; i >= 0; i--){\n\t\t\t\tthis.containers[i]._trigger("deactivate", null, this._uiHash(this));\n\t\t\t\tif(this.containers[i].containerCache.over) {\n\t\t\t\t\tthis.containers[i]._trigger("out", null, this._uiHash(this));\n\t\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (this.placeholder) {\n\t\t\t//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n\t\t\tif(this.placeholder[0].parentNode) {\n\t\t\t\tthis.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\t\t\t}\n\t\t\tif(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {\n\t\t\t\tthis.helper.remove();\n\t\t\t}\n\n\t\t\t$.extend(this, {\n\t\t\t\thelper: null,\n\t\t\t\tdragging: false,\n\t\t\t\treverting: false,\n\t\t\t\t_noFinalSort: null\n\t\t\t});\n\n\t\t\tif(this.domPosition.prev) {\n\t\t\t\t$(this.domPosition.prev).after(this.currentItem);\n\t\t\t} else {\n\t\t\t\t$(this.domPosition.parent).prepend(this.currentItem);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tserialize: function(o) {\n\n\t\tvar items = this._getItemsAsjQuery(o && o.connected),\n\t\t\tstr = [];\n\t\to = o || {};\n\n\t\t$(items).each(function() {\n\t\t\tvar res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\\-=_](.+)/));\n\t\t\tif (res) {\n\t\t\t\tstr.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));\n\t\t\t}\n\t\t});\n\n\t\tif(!str.length && o.key) {\n\t\t\tstr.push(o.key + "=");\n\t\t}\n\n\t\treturn str.join("&");\n\n\t},\n\n\ttoArray: function(o) {\n\n\t\tvar items = this._getItemsAsjQuery(o && o.connected),\n\t\t\tret = [];\n\n\t\to = o || {};\n\n\t\titems.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });\n\t\treturn ret;\n\n\t},\n\n\t/* Be careful with the following core functions */\n\t_intersectsWith: function(item) {\n\n\t\tvar x1 = this.positionAbs.left,\n\t\t\tx2 = x1 + this.helperProportions.width,\n\t\t\ty1 = this.positionAbs.top,\n\t\t\ty2 = y1 + this.helperProportions.height,\n\t\t\tl = item.left,\n\t\t\tr = l + item.width,\n\t\t\tt = item.top,\n\t\t\tb = t + item.height,\n\t\t\tdyClick = this.offset.click.top,\n\t\t\tdxClick = this.offset.click.left,\n\t\t\tisOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),\n\t\t\tisOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),\n\t\t\tisOverElement = isOverElementHeight && isOverElementWidth;\n\n\t\tif ( this.options.tolerance === "pointer" ||\n\t\t\tthis.options.forcePointerForContainers ||\n\t\t\t(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])\n\t\t) {\n\t\t\treturn isOverElement;\n\t\t} else {\n\n\t\t\treturn (l < x1 + (this.helperProportions.width / 2) && // Right Half\n\t\t\t\tx2 - (this.helperProportions.width / 2) < r && // Left Half\n\t\t\t\tt < y1 + (this.helperProportions.height / 2) && // Bottom Half\n\t\t\t\ty2 - (this.helperProportions.height / 2) < b ); // Top Half\n\n\t\t}\n\t},\n\n\t_intersectsWithPointer: function(item) {\n\n\t\tvar isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\n\t\t\tisOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\n\t\t\tisOverElement = isOverElementHeight && isOverElementWidth,\n\t\t\tverticalDirection = this._getDragVerticalDirection(),\n\t\t\thorizontalDirection = this._getDragHorizontalDirection();\n\n\t\tif (!isOverElement) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.floating ?\n\t\t\t( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )\n\t\t\t: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );\n\n\t},\n\n\t_intersectsWithSides: function(item) {\n\n\t\tvar isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),\n\t\t\tisOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),\n\t\t\tverticalDirection = this._getDragVerticalDirection(),\n\t\t\thorizontalDirection = this._getDragHorizontalDirection();\n\n\t\tif (this.floating && horizontalDirection) {\n\t\t\treturn ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));\n\t\t} else {\n\t\t\treturn verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));\n\t\t}\n\n\t},\n\n\t_getDragVerticalDirection: function() {\n\t\tvar delta = this.positionAbs.top - this.lastPositionAbs.top;\n\t\treturn delta !== 0 && (delta > 0 ? "down" : "up");\n\t},\n\n\t_getDragHorizontalDirection: function() {\n\t\tvar delta = this.positionAbs.left - this.lastPositionAbs.left;\n\t\treturn delta !== 0 && (delta > 0 ? "right" : "left");\n\t},\n\n\trefresh: function(event) {\n\t\tthis._refreshItems(event);\n\t\tthis._setHandleClassName();\n\t\tthis.refreshPositions();\n\t\treturn this;\n\t},\n\n\t_connectWith: function() {\n\t\tvar options = this.options;\n\t\treturn options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;\n\t},\n\n\t_getItemsAsjQuery: function(connected) {\n\n\t\tvar i, j, cur, inst,\n\t\t\titems = [],\n\t\t\tqueries = [],\n\t\t\tconnectWith = this._connectWith();\n\n\t\tif(connectWith && connected) {\n\t\t\tfor (i = connectWith.length - 1; i >= 0; i--){\n\t\t\t\tcur = $(connectWith[i], this.document[0]);\n\t\t\t\tfor ( j = cur.length - 1; j >= 0; j--){\n\t\t\t\t\tinst = $.data(cur[j], this.widgetFullName);\n\t\t\t\t\tif(inst && inst !== this && !inst.options.disabled) {\n\t\t\t\t\t\tqueries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);\n\n\t\tfunction addItems() {\n\t\t\titems.push( this );\n\t\t}\n\t\tfor (i = queries.length - 1; i >= 0; i--){\n\t\t\tqueries[i][0].each( addItems );\n\t\t}\n\n\t\treturn $(items);\n\n\t},\n\n\t_removeCurrentsFromItems: function() {\n\n\t\tvar list = this.currentItem.find(":data(" + this.widgetName + "-item)");\n\n\t\tthis.items = $.grep(this.items, function (item) {\n\t\t\tfor (var j=0; j < list.length; j++) {\n\t\t\t\tif(list[j] === item.item[0]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t},\n\n\t_refreshItems: function(event) {\n\n\t\tthis.items = [];\n\t\tthis.containers = [this];\n\n\t\tvar i, j, cur, inst, targetData, _queries, item, queriesLength,\n\t\t\titems = this.items,\n\t\t\tqueries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],\n\t\t\tconnectWith = this._connectWith();\n\n\t\tif(connectWith && this.ready) { //Shouldn\'t be run the first time through due to massive slow-down\n\t\t\tfor (i = connectWith.length - 1; i >= 0; i--){\n\t\t\t\tcur = $(connectWith[i], this.document[0]);\n\t\t\t\tfor (j = cur.length - 1; j >= 0; j--){\n\t\t\t\t\tinst = $.data(cur[j], this.widgetFullName);\n\t\t\t\t\tif(inst && inst !== this && !inst.options.disabled) {\n\t\t\t\t\t\tqueries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\n\t\t\t\t\t\tthis.containers.push(inst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = queries.length - 1; i >= 0; i--) {\n\t\t\ttargetData = queries[i][1];\n\t\t\t_queries = queries[i][0];\n\n\t\t\tfor (j=0, queriesLength = _queries.length; j < queriesLength; j++) {\n\t\t\t\titem = $(_queries[j]);\n\n\t\t\t\titem.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)\n\n\t\t\t\titems.push({\n\t\t\t\t\titem: item,\n\t\t\t\t\tinstance: targetData,\n\t\t\t\t\twidth: 0, height: 0,\n\t\t\t\t\tleft: 0, top: 0\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t},\n\n\trefreshPositions: function(fast) {\n\n\t\t// Determine whether items are being displayed horizontally\n\t\tthis.floating = this.items.length ?\n\t\t\tthis.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :\n\t\t\tfalse;\n\n\t\t//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent\'s position will change\n\t\tif(this.offsetParent && this.helper) {\n\t\t\tthis.offset.parent = this._getParentOffset();\n\t\t}\n\n\t\tvar i, item, t, p;\n\n\t\tfor (i = this.items.length - 1; i >= 0; i--){\n\t\t\titem = this.items[i];\n\n\t\t\t//We ignore calculating positions of all connected containers when we\'re not over them\n\t\t\tif(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tt = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\n\n\t\t\tif (!fast) {\n\t\t\t\titem.width = t.outerWidth();\n\t\t\t\titem.height = t.outerHeight();\n\t\t\t}\n\n\t\t\tp = t.offset();\n\t\t\titem.left = p.left;\n\t\t\titem.top = p.top;\n\t\t}\n\n\t\tif(this.options.custom && this.options.custom.refreshContainers) {\n\t\t\tthis.options.custom.refreshContainers.call(this);\n\t\t} else {\n\t\t\tfor (i = this.containers.length - 1; i >= 0; i--){\n\t\t\t\tp = this.containers[i].element.offset();\n\t\t\t\tthis.containers[i].containerCache.left = p.left;\n\t\t\t\tthis.containers[i].containerCache.top = p.top;\n\t\t\t\tthis.containers[i].containerCache.width = this.containers[i].element.outerWidth();\n\t\t\t\tthis.containers[i].containerCache.height = this.containers[i].element.outerHeight();\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_createPlaceholder: function(that) {\n\t\tthat = that || this;\n\t\tvar className,\n\t\t\to = that.options;\n\n\t\tif(!o.placeholder || o.placeholder.constructor === String) {\n\t\t\tclassName = o.placeholder;\n\t\t\to.placeholder = {\n\t\t\t\telement: function() {\n\n\t\t\t\t\tvar nodeName = that.currentItem[0].nodeName.toLowerCase(),\n\t\t\t\t\t\telement = $( "<" + nodeName + ">", that.document[0] )\n\t\t\t\t\t\t\t.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")\n\t\t\t\t\t\t\t.removeClass("ui-sortable-helper");\n\n\t\t\t\t\tif ( nodeName === "tbody" ) {\n\t\t\t\t\t\tthat._createTrPlaceholder(\n\t\t\t\t\t\t\tthat.currentItem.find( "tr" ).eq( 0 ),\n\t\t\t\t\t\t\t$( "<tr>", that.document[ 0 ] ).appendTo( element )\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if ( nodeName === "tr" ) {\n\t\t\t\t\t\tthat._createTrPlaceholder( that.currentItem, element );\n\t\t\t\t\t} else if ( nodeName === "img" ) {\n\t\t\t\t\t\telement.attr( "src", that.currentItem.attr( "src" ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !className ) {\n\t\t\t\t\t\telement.css( "visibility", "hidden" );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn element;\n\t\t\t\t},\n\t\t\t\tupdate: function(container, p) {\n\n\t\t\t\t\t// 1. If a className is set as \'placeholder option, we don\'t force sizes - the class is responsible for that\n\t\t\t\t\t// 2. The option \'forcePlaceholderSize can be enabled to force it even if a class name is specified\n\t\t\t\t\tif(className && !o.forcePlaceholderSize) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t//If the element doesn\'t have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\n\t\t\t\t\tif(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }\n\t\t\t\t\tif(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t//Create the placeholder\n\t\tthat.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\n\n\t\t//Append it after the actual current item\n\t\tthat.currentItem.after(that.placeholder);\n\n\t\t//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\n\t\to.placeholder.update(that, that.placeholder);\n\n\t},\n\n\t_createTrPlaceholder: function( sourceTr, targetTr ) {\n\t\tvar that = this;\n\n\t\tsourceTr.children().each(function() {\n\t\t\t$( "<td>&#160;</td>", that.document[ 0 ] )\n\t\t\t\t.attr( "colspan", $( this ).attr( "colspan" ) || 1 )\n\t\t\t\t.appendTo( targetTr );\n\t\t});\n\t},\n\n\t_contactContainers: function(event) {\n\t\tvar i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,\n\t\t\tinnermostContainer = null,\n\t\t\tinnermostIndex = null;\n\n\t\t// get innermost container that intersects with item\n\t\tfor (i = this.containers.length - 1; i >= 0; i--) {\n\n\t\t\t// never consider a container that\'s located within the item itself\n\t\t\tif($.contains(this.currentItem[0], this.containers[i].element[0])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(this._intersectsWith(this.containers[i].containerCache)) {\n\n\t\t\t\t// if we\'ve already found a container and it\'s more "inner" than this, then continue\n\t\t\t\tif(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tinnermostContainer = this.containers[i];\n\t\t\t\tinnermostIndex = i;\n\n\t\t\t} else {\n\t\t\t\t// container doesn\'t intersect. trigger "out" event if necessary\n\t\t\t\tif(this.containers[i].containerCache.over) {\n\t\t\t\t\tthis.containers[i]._trigger("out", event, this._uiHash(this));\n\t\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// if no intersecting containers found, return\n\t\tif(!innermostContainer) {\n\t\t\treturn;\n\t\t}\n\n\t\t// move the item into the container if it\'s not there already\n\t\tif(this.containers.length === 1) {\n\t\t\tif (!this.containers[innermostIndex].containerCache.over) {\n\t\t\t\tthis.containers[innermostIndex]._trigger("over", event, this._uiHash(this));\n\t\t\t\tthis.containers[innermostIndex].containerCache.over = 1;\n\t\t\t}\n\t\t} else {\n\n\t\t\t//When entering a new container, we will find the item with the least distance and append our item near it\n\t\t\tdist = 10000;\n\t\t\titemWithLeastDistance = null;\n\t\t\tfloating = innermostContainer.floating || this._isFloating(this.currentItem);\n\t\t\tposProperty = floating ? "left" : "top";\n\t\t\tsizeProperty = floating ? "width" : "height";\n\t\t\taxis = floating ? "clientX" : "clientY";\n\n\t\t\tfor (j = this.items.length - 1; j >= 0; j--) {\n\t\t\t\tif(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(this.items[j].item[0] === this.currentItem[0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcur = this.items[j].item.offset()[posProperty];\n\t\t\t\tnearBottom = false;\n\t\t\t\tif ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {\n\t\t\t\t\tnearBottom = true;\n\t\t\t\t}\n\n\t\t\t\tif ( Math.abs( event[ axis ] - cur ) < dist ) {\n\t\t\t\t\tdist = Math.abs( event[ axis ] - cur );\n\t\t\t\t\titemWithLeastDistance = this.items[ j ];\n\t\t\t\t\tthis.direction = nearBottom ? "up": "down";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Check if dropOnEmpty is enabled\n\t\t\tif(!itemWithLeastDistance && !this.options.dropOnEmpty) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(this.currentContainer === this.containers[innermostIndex]) {\n\t\t\t\tif ( !this.currentContainer.containerCache.over ) {\n\t\t\t\t\tthis.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );\n\t\t\t\t\tthis.currentContainer.containerCache.over = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\n\t\t\tthis._trigger("change", event, this._uiHash());\n\t\t\tthis.containers[innermostIndex]._trigger("change", event, this._uiHash(this));\n\t\t\tthis.currentContainer = this.containers[innermostIndex];\n\n\t\t\t//Update the placeholder\n\t\t\tthis.options.placeholder.update(this.currentContainer, this.placeholder);\n\n\t\t\tthis.containers[innermostIndex]._trigger("over", event, this._uiHash(this));\n\t\t\tthis.containers[innermostIndex].containerCache.over = 1;\n\t\t}\n\n\n\t},\n\n\t_createHelper: function(event) {\n\n\t\tvar o = this.options,\n\t\t\thelper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);\n\n\t\t//Add the helper to the DOM if that didn\'t happen already\n\t\tif(!helper.parents("body").length) {\n\t\t\t$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\n\t\t}\n\n\t\tif(helper[0] === this.currentItem[0]) {\n\t\t\tthis._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };\n\t\t}\n\n\t\tif(!helper[0].style.width || o.forceHelperSize) {\n\t\t\thelper.width(this.currentItem.width());\n\t\t}\n\t\tif(!helper[0].style.height || o.forceHelperSize) {\n\t\t\thelper.height(this.currentItem.height());\n\t\t}\n\n\t\treturn helper;\n\n\t},\n\n\t_adjustOffsetFromHelper: function(obj) {\n\t\tif (typeof obj === "string") {\n\t\t\tobj = obj.split(" ");\n\t\t}\n\t\tif ($.isArray(obj)) {\n\t\t\tobj = {left: +obj[0], top: +obj[1] || 0};\n\t\t}\n\t\tif ("left" in obj) {\n\t\t\tthis.offset.click.left = obj.left + this.margins.left;\n\t\t}\n\t\tif ("right" in obj) {\n\t\t\tthis.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n\t\t}\n\t\tif ("top" in obj) {\n\t\t\tthis.offset.click.top = obj.top + this.margins.top;\n\t\t}\n\t\tif ("bottom" in obj) {\n\t\t\tthis.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n\t\t}\n\t},\n\n\t_getParentOffset: function() {\n\n\n\t\t//Get the offsetParent and cache its position\n\t\tthis.offsetParent = this.helper.offsetParent();\n\t\tvar po = this.offsetParent.offset();\n\n\t\t// This is a special case where we need to modify a offset calculated on start, since the following happened:\n\t\t// 1. The position of the helper is absolute, so it\'s position is calculated based on the next positioned parent\n\t\t// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn\'t the document, which means that\n\t\t//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n\t\tif(this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n\t\t\tpo.left += this.scrollParent.scrollLeft();\n\t\t\tpo.top += this.scrollParent.scrollTop();\n\t\t}\n\n\t\t// This needs to be actually done for all browsers, since pageX/pageY includes this information\n\t\t// with an ugly IE fix\n\t\tif( this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {\n\t\t\tpo = { top: 0, left: 0 };\n\t\t}\n\n\t\treturn {\n\t\t\ttop: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),\n\t\t\tleft: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)\n\t\t};\n\n\t},\n\n\t_getRelativeOffset: function() {\n\n\t\tif(this.cssPosition === "relative") {\n\t\t\tvar p = this.currentItem.position();\n\t\t\treturn {\n\t\t\t\ttop: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),\n\t\t\t\tleft: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()\n\t\t\t};\n\t\t} else {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t},\n\n\t_cacheMargins: function() {\n\t\tthis.margins = {\n\t\t\tleft: (parseInt(this.currentItem.css("marginLeft"),10) || 0),\n\t\t\ttop: (parseInt(this.currentItem.css("marginTop"),10) || 0)\n\t\t};\n\t},\n\n\t_cacheHelperProportions: function() {\n\t\tthis.helperProportions = {\n\t\t\twidth: this.helper.outerWidth(),\n\t\t\theight: this.helper.outerHeight()\n\t\t};\n\t},\n\n\t_setContainment: function() {\n\n\t\tvar ce, co, over,\n\t\t\to = this.options;\n\t\tif(o.containment === "parent") {\n\t\t\to.containment = this.helper[0].parentNode;\n\t\t}\n\t\tif(o.containment === "document" || o.containment === "window") {\n\t\t\tthis.containment = [\n\t\t\t\t0 - this.offset.relative.left - this.offset.parent.left,\n\t\t\t\t0 - this.offset.relative.top - this.offset.parent.top,\n\t\t\t\to.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,\n\t\t\t\t(o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\n\t\t\t];\n\t\t}\n\n\t\tif(!(/^(document|window|parent)$/).test(o.containment)) {\n\t\t\tce = $(o.containment)[0];\n\t\t\tco = $(o.containment).offset();\n\t\t\tover = ($(ce).css("overflow") !== "hidden");\n\n\t\t\tthis.containment = [\n\t\t\t\tco.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,\n\t\t\t\tco.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,\n\t\t\t\tco.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,\n\t\t\t\tco.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top\n\t\t\t];\n\t\t}\n\n\t},\n\n\t_convertPositionTo: function(d, pos) {\n\n\t\tif(!pos) {\n\t\t\tpos = this.position;\n\t\t}\n\t\tvar mod = d === "absolute" ? 1 : -1,\n\t\t\tscroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n\t\t\tscrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n\t\treturn {\n\t\t\ttop: (\n\t\t\t\tpos.top\t+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.relative.top * mod +\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top * mod -\t\t\t\t\t\t\t\t\t\t\t// The offsetParent\'s offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\n\t\t\t),\n\t\t\tleft: (\n\t\t\t\tpos.left +\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.relative.left * mod +\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left * mod\t-\t\t\t\t\t\t\t\t\t\t// The offsetParent\'s offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\n\t\t\t)\n\t\t};\n\n\t},\n\n\t_generatePosition: function(event) {\n\n\t\tvar top, left,\n\t\t\to = this.options,\n\t\t\tpageX = event.pageX,\n\t\t\tpageY = event.pageY,\n\t\t\tscroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n\t\t// This is another very weird special case that only happens for relative elements:\n\t\t// 1. If the css position is relative\n\t\t// 2. and the scroll parent is the document or similar to the offset parent\n\t\t// we have to refresh the relative offset during the scroll so there are no jumps\n\t\tif(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {\n\t\t\tthis.offset.relative = this._getRelativeOffset();\n\t\t}\n\n\t\t/*\n\t\t * - Position constraining -\n\t\t * Constrain the position to a mix of grid, containment.\n\t\t */\n\n\t\tif(this.originalPosition) { //If we are not dragging yet, we won\'t check for options\n\n\t\t\tif(this.containment) {\n\t\t\t\tif(event.pageX - this.offset.click.left < this.containment[0]) {\n\t\t\t\t\tpageX = this.containment[0] + this.offset.click.left;\n\t\t\t\t}\n\t\t\t\tif(event.pageY - this.offset.click.top < this.containment[1]) {\n\t\t\t\t\tpageY = this.containment[1] + this.offset.click.top;\n\t\t\t\t}\n\t\t\t\tif(event.pageX - this.offset.click.left > this.containment[2]) {\n\t\t\t\t\tpageX = this.containment[2] + this.offset.click.left;\n\t\t\t\t}\n\t\t\t\tif(event.pageY - this.offset.click.top > this.containment[3]) {\n\t\t\t\t\tpageY = this.containment[3] + this.offset.click.top;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(o.grid) {\n\t\t\t\ttop = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\n\t\t\t\tpageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n\t\t\t\tleft = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\n\t\t\t\tpageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttop: (\n\t\t\t\tpageY -\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.click.top -\t\t\t\t\t\t\t\t\t\t\t\t\t// Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.top\t-\t\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top +\t\t\t\t\t\t\t\t\t\t\t\t// The offsetParent\'s offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\n\t\t\t),\n\t\t\tleft: (\n\t\t\t\tpageX -\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.click.left -\t\t\t\t\t\t\t\t\t\t\t\t// Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.left\t-\t\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left +\t\t\t\t\t\t\t\t\t\t\t\t// The offsetParent\'s offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\n\t\t\t)\n\t\t};\n\n\t},\n\n\t_rearrange: function(event, i, a, hardRefresh) {\n\n\t\ta ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));\n\n\t\t//Various things done here to improve the performance:\n\t\t// 1. we create a setTimeout, that calls refreshPositions\n\t\t// 2. on the instance, we have a counter variable, that get\'s higher after every append\n\t\t// 3. on the local scope, we copy the counter variable, and check in the timeout, if it\'s still the same\n\t\t// 4. this lets only the last addition to the timeout stack through\n\t\tthis.counter = this.counter ? ++this.counter : 1;\n\t\tvar counter = this.counter;\n\n\t\tthis._delay(function() {\n\t\t\tif(counter === this.counter) {\n\t\t\t\tthis.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\n\t\t\t}\n\t\t});\n\n\t},\n\n\t_clear: function(event, noPropagation) {\n\n\t\tthis.reverting = false;\n\t\t// We delay all events that have to be triggered to after the point where the placeholder has been removed and\n\t\t// everything else normalized again\n\t\tvar i,\n\t\t\tdelayedTriggers = [];\n\n\t\t// We first have to update the dom position of the actual currentItem\n\t\t// Note: don\'t do it if the current item is already removed (by a user), or it gets reappended (see #4088)\n\t\tif(!this._noFinalSort && this.currentItem.parent().length) {\n\t\t\tthis.placeholder.before(this.currentItem);\n\t\t}\n\t\tthis._noFinalSort = null;\n\n\t\tif(this.helper[0] === this.currentItem[0]) {\n\t\t\tfor(i in this._storedCSS) {\n\t\t\t\tif(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {\n\t\t\t\t\tthis._storedCSS[i] = "";\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");\n\t\t} else {\n\t\t\tthis.currentItem.show();\n\t\t}\n\n\t\tif(this.fromOutside && !noPropagation) {\n\t\t\tdelayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });\n\t\t}\n\t\tif((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {\n\t\t\tdelayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed\n\t\t}\n\n\t\t// Check if the items Container has Changed and trigger appropriate\n\t\t// events.\n\t\tif (this !== this.currentContainer) {\n\t\t\tif(!noPropagation) {\n\t\t\t\tdelayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });\n\t\t\t\tdelayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));\n\t\t\t\tdelayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));\n\t\t\t}\n\t\t}\n\n\n\t\t//Post events to containers\n\t\tfunction delayEvent( type, instance, container ) {\n\t\t\treturn function( event ) {\n\t\t\t\tcontainer._trigger( type, event, instance._uiHash( instance ) );\n\t\t\t};\n\t\t}\n\t\tfor (i = this.containers.length - 1; i >= 0; i--){\n\t\t\tif (!noPropagation) {\n\t\t\t\tdelayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );\n\t\t\t}\n\t\t\tif(this.containers[i].containerCache.over) {\n\t\t\t\tdelayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );\n\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t}\n\t\t}\n\n\t\t//Do what was originally in plugins\n\t\tif ( this.storedCursor ) {\n\t\t\tthis.document.find( "body" ).css( "cursor", this.storedCursor );\n\t\t\tthis.storedStylesheet.remove();\n\t\t}\n\t\tif(this._storedOpacity) {\n\t\t\tthis.helper.css("opacity", this._storedOpacity);\n\t\t}\n\t\tif(this._storedZIndex) {\n\t\t\tthis.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);\n\t\t}\n\n\t\tthis.dragging = false;\n\n\t\tif(!noPropagation) {\n\t\t\tthis._trigger("beforeStop", event, this._uiHash());\n\t\t}\n\n\t\t//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n\t\tthis.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\n\t\tif ( !this.cancelHelperRemoval ) {\n\t\t\tif ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {\n\t\t\t\tthis.helper.remove();\n\t\t\t}\n\t\t\tthis.helper = null;\n\t\t}\n\n\t\tif(!noPropagation) {\n\t\t\tfor (i=0; i < delayedTriggers.length; i++) {\n\t\t\t\tdelayedTriggers[i].call(this, event);\n\t\t\t} //Trigger all delayed events\n\t\t\tthis._trigger("stop", event, this._uiHash());\n\t\t}\n\n\t\tthis.fromOutside = false;\n\t\treturn !this.cancelHelperRemoval;\n\n\t},\n\n\t_trigger: function() {\n\t\tif ($.Widget.prototype._trigger.apply(this, arguments) === false) {\n\t\t\tthis.cancel();\n\t\t}\n\t},\n\n\t_uiHash: function(_inst) {\n\t\tvar inst = _inst || this;\n\t\treturn {\n\t\t\thelper: inst.helper,\n\t\t\tplaceholder: inst.placeholder || $([]),\n\t\t\tposition: inst.position,\n\t\t\toriginalPosition: inst.originalPosition,\n\t\t\toffset: inst.positionAbs,\n\t\t\titem: inst.currentItem,\n\t\t\tsender: _inst ? _inst.element : null\n\t\t};\n\t}\n\n});\n\n\n/*!\n * jQuery UI Spinner 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/spinner/\n */\n\n\nfunction spinner_modifier( fn ) {\n\treturn function() {\n\t\tvar previous = this.element.val();\n\t\tfn.apply( this, arguments );\n\t\tthis._refresh();\n\t\tif ( previous !== this.element.val() ) {\n\t\t\tthis._trigger( "change" );\n\t\t}\n\t};\n}\n\nvar spinner = $.widget( "ui.spinner", {\n\tversion: "1.11.4",\n\tdefaultElement: "<input>",\n\twidgetEventPrefix: "spin",\n\toptions: {\n\t\tculture: null,\n\t\ticons: {\n\t\t\tdown: "ui-icon-triangle-1-s",\n\t\t\tup: "ui-icon-triangle-1-n"\n\t\t},\n\t\tincremental: true,\n\t\tmax: null,\n\t\tmin: null,\n\t\tnumberFormat: null,\n\t\tpage: 10,\n\t\tstep: 1,\n\n\t\tchange: null,\n\t\tspin: null,\n\t\tstart: null,\n\t\tstop: null\n\t},\n\n\t_create: function() {\n\t\t// handle string values that need to be parsed\n\t\tthis._setOption( "max", this.options.max );\n\t\tthis._setOption( "min", this.options.min );\n\t\tthis._setOption( "step", this.options.step );\n\n\t\t// Only format if there is a value, prevents the field from being marked\n\t\t// as invalid in Firefox, see #9573.\n\t\tif ( this.value() !== "" ) {\n\t\t\t// Format the value, but don\'t constrain.\n\t\t\tthis._value( this.element.val(), true );\n\t\t}\n\n\t\tthis._draw();\n\t\tthis._on( this._events );\n\t\tthis._refresh();\n\n\t\t// turning off autocomplete prevents the browser from remembering the\n\t\t// value when navigating through history, so we re-enable autocomplete\n\t\t// if the page is unloaded before the widget is destroyed. #7790\n\t\tthis._on( this.window, {\n\t\t\tbeforeunload: function() {\n\t\t\t\tthis.element.removeAttr( "autocomplete" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_getCreateOptions: function() {\n\t\tvar options = {},\n\t\t\telement = this.element;\n\n\t\t$.each( [ "min", "max", "step" ], function( i, option ) {\n\t\t\tvar value = element.attr( option );\n\t\t\tif ( value !== undefined && value.length ) {\n\t\t\t\toptions[ option ] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn options;\n\t},\n\n\t_events: {\n\t\tkeydown: function( event ) {\n\t\t\tif ( this._start( event ) && this._keydown( event ) ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t},\n\t\tkeyup: "_stop",\n\t\tfocus: function() {\n\t\t\tthis.previous = this.element.val();\n\t\t},\n\t\tblur: function( event ) {\n\t\t\tif ( this.cancelBlur ) {\n\t\t\t\tdelete this.cancelBlur;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._stop();\n\t\t\tthis._refresh();\n\t\t\tif ( this.previous !== this.element.val() ) {\n\t\t\t\tthis._trigger( "change", event );\n\t\t\t}\n\t\t},\n\t\tmousewheel: function( event, delta ) {\n\t\t\tif ( !delta ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( !this.spinning && !this._start( event ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis._spin( (delta > 0 ? 1 : -1) * this.options.step, event );\n\t\t\tclearTimeout( this.mousewheelTimer );\n\t\t\tthis.mousewheelTimer = this._delay(function() {\n\t\t\t\tif ( this.spinning ) {\n\t\t\t\t\tthis._stop( event );\n\t\t\t\t}\n\t\t\t}, 100 );\n\t\t\tevent.preventDefault();\n\t\t},\n\t\t"mousedown .ui-spinner-button": function( event ) {\n\t\t\tvar previous;\n\n\t\t\t// We never want the buttons to have focus; whenever the user is\n\t\t\t// interacting with the spinner, the focus should be on the input.\n\t\t\t// If the input is focused then this.previous is properly set from\n\t\t\t// when the input first received focus. If the input is not focused\n\t\t\t// then we need to set this.previous based on the value before spinning.\n\t\t\tprevious = this.element[0] === this.document[0].activeElement ?\n\t\t\t\tthis.previous : this.element.val();\n\t\t\tfunction checkFocus() {\n\t\t\t\tvar isActive = this.element[0] === this.document[0].activeElement;\n\t\t\t\tif ( !isActive ) {\n\t\t\t\t\tthis.element.focus();\n\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t// support: IE\n\t\t\t\t\t// IE sets focus asynchronously, so we need to check if focus\n\t\t\t\t\t// moved off of the input because the user clicked on the button.\n\t\t\t\t\tthis._delay(function() {\n\t\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ensure focus is on (or stays on) the text field\n\t\t\tevent.preventDefault();\n\t\t\tcheckFocus.call( this );\n\n\t\t\t// support: IE\n\t\t\t// IE doesn\'t prevent moving focus even with event.preventDefault()\n\t\t\t// so we set a flag to know when we should ignore the blur event\n\t\t\t// and check (again) if focus moved off of the input.\n\t\t\tthis.cancelBlur = true;\n\t\t\tthis._delay(function() {\n\t\t\t\tdelete this.cancelBlur;\n\t\t\t\tcheckFocus.call( this );\n\t\t\t});\n\n\t\t\tif ( this._start( event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );\n\t\t},\n\t\t"mouseup .ui-spinner-button": "_stop",\n\t\t"mouseenter .ui-spinner-button": function( event ) {\n\t\t\t// button will add ui-state-active if mouse was down while mouseleave and kept down\n\t\t\tif ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( this._start( event ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );\n\t\t},\n\t\t// TODO: do we really want to consider this a stop?\n\t\t// shouldn\'t we just stop the repeater and wait until mouseup before\n\t\t// we trigger the stop event?\n\t\t"mouseleave .ui-spinner-button": "_stop"\n\t},\n\n\t_draw: function() {\n\t\tvar uiSpinner = this.uiSpinner = this.element\n\t\t\t.addClass( "ui-spinner-input" )\n\t\t\t.attr( "autocomplete", "off" )\n\t\t\t.wrap( this._uiSpinnerHtml() )\n\t\t\t.parent()\n\t\t\t\t// add buttons\n\t\t\t\t.append( this._buttonHtml() );\n\n\t\tthis.element.attr( "role", "spinbutton" );\n\n\t\t// button bindings\n\t\tthis.buttons = uiSpinner.find( ".ui-spinner-button" )\n\t\t\t.attr( "tabIndex", -1 )\n\t\t\t.button()\n\t\t\t.removeClass( "ui-corner-all" );\n\n\t\t// IE 6 doesn\'t understand height: 50% for the buttons\n\t\t// unless the wrapper has an explicit height\n\t\tif ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&\n\t\t\t\tuiSpinner.height() > 0 ) {\n\t\t\tuiSpinner.height( uiSpinner.height() );\n\t\t}\n\n\t\t// disable spinner if element was already disabled\n\t\tif ( this.options.disabled ) {\n\t\t\tthis.disable();\n\t\t}\n\t},\n\n\t_keydown: function( event ) {\n\t\tvar options = this.options,\n\t\t\tkeyCode = $.ui.keyCode;\n\n\t\tswitch ( event.keyCode ) {\n\t\tcase keyCode.UP:\n\t\t\tthis._repeat( null, 1, event );\n\t\t\treturn true;\n\t\tcase keyCode.DOWN:\n\t\t\tthis._repeat( null, -1, event );\n\t\t\treturn true;\n\t\tcase keyCode.PAGE_UP:\n\t\t\tthis._repeat( null, options.page, event );\n\t\t\treturn true;\n\t\tcase keyCode.PAGE_DOWN:\n\t\t\tthis._repeat( null, -options.page, event );\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_uiSpinnerHtml: function() {\n\t\treturn "<span class=\'ui-spinner ui-widget ui-widget-content ui-corner-all\'></span>";\n\t},\n\n\t_buttonHtml: function() {\n\t\treturn "" +\n\t\t\t"<a class=\'ui-spinner-button ui-spinner-up ui-corner-tr\'>" +\n\t\t\t\t"<span class=\'ui-icon " + this.options.icons.up + "\'>&#9650;</span>" +\n\t\t\t"</a>" +\n\t\t\t"<a class=\'ui-spinner-button ui-spinner-down ui-corner-br\'>" +\n\t\t\t\t"<span class=\'ui-icon " + this.options.icons.down + "\'>&#9660;</span>" +\n\t\t\t"</a>";\n\t},\n\n\t_start: function( event ) {\n\t\tif ( !this.spinning && this._trigger( "start", event ) === false ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !this.counter ) {\n\t\t\tthis.counter = 1;\n\t\t}\n\t\tthis.spinning = true;\n\t\treturn true;\n\t},\n\n\t_repeat: function( i, steps, event ) {\n\t\ti = i || 500;\n\n\t\tclearTimeout( this.timer );\n\t\tthis.timer = this._delay(function() {\n\t\t\tthis._repeat( 40, steps, event );\n\t\t}, i );\n\n\t\tthis._spin( steps * this.options.step, event );\n\t},\n\n\t_spin: function( step, event ) {\n\t\tvar value = this.value() || 0;\n\n\t\tif ( !this.counter ) {\n\t\t\tthis.counter = 1;\n\t\t}\n\n\t\tvalue = this._adjustValue( value + step * this._increment( this.counter ) );\n\n\t\tif ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {\n\t\t\tthis._value( value );\n\t\t\tthis.counter++;\n\t\t}\n\t},\n\n\t_increment: function( i ) {\n\t\tvar incremental = this.options.incremental;\n\n\t\tif ( incremental ) {\n\t\t\treturn $.isFunction( incremental ) ?\n\t\t\t\tincremental( i ) :\n\t\t\t\tMath.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );\n\t\t}\n\n\t\treturn 1;\n\t},\n\n\t_precision: function() {\n\t\tvar precision = this._precisionOf( this.options.step );\n\t\tif ( this.options.min !== null ) {\n\t\t\tprecision = Math.max( precision, this._precisionOf( this.options.min ) );\n\t\t}\n\t\treturn precision;\n\t},\n\n\t_precisionOf: function( num ) {\n\t\tvar str = num.toString(),\n\t\t\tdecimal = str.indexOf( "." );\n\t\treturn decimal === -1 ? 0 : str.length - decimal - 1;\n\t},\n\n\t_adjustValue: function( value ) {\n\t\tvar base, aboveMin,\n\t\t\toptions = this.options;\n\n\t\t// make sure we\'re at a valid step\n\t\t// - find out where we are relative to the base (min or 0)\n\t\tbase = options.min !== null ? options.min : 0;\n\t\taboveMin = value - base;\n\t\t// - round to the nearest step\n\t\taboveMin = Math.round(aboveMin / options.step) * options.step;\n\t\t// - rounding is based on 0, so adjust back to our base\n\t\tvalue = base + aboveMin;\n\n\t\t// fix precision from bad JS floating point math\n\t\tvalue = parseFloat( value.toFixed( this._precision() ) );\n\n\t\t// clamp the value\n\t\tif ( options.max !== null && value > options.max) {\n\t\t\treturn options.max;\n\t\t}\n\t\tif ( options.min !== null && value < options.min ) {\n\t\t\treturn options.min;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t_stop: function( event ) {\n\t\tif ( !this.spinning ) {\n\t\t\treturn;\n\t\t}\n\n\t\tclearTimeout( this.timer );\n\t\tclearTimeout( this.mousewheelTimer );\n\t\tthis.counter = 0;\n\t\tthis.spinning = false;\n\t\tthis._trigger( "stop", event );\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "culture" || key === "numberFormat" ) {\n\t\t\tvar prevValue = this._parse( this.element.val() );\n\t\t\tthis.options[ key ] = value;\n\t\t\tthis.element.val( this._format( prevValue ) );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === "max" || key === "min" || key === "step" ) {\n\t\t\tif ( typeof value === "string" ) {\n\t\t\t\tvalue = this._parse( value );\n\t\t\t}\n\t\t}\n\t\tif ( key === "icons" ) {\n\t\t\tthis.buttons.first().find( ".ui-icon" )\n\t\t\t\t.removeClass( this.options.icons.up )\n\t\t\t\t.addClass( value.up );\n\t\t\tthis.buttons.last().find( ".ui-icon" )\n\t\t\t\t.removeClass( this.options.icons.down )\n\t\t\t\t.addClass( value.down );\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\tif ( key === "disabled" ) {\n\t\t\tthis.widget().toggleClass( "ui-state-disabled", !!value );\n\t\t\tthis.element.prop( "disabled", !!value );\n\t\t\tthis.buttons.button( value ? "disable" : "enable" );\n\t\t}\n\t},\n\n\t_setOptions: spinner_modifier(function( options ) {\n\t\tthis._super( options );\n\t}),\n\n\t_parse: function( val ) {\n\t\tif ( typeof val === "string" && val !== "" ) {\n\t\t\tval = window.Globalize && this.options.numberFormat ?\n\t\t\t\tGlobalize.parseFloat( val, 10, this.options.culture ) : +val;\n\t\t}\n\t\treturn val === "" || isNaN( val ) ? null : val;\n\t},\n\n\t_format: function( value ) {\n\t\tif ( value === "" ) {\n\t\t\treturn "";\n\t\t}\n\t\treturn window.Globalize && this.options.numberFormat ?\n\t\t\tGlobalize.format( value, this.options.numberFormat, this.options.culture ) :\n\t\t\tvalue;\n\t},\n\n\t_refresh: function() {\n\t\tthis.element.attr({\n\t\t\t"aria-valuemin": this.options.min,\n\t\t\t"aria-valuemax": this.options.max,\n\t\t\t// TODO: what should we do with values that can\'t be parsed?\n\t\t\t"aria-valuenow": this._parse( this.element.val() )\n\t\t});\n\t},\n\n\tisValid: function() {\n\t\tvar value = this.value();\n\n\t\t// null is invalid\n\t\tif ( value === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if value gets adjusted, it\'s invalid\n\t\treturn value === this._adjustValue( value );\n\t},\n\n\t// update the value without triggering change\n\t_value: function( value, allowAny ) {\n\t\tvar parsed;\n\t\tif ( value !== "" ) {\n\t\t\tparsed = this._parse( value );\n\t\t\tif ( parsed !== null ) {\n\t\t\t\tif ( !allowAny ) {\n\t\t\t\t\tparsed = this._adjustValue( parsed );\n\t\t\t\t}\n\t\t\t\tvalue = this._format( parsed );\n\t\t\t}\n\t\t}\n\t\tthis.element.val( value );\n\t\tthis._refresh();\n\t},\n\n\t_destroy: function() {\n\t\tthis.element\n\t\t\t.removeClass( "ui-spinner-input" )\n\t\t\t.prop( "disabled", false )\n\t\t\t.removeAttr( "autocomplete" )\n\t\t\t.removeAttr( "role" )\n\t\t\t.removeAttr( "aria-valuemin" )\n\t\t\t.removeAttr( "aria-valuemax" )\n\t\t\t.removeAttr( "aria-valuenow" );\n\t\tthis.uiSpinner.replaceWith( this.element );\n\t},\n\n\tstepUp: spinner_modifier(function( steps ) {\n\t\tthis._stepUp( steps );\n\t}),\n\t_stepUp: function( steps ) {\n\t\tif ( this._start() ) {\n\t\t\tthis._spin( (steps || 1) * this.options.step );\n\t\t\tthis._stop();\n\t\t}\n\t},\n\n\tstepDown: spinner_modifier(function( steps ) {\n\t\tthis._stepDown( steps );\n\t}),\n\t_stepDown: function( steps ) {\n\t\tif ( this._start() ) {\n\t\t\tthis._spin( (steps || 1) * -this.options.step );\n\t\t\tthis._stop();\n\t\t}\n\t},\n\n\tpageUp: spinner_modifier(function( pages ) {\n\t\tthis._stepUp( (pages || 1) * this.options.page );\n\t}),\n\n\tpageDown: spinner_modifier(function( pages ) {\n\t\tthis._stepDown( (pages || 1) * this.options.page );\n\t}),\n\n\tvalue: function( newVal ) {\n\t\tif ( !arguments.length ) {\n\t\t\treturn this._parse( this.element.val() );\n\t\t}\n\t\tspinner_modifier( this._value ).call( this, newVal );\n\t},\n\n\twidget: function() {\n\t\treturn this.uiSpinner;\n\t}\n});\n\n\n/*!\n * jQuery UI Tabs 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/tabs/\n */\n\n\nvar tabs = $.widget( "ui.tabs", {\n\tversion: "1.11.4",\n\tdelay: 300,\n\toptions: {\n\t\tactive: null,\n\t\tcollapsible: false,\n\t\tevent: "click",\n\t\theightStyle: "content",\n\t\thide: null,\n\t\tshow: null,\n\n\t\t// callbacks\n\t\tactivate: null,\n\t\tbeforeActivate: null,\n\t\tbeforeLoad: null,\n\t\tload: null\n\t},\n\n\t_isLocal: (function() {\n\t\tvar rhash = /#.*$/;\n\n\t\treturn function( anchor ) {\n\t\t\tvar anchorUrl, locationUrl;\n\n\t\t\t// support: IE7\n\t\t\t// IE7 doesn\'t normalize the href property when set via script (#9317)\n\t\t\tanchor = anchor.cloneNode( false );\n\n\t\t\tanchorUrl = anchor.href.replace( rhash, "" );\n\t\t\tlocationUrl = location.href.replace( rhash, "" );\n\n\t\t\t// decoding may throw an error if the URL isn\'t UTF-8 (#9518)\n\t\t\ttry {\n\t\t\t\tanchorUrl = decodeURIComponent( anchorUrl );\n\t\t\t} catch ( error ) {}\n\t\t\ttry {\n\t\t\t\tlocationUrl = decodeURIComponent( locationUrl );\n\t\t\t} catch ( error ) {}\n\n\t\t\treturn anchor.hash.length > 1 && anchorUrl === locationUrl;\n\t\t};\n\t})(),\n\n\t_create: function() {\n\t\tvar that = this,\n\t\t\toptions = this.options;\n\n\t\tthis.running = false;\n\n\t\tthis.element\n\t\t\t.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )\n\t\t\t.toggleClass( "ui-tabs-collapsible", options.collapsible );\n\n\t\tthis._processTabs();\n\t\toptions.active = this._initialActive();\n\n\t\t// Take disabling tabs via class attribute from HTML\n\t\t// into account and update option properly.\n\t\tif ( $.isArray( options.disabled ) ) {\n\t\t\toptions.disabled = $.unique( options.disabled.concat(\n\t\t\t\t$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {\n\t\t\t\t\treturn that.tabs.index( li );\n\t\t\t\t})\n\t\t\t) ).sort();\n\t\t}\n\n\t\t// check for length avoids error when initializing empty list\n\t\tif ( this.options.active !== false && this.anchors.length ) {\n\t\t\tthis.active = this._findActive( options.active );\n\t\t} else {\n\t\t\tthis.active = $();\n\t\t}\n\n\t\tthis._refresh();\n\n\t\tif ( this.active.length ) {\n\t\t\tthis.load( options.active );\n\t\t}\n\t},\n\n\t_initialActive: function() {\n\t\tvar active = this.options.active,\n\t\t\tcollapsible = this.options.collapsible,\n\t\t\tlocationHash = location.hash.substring( 1 );\n\n\t\tif ( active === null ) {\n\t\t\t// check the fragment identifier in the URL\n\t\t\tif ( locationHash ) {\n\t\t\t\tthis.tabs.each(function( i, tab ) {\n\t\t\t\t\tif ( $( tab ).attr( "aria-controls" ) === locationHash ) {\n\t\t\t\t\t\tactive = i;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// check for a tab marked active via a class\n\t\t\tif ( active === null ) {\n\t\t\t\tactive = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );\n\t\t\t}\n\n\t\t\t// no active tab, set to false\n\t\t\tif ( active === null || active === -1 ) {\n\t\t\t\tactive = this.tabs.length ? 0 : false;\n\t\t\t}\n\t\t}\n\n\t\t// handle numbers: negative, out of range\n\t\tif ( active !== false ) {\n\t\t\tactive = this.tabs.index( this.tabs.eq( active ) );\n\t\t\tif ( active === -1 ) {\n\t\t\t\tactive = collapsible ? false : 0;\n\t\t\t}\n\t\t}\n\n\t\t// don\'t allow collapsible: false and active: false\n\t\tif ( !collapsible && active === false && this.anchors.length ) {\n\t\t\tactive = 0;\n\t\t}\n\n\t\treturn active;\n\t},\n\n\t_getCreateEventData: function() {\n\t\treturn {\n\t\t\ttab: this.active,\n\t\t\tpanel: !this.active.length ? $() : this._getPanelForTab( this.active )\n\t\t};\n\t},\n\n\t_tabKeydown: function( event ) {\n\t\tvar focusedTab = $( this.document[0].activeElement ).closest( "li" ),\n\t\t\tselectedIndex = this.tabs.index( focusedTab ),\n\t\t\tgoingForward = true;\n\n\t\tif ( this._handlePageNav( event ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch ( event.keyCode ) {\n\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\tselectedIndex++;\n\t\t\t\tbreak;\n\t\t\tcase $.ui.keyCode.UP:\n\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\tgoingForward = false;\n\t\t\t\tselectedIndex--;\n\t\t\t\tbreak;\n\t\t\tcase $.ui.keyCode.END:\n\t\t\t\tselectedIndex = this.anchors.length - 1;\n\t\t\t\tbreak;\n\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\tselectedIndex = 0;\n\t\t\t\tbreak;\n\t\t\tcase $.ui.keyCode.SPACE:\n\t\t\t\t// Activate only, no collapsing\n\t\t\t\tevent.preventDefault();\n\t\t\t\tclearTimeout( this.activating );\n\t\t\t\tthis._activate( selectedIndex );\n\t\t\t\treturn;\n\t\t\tcase $.ui.keyCode.ENTER:\n\t\t\t\t// Toggle (cancel delayed activation, allow collapsing)\n\t\t\t\tevent.preventDefault();\n\t\t\t\tclearTimeout( this.activating );\n\t\t\t\t// Determine if we should collapse or activate\n\t\t\t\tthis._activate( selectedIndex === this.options.active ? false : selectedIndex );\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\t// Focus the appropriate tab, based on which key was pressed\n\t\tevent.preventDefault();\n\t\tclearTimeout( this.activating );\n\t\tselectedIndex = this._focusNextTab( selectedIndex, goingForward );\n\n\t\t// Navigating with control/command key will prevent automatic activation\n\t\tif ( !event.ctrlKey && !event.metaKey ) {\n\n\t\t\t// Update aria-selected immediately so that AT think the tab is already selected.\n\t\t\t// Otherwise AT may confuse the user by stating that they need to activate the tab,\n\t\t\t// but the tab will already be activated by the time the announcement finishes.\n\t\t\tfocusedTab.attr( "aria-selected", "false" );\n\t\t\tthis.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );\n\n\t\t\tthis.activating = this._delay(function() {\n\t\t\t\tthis.option( "active", selectedIndex );\n\t\t\t}, this.delay );\n\t\t}\n\t},\n\n\t_panelKeydown: function( event ) {\n\t\tif ( this._handlePageNav( event ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ctrl+up moves focus to the current tab\n\t\tif ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.active.focus();\n\t\t}\n\t},\n\n\t// Alt+page up/down moves focus to the previous/next tab (and activates)\n\t_handlePageNav: function( event ) {\n\t\tif ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {\n\t\t\tthis._activate( this._focusNextTab( this.options.active - 1, false ) );\n\t\t\treturn true;\n\t\t}\n\t\tif ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {\n\t\t\tthis._activate( this._focusNextTab( this.options.active + 1, true ) );\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t_findNextTab: function( index, goingForward ) {\n\t\tvar lastTabIndex = this.tabs.length - 1;\n\n\t\tfunction constrain() {\n\t\t\tif ( index > lastTabIndex ) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tif ( index < 0 ) {\n\t\t\t\tindex = lastTabIndex;\n\t\t\t}\n\t\t\treturn index;\n\t\t}\n\n\t\twhile ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {\n\t\t\tindex = goingForward ? index + 1 : index - 1;\n\t\t}\n\n\t\treturn index;\n\t},\n\n\t_focusNextTab: function( index, goingForward ) {\n\t\tindex = this._findNextTab( index, goingForward );\n\t\tthis.tabs.eq( index ).focus();\n\t\treturn index;\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "active" ) {\n\t\t\t// _activate() will handle invalid values and update this.options\n\t\t\tthis._activate( value );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === "disabled" ) {\n\t\t\t// don\'t use the widget factory\'s disabled handling\n\t\t\tthis._setupDisabled( value );\n\t\t\treturn;\n\t\t}\n\n\t\tthis._super( key, value);\n\n\t\tif ( key === "collapsible" ) {\n\t\t\tthis.element.toggleClass( "ui-tabs-collapsible", value );\n\t\t\t// Setting collapsible: false while collapsed; open first panel\n\t\t\tif ( !value && this.options.active === false ) {\n\t\t\t\tthis._activate( 0 );\n\t\t\t}\n\t\t}\n\n\t\tif ( key === "event" ) {\n\t\t\tthis._setupEvents( value );\n\t\t}\n\n\t\tif ( key === "heightStyle" ) {\n\t\t\tthis._setupHeightStyle( value );\n\t\t}\n\t},\n\n\t_sanitizeSelector: function( hash ) {\n\t\treturn hash ? hash.replace( /[!"$%&\'()*+,.\\/:;<=>?@\\[\\]\\^`{|}~]/g, "\\\\$&" ) : "";\n\t},\n\n\trefresh: function() {\n\t\tvar options = this.options,\n\t\t\tlis = this.tablist.children( ":has(a[href])" );\n\n\t\t// get disabled tabs from class attribute from HTML\n\t\t// this will get converted to a boolean if needed in _refresh()\n\t\toptions.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {\n\t\t\treturn lis.index( tab );\n\t\t});\n\n\t\tthis._processTabs();\n\n\t\t// was collapsed or no tabs\n\t\tif ( options.active === false || !this.anchors.length ) {\n\t\t\toptions.active = false;\n\t\t\tthis.active = $();\n\t\t// was active, but active tab is gone\n\t\t} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {\n\t\t\t// all remaining tabs are disabled\n\t\t\tif ( this.tabs.length === options.disabled.length ) {\n\t\t\t\toptions.active = false;\n\t\t\t\tthis.active = $();\n\t\t\t// activate previous tab\n\t\t\t} else {\n\t\t\t\tthis._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );\n\t\t\t}\n\t\t// was active, active tab still exists\n\t\t} else {\n\t\t\t// make sure active index is correct\n\t\t\toptions.active = this.tabs.index( this.active );\n\t\t}\n\n\t\tthis._refresh();\n\t},\n\n\t_refresh: function() {\n\t\tthis._setupDisabled( this.options.disabled );\n\t\tthis._setupEvents( this.options.event );\n\t\tthis._setupHeightStyle( this.options.heightStyle );\n\n\t\tthis.tabs.not( this.active ).attr({\n\t\t\t"aria-selected": "false",\n\t\t\t"aria-expanded": "false",\n\t\t\ttabIndex: -1\n\t\t});\n\t\tthis.panels.not( this._getPanelForTab( this.active ) )\n\t\t\t.hide()\n\t\t\t.attr({\n\t\t\t\t"aria-hidden": "true"\n\t\t\t});\n\n\t\t// Make sure one tab is in the tab order\n\t\tif ( !this.active.length ) {\n\t\t\tthis.tabs.eq( 0 ).attr( "tabIndex", 0 );\n\t\t} else {\n\t\t\tthis.active\n\t\t\t\t.addClass( "ui-tabs-active ui-state-active" )\n\t\t\t\t.attr({\n\t\t\t\t\t"aria-selected": "true",\n\t\t\t\t\t"aria-expanded": "true",\n\t\t\t\t\ttabIndex: 0\n\t\t\t\t});\n\t\t\tthis._getPanelForTab( this.active )\n\t\t\t\t.show()\n\t\t\t\t.attr({\n\t\t\t\t\t"aria-hidden": "false"\n\t\t\t\t});\n\t\t}\n\t},\n\n\t_processTabs: function() {\n\t\tvar that = this,\n\t\t\tprevTabs = this.tabs,\n\t\t\tprevAnchors = this.anchors,\n\t\t\tprevPanels = this.panels;\n\n\t\tthis.tablist = this._getList()\n\t\t\t.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )\n\t\t\t.attr( "role", "tablist" )\n\n\t\t\t// Prevent users from focusing disabled tabs via click\n\t\t\t.delegate( "> li", "mousedown" + this.eventNamespace, function( event ) {\n\t\t\t\tif ( $( this ).is( ".ui-state-disabled" ) ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// support: IE <9\n\t\t\t// Preventing the default action in mousedown doesn\'t prevent IE\n\t\t\t// from focusing the element, so if the anchor gets focused, blur.\n\t\t\t// We don\'t have to worry about focusing the previously focused\n\t\t\t// element since clicking on a non-focusable element should focus\n\t\t\t// the body anyway.\n\t\t\t.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {\n\t\t\t\tif ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.tabs = this.tablist.find( "> li:has(a[href])" )\n\t\t\t.addClass( "ui-state-default ui-corner-top" )\n\t\t\t.attr({\n\t\t\t\trole: "tab",\n\t\t\t\ttabIndex: -1\n\t\t\t});\n\n\t\tthis.anchors = this.tabs.map(function() {\n\t\t\t\treturn $( "a", this )[ 0 ];\n\t\t\t})\n\t\t\t.addClass( "ui-tabs-anchor" )\n\t\t\t.attr({\n\t\t\t\trole: "presentation",\n\t\t\t\ttabIndex: -1\n\t\t\t});\n\n\t\tthis.panels = $();\n\n\t\tthis.anchors.each(function( i, anchor ) {\n\t\t\tvar selector, panel, panelId,\n\t\t\t\tanchorId = $( anchor ).uniqueId().attr( "id" ),\n\t\t\t\ttab = $( anchor ).closest( "li" ),\n\t\t\t\toriginalAriaControls = tab.attr( "aria-controls" );\n\n\t\t\t// inline tab\n\t\t\tif ( that._isLocal( anchor ) ) {\n\t\t\t\tselector = anchor.hash;\n\t\t\t\tpanelId = selector.substring( 1 );\n\t\t\t\tpanel = that.element.find( that._sanitizeSelector( selector ) );\n\t\t\t// remote tab\n\t\t\t} else {\n\t\t\t\t// If the tab doesn\'t already have aria-controls,\n\t\t\t\t// generate an id by using a throw-away element\n\t\t\t\tpanelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;\n\t\t\t\tselector = "#" + panelId;\n\t\t\t\tpanel = that.element.find( selector );\n\t\t\t\tif ( !panel.length ) {\n\t\t\t\t\tpanel = that._createPanel( panelId );\n\t\t\t\t\tpanel.insertAfter( that.panels[ i - 1 ] || that.tablist );\n\t\t\t\t}\n\t\t\t\tpanel.attr( "aria-live", "polite" );\n\t\t\t}\n\n\t\t\tif ( panel.length) {\n\t\t\t\tthat.panels = that.panels.add( panel );\n\t\t\t}\n\t\t\tif ( originalAriaControls ) {\n\t\t\t\ttab.data( "ui-tabs-aria-controls", originalAriaControls );\n\t\t\t}\n\t\t\ttab.attr({\n\t\t\t\t"aria-controls": panelId,\n\t\t\t\t"aria-labelledby": anchorId\n\t\t\t});\n\t\t\tpanel.attr( "aria-labelledby", anchorId );\n\t\t});\n\n\t\tthis.panels\n\t\t\t.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )\n\t\t\t.attr( "role", "tabpanel" );\n\n\t\t// Avoid memory leaks (#10056)\n\t\tif ( prevTabs ) {\n\t\t\tthis._off( prevTabs.not( this.tabs ) );\n\t\t\tthis._off( prevAnchors.not( this.anchors ) );\n\t\t\tthis._off( prevPanels.not( this.panels ) );\n\t\t}\n\t},\n\n\t// allow overriding how to find the list for rare usage scenarios (#7715)\n\t_getList: function() {\n\t\treturn this.tablist || this.element.find( "ol,ul" ).eq( 0 );\n\t},\n\n\t_createPanel: function( id ) {\n\t\treturn $( "<div>" )\n\t\t\t.attr( "id", id )\n\t\t\t.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )\n\t\t\t.data( "ui-tabs-destroy", true );\n\t},\n\n\t_setupDisabled: function( disabled ) {\n\t\tif ( $.isArray( disabled ) ) {\n\t\t\tif ( !disabled.length ) {\n\t\t\t\tdisabled = false;\n\t\t\t} else if ( disabled.length === this.anchors.length ) {\n\t\t\t\tdisabled = true;\n\t\t\t}\n\t\t}\n\n\t\t// disable tabs\n\t\tfor ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {\n\t\t\tif ( disabled === true || $.inArray( i, disabled ) !== -1 ) {\n\t\t\t\t$( li )\n\t\t\t\t\t.addClass( "ui-state-disabled" )\n\t\t\t\t\t.attr( "aria-disabled", "true" );\n\t\t\t} else {\n\t\t\t\t$( li )\n\t\t\t\t\t.removeClass( "ui-state-disabled" )\n\t\t\t\t\t.removeAttr( "aria-disabled" );\n\t\t\t}\n\t\t}\n\n\t\tthis.options.disabled = disabled;\n\t},\n\n\t_setupEvents: function( event ) {\n\t\tvar events = {};\n\t\tif ( event ) {\n\t\t\t$.each( event.split(" "), function( index, eventName ) {\n\t\t\t\tevents[ eventName ] = "_eventHandler";\n\t\t\t});\n\t\t}\n\n\t\tthis._off( this.anchors.add( this.tabs ).add( this.panels ) );\n\t\t// Always prevent the default action, even when disabled\n\t\tthis._on( true, this.anchors, {\n\t\t\tclick: function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t});\n\t\tthis._on( this.anchors, events );\n\t\tthis._on( this.tabs, { keydown: "_tabKeydown" } );\n\t\tthis._on( this.panels, { keydown: "_panelKeydown" } );\n\n\t\tthis._focusable( this.tabs );\n\t\tthis._hoverable( this.tabs );\n\t},\n\n\t_setupHeightStyle: function( heightStyle ) {\n\t\tvar maxHeight,\n\t\t\tparent = this.element.parent();\n\n\t\tif ( heightStyle === "fill" ) {\n\t\t\tmaxHeight = parent.height();\n\t\t\tmaxHeight -= this.element.outerHeight() - this.element.height();\n\n\t\t\tthis.element.siblings( ":visible" ).each(function() {\n\t\t\t\tvar elem = $( this ),\n\t\t\t\t\tposition = elem.css( "position" );\n\n\t\t\t\tif ( position === "absolute" || position === "fixed" ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmaxHeight -= elem.outerHeight( true );\n\t\t\t});\n\n\t\t\tthis.element.children().not( this.panels ).each(function() {\n\t\t\t\tmaxHeight -= $( this ).outerHeight( true );\n\t\t\t});\n\n\t\t\tthis.panels.each(function() {\n\t\t\t\t$( this ).height( Math.max( 0, maxHeight -\n\t\t\t\t\t$( this ).innerHeight() + $( this ).height() ) );\n\t\t\t})\n\t\t\t.css( "overflow", "auto" );\n\t\t} else if ( heightStyle === "auto" ) {\n\t\t\tmaxHeight = 0;\n\t\t\tthis.panels.each(function() {\n\t\t\t\tmaxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );\n\t\t\t}).height( maxHeight );\n\t\t}\n\t},\n\n\t_eventHandler: function( event ) {\n\t\tvar options = this.options,\n\t\t\tactive = this.active,\n\t\t\tanchor = $( event.currentTarget ),\n\t\t\ttab = anchor.closest( "li" ),\n\t\t\tclickedIsActive = tab[ 0 ] === active[ 0 ],\n\t\t\tcollapsing = clickedIsActive && options.collapsible,\n\t\t\ttoShow = collapsing ? $() : this._getPanelForTab( tab ),\n\t\t\ttoHide = !active.length ? $() : this._getPanelForTab( active ),\n\t\t\teventData = {\n\t\t\t\toldTab: active,\n\t\t\t\toldPanel: toHide,\n\t\t\t\tnewTab: collapsing ? $() : tab,\n\t\t\t\tnewPanel: toShow\n\t\t\t};\n\n\t\tevent.preventDefault();\n\n\t\tif ( tab.hasClass( "ui-state-disabled" ) ||\n\t\t\t\t// tab is already loading\n\t\t\t\ttab.hasClass( "ui-tabs-loading" ) ||\n\t\t\t\t// can\'t switch durning an animation\n\t\t\t\tthis.running ||\n\t\t\t\t// click on active header, but not collapsible\n\t\t\t\t( clickedIsActive && !options.collapsible ) ||\n\t\t\t\t// allow canceling activation\n\t\t\t\t( this._trigger( "beforeActivate", event, eventData ) === false ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\toptions.active = collapsing ? false : this.tabs.index( tab );\n\n\t\tthis.active = clickedIsActive ? $() : tab;\n\t\tif ( this.xhr ) {\n\t\t\tthis.xhr.abort();\n\t\t}\n\n\t\tif ( !toHide.length && !toShow.length ) {\n\t\t\t$.error( "jQuery UI Tabs: Mismatching fragment identifier." );\n\t\t}\n\n\t\tif ( toShow.length ) {\n\t\t\tthis.load( this.tabs.index( tab ), event );\n\t\t}\n\t\tthis._toggle( event, eventData );\n\t},\n\n\t// handles show/hide for selecting tabs\n\t_toggle: function( event, eventData ) {\n\t\tvar that = this,\n\t\t\ttoShow = eventData.newPanel,\n\t\t\ttoHide = eventData.oldPanel;\n\n\t\tthis.running = true;\n\n\t\tfunction complete() {\n\t\t\tthat.running = false;\n\t\t\tthat._trigger( "activate", event, eventData );\n\t\t}\n\n\t\tfunction show() {\n\t\t\teventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );\n\n\t\t\tif ( toShow.length && that.options.show ) {\n\t\t\t\tthat._show( toShow, that.options.show, complete );\n\t\t\t} else {\n\t\t\t\ttoShow.show();\n\t\t\t\tcomplete();\n\t\t\t}\n\t\t}\n\n\t\t// start out by hiding, then showing, then completing\n\t\tif ( toHide.length && this.options.hide ) {\n\t\t\tthis._hide( toHide, this.options.hide, function() {\n\t\t\t\teventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );\n\t\t\t\tshow();\n\t\t\t});\n\t\t} else {\n\t\t\teventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );\n\t\t\ttoHide.hide();\n\t\t\tshow();\n\t\t}\n\n\t\ttoHide.attr( "aria-hidden", "true" );\n\t\teventData.oldTab.attr({\n\t\t\t"aria-selected": "false",\n\t\t\t"aria-expanded": "false"\n\t\t});\n\t\t// If we\'re switching tabs, remove the old tab from the tab order.\n\t\t// If we\'re opening from collapsed state, remove the previous tab from the tab order.\n\t\t// If we\'re collapsing, then keep the collapsing tab in the tab order.\n\t\tif ( toShow.length && toHide.length ) {\n\t\t\teventData.oldTab.attr( "tabIndex", -1 );\n\t\t} else if ( toShow.length ) {\n\t\t\tthis.tabs.filter(function() {\n\t\t\t\treturn $( this ).attr( "tabIndex" ) === 0;\n\t\t\t})\n\t\t\t.attr( "tabIndex", -1 );\n\t\t}\n\n\t\ttoShow.attr( "aria-hidden", "false" );\n\t\teventData.newTab.attr({\n\t\t\t"aria-selected": "true",\n\t\t\t"aria-expanded": "true",\n\t\t\ttabIndex: 0\n\t\t});\n\t},\n\n\t_activate: function( index ) {\n\t\tvar anchor,\n\t\t\tactive = this._findActive( index );\n\n\t\t// trying to activate the already active panel\n\t\tif ( active[ 0 ] === this.active[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// trying to collapse, simulate a click on the current active header\n\t\tif ( !active.length ) {\n\t\t\tactive = this.active;\n\t\t}\n\n\t\tanchor = active.find( ".ui-tabs-anchor" )[ 0 ];\n\t\tthis._eventHandler({\n\t\t\ttarget: anchor,\n\t\t\tcurrentTarget: anchor,\n\t\t\tpreventDefault: $.noop\n\t\t});\n\t},\n\n\t_findActive: function( index ) {\n\t\treturn index === false ? $() : this.tabs.eq( index );\n\t},\n\n\t_getIndex: function( index ) {\n\t\t// meta-function to give users option to provide a href string instead of a numerical index.\n\t\tif ( typeof index === "string" ) {\n\t\t\tindex = this.anchors.index( this.anchors.filter( "[href$=\'" + index + "\']" ) );\n\t\t}\n\n\t\treturn index;\n\t},\n\n\t_destroy: function() {\n\t\tif ( this.xhr ) {\n\t\t\tthis.xhr.abort();\n\t\t}\n\n\t\tthis.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );\n\n\t\tthis.tablist\n\t\t\t.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )\n\t\t\t.removeAttr( "role" );\n\n\t\tthis.anchors\n\t\t\t.removeClass( "ui-tabs-anchor" )\n\t\t\t.removeAttr( "role" )\n\t\t\t.removeAttr( "tabIndex" )\n\t\t\t.removeUniqueId();\n\n\t\tthis.tablist.unbind( this.eventNamespace );\n\n\t\tthis.tabs.add( this.panels ).each(function() {\n\t\t\tif ( $.data( this, "ui-tabs-destroy" ) ) {\n\t\t\t\t$( this ).remove();\n\t\t\t} else {\n\t\t\t\t$( this )\n\t\t\t\t\t.removeClass( "ui-state-default ui-state-active ui-state-disabled " +\n\t\t\t\t\t\t"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )\n\t\t\t\t\t.removeAttr( "tabIndex" )\n\t\t\t\t\t.removeAttr( "aria-live" )\n\t\t\t\t\t.removeAttr( "aria-busy" )\n\t\t\t\t\t.removeAttr( "aria-selected" )\n\t\t\t\t\t.removeAttr( "aria-labelledby" )\n\t\t\t\t\t.removeAttr( "aria-hidden" )\n\t\t\t\t\t.removeAttr( "aria-expanded" )\n\t\t\t\t\t.removeAttr( "role" );\n\t\t\t}\n\t\t});\n\n\t\tthis.tabs.each(function() {\n\t\t\tvar li = $( this ),\n\t\t\t\tprev = li.data( "ui-tabs-aria-controls" );\n\t\t\tif ( prev ) {\n\t\t\t\tli\n\t\t\t\t\t.attr( "aria-controls", prev )\n\t\t\t\t\t.removeData( "ui-tabs-aria-controls" );\n\t\t\t} else {\n\t\t\t\tli.removeAttr( "aria-controls" );\n\t\t\t}\n\t\t});\n\n\t\tthis.panels.show();\n\n\t\tif ( this.options.heightStyle !== "content" ) {\n\t\t\tthis.panels.css( "height", "" );\n\t\t}\n\t},\n\n\tenable: function( index ) {\n\t\tvar disabled = this.options.disabled;\n\t\tif ( disabled === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( index === undefined ) {\n\t\t\tdisabled = false;\n\t\t} else {\n\t\t\tindex = this._getIndex( index );\n\t\t\tif ( $.isArray( disabled ) ) {\n\t\t\t\tdisabled = $.map( disabled, function( num ) {\n\t\t\t\t\treturn num !== index ? num : null;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdisabled = $.map( this.tabs, function( li, num ) {\n\t\t\t\t\treturn num !== index ? num : null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tthis._setupDisabled( disabled );\n\t},\n\n\tdisable: function( index ) {\n\t\tvar disabled = this.options.disabled;\n\t\tif ( disabled === true ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( index === undefined ) {\n\t\t\tdisabled = true;\n\t\t} else {\n\t\t\tindex = this._getIndex( index );\n\t\t\tif ( $.inArray( index, disabled ) !== -1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( $.isArray( disabled ) ) {\n\t\t\t\tdisabled = $.merge( [ index ], disabled ).sort();\n\t\t\t} else {\n\t\t\t\tdisabled = [ index ];\n\t\t\t}\n\t\t}\n\t\tthis._setupDisabled( disabled );\n\t},\n\n\tload: function( index, event ) {\n\t\tindex = this._getIndex( index );\n\t\tvar that = this,\n\t\t\ttab = this.tabs.eq( index ),\n\t\t\tanchor = tab.find( ".ui-tabs-anchor" ),\n\t\t\tpanel = this._getPanelForTab( tab ),\n\t\t\teventData = {\n\t\t\t\ttab: tab,\n\t\t\t\tpanel: panel\n\t\t\t},\n\t\t\tcomplete = function( jqXHR, status ) {\n\t\t\t\tif ( status === "abort" ) {\n\t\t\t\t\tthat.panels.stop( false, true );\n\t\t\t\t}\n\n\t\t\t\ttab.removeClass( "ui-tabs-loading" );\n\t\t\t\tpanel.removeAttr( "aria-busy" );\n\n\t\t\t\tif ( jqXHR === that.xhr ) {\n\t\t\t\t\tdelete that.xhr;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// not remote\n\t\tif ( this._isLocal( anchor[ 0 ] ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );\n\n\t\t// support: jQuery <1.8\n\t\t// jQuery <1.8 returns false if the request is canceled in beforeSend,\n\t\t// but as of 1.8, $.ajax() always returns a jqXHR object.\n\t\tif ( this.xhr && this.xhr.statusText !== "canceled" ) {\n\t\t\ttab.addClass( "ui-tabs-loading" );\n\t\t\tpanel.attr( "aria-busy", "true" );\n\n\t\t\tthis.xhr\n\t\t\t\t.done(function( response, status, jqXHR ) {\n\t\t\t\t\t// support: jQuery <1.8\n\t\t\t\t\t// http://bugs.jquery.com/ticket/11778\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tpanel.html( response );\n\t\t\t\t\t\tthat._trigger( "load", event, eventData );\n\n\t\t\t\t\t\tcomplete( jqXHR, status );\n\t\t\t\t\t}, 1 );\n\t\t\t\t})\n\t\t\t\t.fail(function( jqXHR, status ) {\n\t\t\t\t\t// support: jQuery <1.8\n\t\t\t\t\t// http://bugs.jquery.com/ticket/11778\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tcomplete( jqXHR, status );\n\t\t\t\t\t}, 1 );\n\t\t\t\t});\n\t\t}\n\t},\n\n\t_ajaxSettings: function( anchor, event, eventData ) {\n\t\tvar that = this;\n\t\treturn {\n\t\t\turl: anchor.attr( "href" ),\n\t\t\tbeforeSend: function( jqXHR, settings ) {\n\t\t\t\treturn that._trigger( "beforeLoad", event,\n\t\t\t\t\t$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );\n\t\t\t}\n\t\t};\n\t},\n\n\t_getPanelForTab: function( tab ) {\n\t\tvar id = $( tab ).attr( "aria-controls" );\n\t\treturn this.element.find( this._sanitizeSelector( "#" + id ) );\n\t}\n});\n\n\n/*!\n * jQuery UI Tooltip 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/tooltip/\n */\n\n\nvar tooltip = $.widget( "ui.tooltip", {\n\tversion: "1.11.4",\n\toptions: {\n\t\tcontent: function() {\n\t\t\t// support: IE<9, Opera in jQuery <1.7\n\t\t\t// .text() can\'t accept undefined, so coerce to a string\n\t\t\tvar title = $( this ).attr( "title" ) || "";\n\t\t\t// Escape title, since we\'re going from an attribute to raw HTML\n\t\t\treturn $( "<a>" ).text( title ).html();\n\t\t},\n\t\thide: true,\n\t\t// Disabled elements have inconsistent behavior across browsers (#8661)\n\t\titems: "[title]:not([disabled])",\n\t\tposition: {\n\t\t\tmy: "left top+15",\n\t\t\tat: "left bottom",\n\t\t\tcollision: "flipfit flip"\n\t\t},\n\t\tshow: true,\n\t\ttooltipClass: null,\n\t\ttrack: false,\n\n\t\t// callbacks\n\t\tclose: null,\n\t\topen: null\n\t},\n\n\t_addDescribedBy: function( elem, id ) {\n\t\tvar describedby = (elem.attr( "aria-describedby" ) || "").split( /\\s+/ );\n\t\tdescribedby.push( id );\n\t\telem\n\t\t\t.data( "ui-tooltip-id", id )\n\t\t\t.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );\n\t},\n\n\t_removeDescribedBy: function( elem ) {\n\t\tvar id = elem.data( "ui-tooltip-id" ),\n\t\t\tdescribedby = (elem.attr( "aria-describedby" ) || "").split( /\\s+/ ),\n\t\t\tindex = $.inArray( id, describedby );\n\n\t\tif ( index !== -1 ) {\n\t\t\tdescribedby.splice( index, 1 );\n\t\t}\n\n\t\telem.removeData( "ui-tooltip-id" );\n\t\tdescribedby = $.trim( describedby.join( " " ) );\n\t\tif ( describedby ) {\n\t\t\telem.attr( "aria-describedby", describedby );\n\t\t} else {\n\t\t\telem.removeAttr( "aria-describedby" );\n\t\t}\n\t},\n\n\t_create: function() {\n\t\tthis._on({\n\t\t\tmouseover: "open",\n\t\t\tfocusin: "open"\n\t\t});\n\n\t\t// IDs of generated tooltips, needed for destroy\n\t\tthis.tooltips = {};\n\n\t\t// IDs of parent tooltips where we removed the title attribute\n\t\tthis.parents = {};\n\n\t\tif ( this.options.disabled ) {\n\t\t\tthis._disable();\n\t\t}\n\n\t\t// Append the aria-live region so tooltips announce correctly\n\t\tthis.liveRegion = $( "<div>" )\n\t\t\t.attr({\n\t\t\t\trole: "log",\n\t\t\t\t"aria-live": "assertive",\n\t\t\t\t"aria-relevant": "additions"\n\t\t\t})\n\t\t\t.addClass( "ui-helper-hidden-accessible" )\n\t\t\t.appendTo( this.document[ 0 ].body );\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tvar that = this;\n\n\t\tif ( key === "disabled" ) {\n\t\t\tthis[ value ? "_disable" : "_enable" ]();\n\t\t\tthis.options[ key ] = value;\n\t\t\t// disable element style changes\n\t\t\treturn;\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\tif ( key === "content" ) {\n\t\t\t$.each( this.tooltips, function( id, tooltipData ) {\n\t\t\t\tthat._updateContent( tooltipData.element );\n\t\t\t});\n\t\t}\n\t},\n\n\t_disable: function() {\n\t\tvar that = this;\n\n\t\t// close open tooltips\n\t\t$.each( this.tooltips, function( id, tooltipData ) {\n\t\t\tvar event = $.Event( "blur" );\n\t\t\tevent.target = event.currentTarget = tooltipData.element[ 0 ];\n\t\t\tthat.close( event, true );\n\t\t});\n\n\t\t// remove title attributes to prevent native tooltips\n\t\tthis.element.find( this.options.items ).addBack().each(function() {\n\t\t\tvar element = $( this );\n\t\t\tif ( element.is( "[title]" ) ) {\n\t\t\t\telement\n\t\t\t\t\t.data( "ui-tooltip-title", element.attr( "title" ) )\n\t\t\t\t\t.removeAttr( "title" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_enable: function() {\n\t\t// restore title attributes\n\t\tthis.element.find( this.options.items ).addBack().each(function() {\n\t\t\tvar element = $( this );\n\t\t\tif ( element.data( "ui-tooltip-title" ) ) {\n\t\t\t\telement.attr( "title", element.data( "ui-tooltip-title" ) );\n\t\t\t}\n\t\t});\n\t},\n\n\topen: function( event ) {\n\t\tvar that = this,\n\t\t\ttarget = $( event ? event.target : this.element )\n\t\t\t\t// we need closest here due to mouseover bubbling,\n\t\t\t\t// but always pointing at the same event target\n\t\t\t\t.closest( this.options.items );\n\n\t\t// No element to show a tooltip for or the tooltip is already open\n\t\tif ( !target.length || target.data( "ui-tooltip-id" ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( target.attr( "title" ) ) {\n\t\t\ttarget.data( "ui-tooltip-title", target.attr( "title" ) );\n\t\t}\n\n\t\ttarget.data( "ui-tooltip-open", true );\n\n\t\t// kill parent tooltips, custom or native, for hover\n\t\tif ( event && event.type === "mouseover" ) {\n\t\t\ttarget.parents().each(function() {\n\t\t\t\tvar parent = $( this ),\n\t\t\t\t\tblurEvent;\n\t\t\t\tif ( parent.data( "ui-tooltip-open" ) ) {\n\t\t\t\t\tblurEvent = $.Event( "blur" );\n\t\t\t\t\tblurEvent.target = blurEvent.currentTarget = this;\n\t\t\t\t\tthat.close( blurEvent, true );\n\t\t\t\t}\n\t\t\t\tif ( parent.attr( "title" ) ) {\n\t\t\t\t\tparent.uniqueId();\n\t\t\t\t\tthat.parents[ this.id ] = {\n\t\t\t\t\t\telement: this,\n\t\t\t\t\t\ttitle: parent.attr( "title" )\n\t\t\t\t\t};\n\t\t\t\t\tparent.attr( "title", "" );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis._registerCloseHandlers( event, target );\n\t\tthis._updateContent( target, event );\n\t},\n\n\t_updateContent: function( target, event ) {\n\t\tvar content,\n\t\t\tcontentOption = this.options.content,\n\t\t\tthat = this,\n\t\t\teventType = event ? event.type : null;\n\n\t\tif ( typeof contentOption === "string" ) {\n\t\t\treturn this._open( event, target, contentOption );\n\t\t}\n\n\t\tcontent = contentOption.call( target[0], function( response ) {\n\n\t\t\t// IE may instantly serve a cached response for ajax requests\n\t\t\t// delay this call to _open so the other call to _open runs first\n\t\t\tthat._delay(function() {\n\n\t\t\t\t// Ignore async response if tooltip was closed already\n\t\t\t\tif ( !target.data( "ui-tooltip-open" ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// jQuery creates a special event for focusin when it doesn\'t\n\t\t\t\t// exist natively. To improve performance, the native event\n\t\t\t\t// object is reused and the type is changed. Therefore, we can\'t\n\t\t\t\t// rely on the type being correct after the event finished\n\t\t\t\t// bubbling, so we set it back to the previous value. (#8740)\n\t\t\t\tif ( event ) {\n\t\t\t\t\tevent.type = eventType;\n\t\t\t\t}\n\t\t\t\tthis._open( event, target, response );\n\t\t\t});\n\t\t});\n\t\tif ( content ) {\n\t\t\tthis._open( event, target, content );\n\t\t}\n\t},\n\n\t_open: function( event, target, content ) {\n\t\tvar tooltipData, tooltip, delayedShow, a11yContent,\n\t\t\tpositionOption = $.extend( {}, this.options.position );\n\n\t\tif ( !content ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Content can be updated multiple times. If the tooltip already\n\t\t// exists, then just update the content and bail.\n\t\ttooltipData = this._find( target );\n\t\tif ( tooltipData ) {\n\t\t\ttooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have a title, clear it to prevent the native tooltip\n\t\t// we have to check first to avoid defining a title if none exists\n\t\t// (we don\'t want to cause an element to start matching [title])\n\t\t//\n\t\t// We use removeAttr only for key events, to allow IE to export the correct\n\t\t// accessible attributes. For mouse events, set to empty string to avoid\n\t\t// native tooltip showing up (happens only when removing inside mouseover).\n\t\tif ( target.is( "[title]" ) ) {\n\t\t\tif ( event && event.type === "mouseover" ) {\n\t\t\t\ttarget.attr( "title", "" );\n\t\t\t} else {\n\t\t\t\ttarget.removeAttr( "title" );\n\t\t\t}\n\t\t}\n\n\t\ttooltipData = this._tooltip( target );\n\t\ttooltip = tooltipData.tooltip;\n\t\tthis._addDescribedBy( target, tooltip.attr( "id" ) );\n\t\ttooltip.find( ".ui-tooltip-content" ).html( content );\n\n\t\t// Support: Voiceover on OS X, JAWS on IE <= 9\n\t\t// JAWS announces deletions even when aria-relevant="additions"\n\t\t// Voiceover will sometimes re-read the entire log region\'s contents from the beginning\n\t\tthis.liveRegion.children().hide();\n\t\tif ( content.clone ) {\n\t\t\ta11yContent = content.clone();\n\t\t\ta11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );\n\t\t} else {\n\t\t\ta11yContent = content;\n\t\t}\n\t\t$( "<div>" ).html( a11yContent ).appendTo( this.liveRegion );\n\n\t\tfunction position( event ) {\n\t\t\tpositionOption.of = event;\n\t\t\tif ( tooltip.is( ":hidden" ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttooltip.position( positionOption );\n\t\t}\n\t\tif ( this.options.track && event && /^mouse/.test( event.type ) ) {\n\t\t\tthis._on( this.document, {\n\t\t\t\tmousemove: position\n\t\t\t});\n\t\t\t// trigger once to override element-relative positioning\n\t\t\tposition( event );\n\t\t} else {\n\t\t\ttooltip.position( $.extend({\n\t\t\t\tof: target\n\t\t\t}, this.options.position ) );\n\t\t}\n\n\t\ttooltip.hide();\n\n\t\tthis._show( tooltip, this.options.show );\n\t\t// Handle tracking tooltips that are shown with a delay (#8644). As soon\n\t\t// as the tooltip is visible, position the tooltip using the most recent\n\t\t// event.\n\t\tif ( this.options.show && this.options.show.delay ) {\n\t\t\tdelayedShow = this.delayedShow = setInterval(function() {\n\t\t\t\tif ( tooltip.is( ":visible" ) ) {\n\t\t\t\t\tposition( positionOption.of );\n\t\t\t\t\tclearInterval( delayedShow );\n\t\t\t\t}\n\t\t\t}, $.fx.interval );\n\t\t}\n\n\t\tthis._trigger( "open", event, { tooltip: tooltip } );\n\t},\n\n\t_registerCloseHandlers: function( event, target ) {\n\t\tvar events = {\n\t\t\tkeyup: function( event ) {\n\t\t\t\tif ( event.keyCode === $.ui.keyCode.ESCAPE ) {\n\t\t\t\t\tvar fakeEvent = $.Event(event);\n\t\t\t\t\tfakeEvent.currentTarget = target[0];\n\t\t\t\t\tthis.close( fakeEvent, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Only bind remove handler for delegated targets. Non-delegated\n\t\t// tooltips will handle this in destroy.\n\t\tif ( target[ 0 ] !== this.element[ 0 ] ) {\n\t\t\tevents.remove = function() {\n\t\t\t\tthis._removeTooltip( this._find( target ).tooltip );\n\t\t\t};\n\t\t}\n\n\t\tif ( !event || event.type === "mouseover" ) {\n\t\t\tevents.mouseleave = "close";\n\t\t}\n\t\tif ( !event || event.type === "focusin" ) {\n\t\t\tevents.focusout = "close";\n\t\t}\n\t\tthis._on( true, target, events );\n\t},\n\n\tclose: function( event ) {\n\t\tvar tooltip,\n\t\t\tthat = this,\n\t\t\ttarget = $( event ? event.currentTarget : this.element ),\n\t\t\ttooltipData = this._find( target );\n\n\t\t// The tooltip may already be closed\n\t\tif ( !tooltipData ) {\n\n\t\t\t// We set ui-tooltip-open immediately upon open (in open()), but only set the\n\t\t\t// additional data once there\'s actually content to show (in _open()). So even if the\n\t\t\t// tooltip doesn\'t have full data, we always remove ui-tooltip-open in case we\'re in\n\t\t\t// the period between open() and _open().\n\t\t\ttarget.removeData( "ui-tooltip-open" );\n\t\t\treturn;\n\t\t}\n\n\t\ttooltip = tooltipData.tooltip;\n\n\t\t// disabling closes the tooltip, so we need to track when we\'re closing\n\t\t// to avoid an infinite loop in case the tooltip becomes disabled on close\n\t\tif ( tooltipData.closing ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear the interval for delayed tracking tooltips\n\t\tclearInterval( this.delayedShow );\n\n\t\t// only set title if we had one before (see comment in _open())\n\t\t// If the title attribute has changed since open(), don\'t restore\n\t\tif ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {\n\t\t\ttarget.attr( "title", target.data( "ui-tooltip-title" ) );\n\t\t}\n\n\t\tthis._removeDescribedBy( target );\n\n\t\ttooltipData.hiding = true;\n\t\ttooltip.stop( true );\n\t\tthis._hide( tooltip, this.options.hide, function() {\n\t\t\tthat._removeTooltip( $( this ) );\n\t\t});\n\n\t\ttarget.removeData( "ui-tooltip-open" );\n\t\tthis._off( target, "mouseleave focusout keyup" );\n\n\t\t// Remove \'remove\' binding only on delegated targets\n\t\tif ( target[ 0 ] !== this.element[ 0 ] ) {\n\t\t\tthis._off( target, "remove" );\n\t\t}\n\t\tthis._off( this.document, "mousemove" );\n\n\t\tif ( event && event.type === "mouseleave" ) {\n\t\t\t$.each( this.parents, function( id, parent ) {\n\t\t\t\t$( parent.element ).attr( "title", parent.title );\n\t\t\t\tdelete that.parents[ id ];\n\t\t\t});\n\t\t}\n\n\t\ttooltipData.closing = true;\n\t\tthis._trigger( "close", event, { tooltip: tooltip } );\n\t\tif ( !tooltipData.hiding ) {\n\t\t\ttooltipData.closing = false;\n\t\t}\n\t},\n\n\t_tooltip: function( element ) {\n\t\tvar tooltip = $( "<div>" )\n\t\t\t\t.attr( "role", "tooltip" )\n\t\t\t\t.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +\n\t\t\t\t\t( this.options.tooltipClass || "" ) ),\n\t\t\tid = tooltip.uniqueId().attr( "id" );\n\n\t\t$( "<div>" )\n\t\t\t.addClass( "ui-tooltip-content" )\n\t\t\t.appendTo( tooltip );\n\n\t\ttooltip.appendTo( this.document[0].body );\n\n\t\treturn this.tooltips[ id ] = {\n\t\t\telement: element,\n\t\t\ttooltip: tooltip\n\t\t};\n\t},\n\n\t_find: function( target ) {\n\t\tvar id = target.data( "ui-tooltip-id" );\n\t\treturn id ? this.tooltips[ id ] : null;\n\t},\n\n\t_removeTooltip: function( tooltip ) {\n\t\ttooltip.remove();\n\t\tdelete this.tooltips[ tooltip.attr( "id" ) ];\n\t},\n\n\t_destroy: function() {\n\t\tvar that = this;\n\n\t\t// close open tooltips\n\t\t$.each( this.tooltips, function( id, tooltipData ) {\n\t\t\t// Delegate to close method to handle common cleanup\n\t\t\tvar event = $.Event( "blur" ),\n\t\t\t\telement = tooltipData.element;\n\t\t\tevent.target = event.currentTarget = element[ 0 ];\n\t\t\tthat.close( event, true );\n\n\t\t\t// Remove immediately; destroying an open tooltip doesn\'t use the\n\t\t\t// hide animation\n\t\t\t$( "#" + id ).remove();\n\n\t\t\t// Restore the title\n\t\t\tif ( element.data( "ui-tooltip-title" ) ) {\n\t\t\t\t// If the title attribute has changed since open(), don\'t restore\n\t\t\t\tif ( !element.attr( "title" ) ) {\n\t\t\t\t\telement.attr( "title", element.data( "ui-tooltip-title" ) );\n\t\t\t\t}\n\t\t\t\telement.removeData( "ui-tooltip-title" );\n\t\t\t}\n\t\t});\n\t\tthis.liveRegion.remove();\n\t}\n});\n\n\n\n}));'}});